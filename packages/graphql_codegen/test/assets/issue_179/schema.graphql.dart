class Input$AddProjectToSecurityDashboardInput {
  factory Input$AddProjectToSecurityDashboardInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$AddProjectToSecurityDashboardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$AddProjectToSecurityDashboardInput._(this._$data);

  factory Input$AddProjectToSecurityDashboardInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$AddProjectToSecurityDashboardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$AddProjectToSecurityDashboardInput<
          Input$AddProjectToSecurityDashboardInput>
      get copyWith => CopyWith$Input$AddProjectToSecurityDashboardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectToSecurityDashboardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectToSecurityDashboardInput<TRes> {
  factory CopyWith$Input$AddProjectToSecurityDashboardInput(
    Input$AddProjectToSecurityDashboardInput instance,
    TRes Function(Input$AddProjectToSecurityDashboardInput) then,
  ) = _CopyWithImpl$Input$AddProjectToSecurityDashboardInput;

  factory CopyWith$Input$AddProjectToSecurityDashboardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectToSecurityDashboardInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$AddProjectToSecurityDashboardInput<TRes>
    implements CopyWith$Input$AddProjectToSecurityDashboardInput<TRes> {
  _CopyWithImpl$Input$AddProjectToSecurityDashboardInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectToSecurityDashboardInput _instance;

  final TRes Function(Input$AddProjectToSecurityDashboardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$AddProjectToSecurityDashboardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectToSecurityDashboardInput<TRes>
    implements CopyWith$Input$AddProjectToSecurityDashboardInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectToSecurityDashboardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$AdminSidekiqQueuesDeleteJobsInput {
  factory Input$AdminSidekiqQueuesDeleteJobsInput({
    String? clientMutationId,
    String? user,
    String? project,
    String? rootNamespace,
    String? clientId,
    String? callerId,
    String? remoteIp,
    String? jobId,
    String? pipelineId,
    String? relatedClass,
    String? featureCategory,
    String? artifactSize,
    String? artifactsDependenciesSize,
    String? artifactsDependenciesCount,
    String? rootCallerId,
    String? subscriptionPlan,
    String? workerClass,
    required String queueName,
  }) =>
      Input$AdminSidekiqQueuesDeleteJobsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (user != null) r'user': user,
        if (project != null) r'project': project,
        if (rootNamespace != null) r'rootNamespace': rootNamespace,
        if (clientId != null) r'clientId': clientId,
        if (callerId != null) r'callerId': callerId,
        if (remoteIp != null) r'remoteIp': remoteIp,
        if (jobId != null) r'jobId': jobId,
        if (pipelineId != null) r'pipelineId': pipelineId,
        if (relatedClass != null) r'relatedClass': relatedClass,
        if (featureCategory != null) r'featureCategory': featureCategory,
        if (artifactSize != null) r'artifactSize': artifactSize,
        if (artifactsDependenciesSize != null)
          r'artifactsDependenciesSize': artifactsDependenciesSize,
        if (artifactsDependenciesCount != null)
          r'artifactsDependenciesCount': artifactsDependenciesCount,
        if (rootCallerId != null) r'rootCallerId': rootCallerId,
        if (subscriptionPlan != null) r'subscriptionPlan': subscriptionPlan,
        if (workerClass != null) r'workerClass': workerClass,
        r'queueName': queueName,
      });

  Input$AdminSidekiqQueuesDeleteJobsInput._(this._$data);

  factory Input$AdminSidekiqQueuesDeleteJobsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = (l$user as String?);
    }
    if (data.containsKey('project')) {
      final l$project = data['project'];
      result$data['project'] = (l$project as String?);
    }
    if (data.containsKey('rootNamespace')) {
      final l$rootNamespace = data['rootNamespace'];
      result$data['rootNamespace'] = (l$rootNamespace as String?);
    }
    if (data.containsKey('clientId')) {
      final l$clientId = data['clientId'];
      result$data['clientId'] = (l$clientId as String?);
    }
    if (data.containsKey('callerId')) {
      final l$callerId = data['callerId'];
      result$data['callerId'] = (l$callerId as String?);
    }
    if (data.containsKey('remoteIp')) {
      final l$remoteIp = data['remoteIp'];
      result$data['remoteIp'] = (l$remoteIp as String?);
    }
    if (data.containsKey('jobId')) {
      final l$jobId = data['jobId'];
      result$data['jobId'] = (l$jobId as String?);
    }
    if (data.containsKey('pipelineId')) {
      final l$pipelineId = data['pipelineId'];
      result$data['pipelineId'] = (l$pipelineId as String?);
    }
    if (data.containsKey('relatedClass')) {
      final l$relatedClass = data['relatedClass'];
      result$data['relatedClass'] = (l$relatedClass as String?);
    }
    if (data.containsKey('featureCategory')) {
      final l$featureCategory = data['featureCategory'];
      result$data['featureCategory'] = (l$featureCategory as String?);
    }
    if (data.containsKey('artifactSize')) {
      final l$artifactSize = data['artifactSize'];
      result$data['artifactSize'] = (l$artifactSize as String?);
    }
    if (data.containsKey('artifactsDependenciesSize')) {
      final l$artifactsDependenciesSize = data['artifactsDependenciesSize'];
      result$data['artifactsDependenciesSize'] =
          (l$artifactsDependenciesSize as String?);
    }
    if (data.containsKey('artifactsDependenciesCount')) {
      final l$artifactsDependenciesCount = data['artifactsDependenciesCount'];
      result$data['artifactsDependenciesCount'] =
          (l$artifactsDependenciesCount as String?);
    }
    if (data.containsKey('rootCallerId')) {
      final l$rootCallerId = data['rootCallerId'];
      result$data['rootCallerId'] = (l$rootCallerId as String?);
    }
    if (data.containsKey('subscriptionPlan')) {
      final l$subscriptionPlan = data['subscriptionPlan'];
      result$data['subscriptionPlan'] = (l$subscriptionPlan as String?);
    }
    if (data.containsKey('workerClass')) {
      final l$workerClass = data['workerClass'];
      result$data['workerClass'] = (l$workerClass as String?);
    }
    final l$queueName = data['queueName'];
    result$data['queueName'] = (l$queueName as String);
    return Input$AdminSidekiqQueuesDeleteJobsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get user => (_$data['user'] as String?);
  String? get project => (_$data['project'] as String?);
  String? get rootNamespace => (_$data['rootNamespace'] as String?);
  String? get clientId => (_$data['clientId'] as String?);
  String? get callerId => (_$data['callerId'] as String?);
  String? get remoteIp => (_$data['remoteIp'] as String?);
  String? get jobId => (_$data['jobId'] as String?);
  String? get pipelineId => (_$data['pipelineId'] as String?);
  String? get relatedClass => (_$data['relatedClass'] as String?);
  String? get featureCategory => (_$data['featureCategory'] as String?);
  String? get artifactSize => (_$data['artifactSize'] as String?);
  String? get artifactsDependenciesSize =>
      (_$data['artifactsDependenciesSize'] as String?);
  String? get artifactsDependenciesCount =>
      (_$data['artifactsDependenciesCount'] as String?);
  String? get rootCallerId => (_$data['rootCallerId'] as String?);
  String? get subscriptionPlan => (_$data['subscriptionPlan'] as String?);
  String? get workerClass => (_$data['workerClass'] as String?);
  String get queueName => (_$data['queueName'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user;
    }
    if (_$data.containsKey('project')) {
      final l$project = project;
      result$data['project'] = l$project;
    }
    if (_$data.containsKey('rootNamespace')) {
      final l$rootNamespace = rootNamespace;
      result$data['rootNamespace'] = l$rootNamespace;
    }
    if (_$data.containsKey('clientId')) {
      final l$clientId = clientId;
      result$data['clientId'] = l$clientId;
    }
    if (_$data.containsKey('callerId')) {
      final l$callerId = callerId;
      result$data['callerId'] = l$callerId;
    }
    if (_$data.containsKey('remoteIp')) {
      final l$remoteIp = remoteIp;
      result$data['remoteIp'] = l$remoteIp;
    }
    if (_$data.containsKey('jobId')) {
      final l$jobId = jobId;
      result$data['jobId'] = l$jobId;
    }
    if (_$data.containsKey('pipelineId')) {
      final l$pipelineId = pipelineId;
      result$data['pipelineId'] = l$pipelineId;
    }
    if (_$data.containsKey('relatedClass')) {
      final l$relatedClass = relatedClass;
      result$data['relatedClass'] = l$relatedClass;
    }
    if (_$data.containsKey('featureCategory')) {
      final l$featureCategory = featureCategory;
      result$data['featureCategory'] = l$featureCategory;
    }
    if (_$data.containsKey('artifactSize')) {
      final l$artifactSize = artifactSize;
      result$data['artifactSize'] = l$artifactSize;
    }
    if (_$data.containsKey('artifactsDependenciesSize')) {
      final l$artifactsDependenciesSize = artifactsDependenciesSize;
      result$data['artifactsDependenciesSize'] = l$artifactsDependenciesSize;
    }
    if (_$data.containsKey('artifactsDependenciesCount')) {
      final l$artifactsDependenciesCount = artifactsDependenciesCount;
      result$data['artifactsDependenciesCount'] = l$artifactsDependenciesCount;
    }
    if (_$data.containsKey('rootCallerId')) {
      final l$rootCallerId = rootCallerId;
      result$data['rootCallerId'] = l$rootCallerId;
    }
    if (_$data.containsKey('subscriptionPlan')) {
      final l$subscriptionPlan = subscriptionPlan;
      result$data['subscriptionPlan'] = l$subscriptionPlan;
    }
    if (_$data.containsKey('workerClass')) {
      final l$workerClass = workerClass;
      result$data['workerClass'] = l$workerClass;
    }
    final l$queueName = queueName;
    result$data['queueName'] = l$queueName;
    return result$data;
  }

  CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput<
          Input$AdminSidekiqQueuesDeleteJobsInput>
      get copyWith => CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AdminSidekiqQueuesDeleteJobsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$project = project;
    final lOther$project = other.project;
    if (_$data.containsKey('project') != other._$data.containsKey('project')) {
      return false;
    }
    if (l$project != lOther$project) {
      return false;
    }
    final l$rootNamespace = rootNamespace;
    final lOther$rootNamespace = other.rootNamespace;
    if (_$data.containsKey('rootNamespace') !=
        other._$data.containsKey('rootNamespace')) {
      return false;
    }
    if (l$rootNamespace != lOther$rootNamespace) {
      return false;
    }
    final l$clientId = clientId;
    final lOther$clientId = other.clientId;
    if (_$data.containsKey('clientId') !=
        other._$data.containsKey('clientId')) {
      return false;
    }
    if (l$clientId != lOther$clientId) {
      return false;
    }
    final l$callerId = callerId;
    final lOther$callerId = other.callerId;
    if (_$data.containsKey('callerId') !=
        other._$data.containsKey('callerId')) {
      return false;
    }
    if (l$callerId != lOther$callerId) {
      return false;
    }
    final l$remoteIp = remoteIp;
    final lOther$remoteIp = other.remoteIp;
    if (_$data.containsKey('remoteIp') !=
        other._$data.containsKey('remoteIp')) {
      return false;
    }
    if (l$remoteIp != lOther$remoteIp) {
      return false;
    }
    final l$jobId = jobId;
    final lOther$jobId = other.jobId;
    if (_$data.containsKey('jobId') != other._$data.containsKey('jobId')) {
      return false;
    }
    if (l$jobId != lOther$jobId) {
      return false;
    }
    final l$pipelineId = pipelineId;
    final lOther$pipelineId = other.pipelineId;
    if (_$data.containsKey('pipelineId') !=
        other._$data.containsKey('pipelineId')) {
      return false;
    }
    if (l$pipelineId != lOther$pipelineId) {
      return false;
    }
    final l$relatedClass = relatedClass;
    final lOther$relatedClass = other.relatedClass;
    if (_$data.containsKey('relatedClass') !=
        other._$data.containsKey('relatedClass')) {
      return false;
    }
    if (l$relatedClass != lOther$relatedClass) {
      return false;
    }
    final l$featureCategory = featureCategory;
    final lOther$featureCategory = other.featureCategory;
    if (_$data.containsKey('featureCategory') !=
        other._$data.containsKey('featureCategory')) {
      return false;
    }
    if (l$featureCategory != lOther$featureCategory) {
      return false;
    }
    final l$artifactSize = artifactSize;
    final lOther$artifactSize = other.artifactSize;
    if (_$data.containsKey('artifactSize') !=
        other._$data.containsKey('artifactSize')) {
      return false;
    }
    if (l$artifactSize != lOther$artifactSize) {
      return false;
    }
    final l$artifactsDependenciesSize = artifactsDependenciesSize;
    final lOther$artifactsDependenciesSize = other.artifactsDependenciesSize;
    if (_$data.containsKey('artifactsDependenciesSize') !=
        other._$data.containsKey('artifactsDependenciesSize')) {
      return false;
    }
    if (l$artifactsDependenciesSize != lOther$artifactsDependenciesSize) {
      return false;
    }
    final l$artifactsDependenciesCount = artifactsDependenciesCount;
    final lOther$artifactsDependenciesCount = other.artifactsDependenciesCount;
    if (_$data.containsKey('artifactsDependenciesCount') !=
        other._$data.containsKey('artifactsDependenciesCount')) {
      return false;
    }
    if (l$artifactsDependenciesCount != lOther$artifactsDependenciesCount) {
      return false;
    }
    final l$rootCallerId = rootCallerId;
    final lOther$rootCallerId = other.rootCallerId;
    if (_$data.containsKey('rootCallerId') !=
        other._$data.containsKey('rootCallerId')) {
      return false;
    }
    if (l$rootCallerId != lOther$rootCallerId) {
      return false;
    }
    final l$subscriptionPlan = subscriptionPlan;
    final lOther$subscriptionPlan = other.subscriptionPlan;
    if (_$data.containsKey('subscriptionPlan') !=
        other._$data.containsKey('subscriptionPlan')) {
      return false;
    }
    if (l$subscriptionPlan != lOther$subscriptionPlan) {
      return false;
    }
    final l$workerClass = workerClass;
    final lOther$workerClass = other.workerClass;
    if (_$data.containsKey('workerClass') !=
        other._$data.containsKey('workerClass')) {
      return false;
    }
    if (l$workerClass != lOther$workerClass) {
      return false;
    }
    final l$queueName = queueName;
    final lOther$queueName = other.queueName;
    if (l$queueName != lOther$queueName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$user = user;
    final l$project = project;
    final l$rootNamespace = rootNamespace;
    final l$clientId = clientId;
    final l$callerId = callerId;
    final l$remoteIp = remoteIp;
    final l$jobId = jobId;
    final l$pipelineId = pipelineId;
    final l$relatedClass = relatedClass;
    final l$featureCategory = featureCategory;
    final l$artifactSize = artifactSize;
    final l$artifactsDependenciesSize = artifactsDependenciesSize;
    final l$artifactsDependenciesCount = artifactsDependenciesCount;
    final l$rootCallerId = rootCallerId;
    final l$subscriptionPlan = subscriptionPlan;
    final l$workerClass = workerClass;
    final l$queueName = queueName;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('project') ? l$project : const {},
      _$data.containsKey('rootNamespace') ? l$rootNamespace : const {},
      _$data.containsKey('clientId') ? l$clientId : const {},
      _$data.containsKey('callerId') ? l$callerId : const {},
      _$data.containsKey('remoteIp') ? l$remoteIp : const {},
      _$data.containsKey('jobId') ? l$jobId : const {},
      _$data.containsKey('pipelineId') ? l$pipelineId : const {},
      _$data.containsKey('relatedClass') ? l$relatedClass : const {},
      _$data.containsKey('featureCategory') ? l$featureCategory : const {},
      _$data.containsKey('artifactSize') ? l$artifactSize : const {},
      _$data.containsKey('artifactsDependenciesSize')
          ? l$artifactsDependenciesSize
          : const {},
      _$data.containsKey('artifactsDependenciesCount')
          ? l$artifactsDependenciesCount
          : const {},
      _$data.containsKey('rootCallerId') ? l$rootCallerId : const {},
      _$data.containsKey('subscriptionPlan') ? l$subscriptionPlan : const {},
      _$data.containsKey('workerClass') ? l$workerClass : const {},
      l$queueName,
    ]);
  }
}

abstract class CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput<TRes> {
  factory CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput(
    Input$AdminSidekiqQueuesDeleteJobsInput instance,
    TRes Function(Input$AdminSidekiqQueuesDeleteJobsInput) then,
  ) = _CopyWithImpl$Input$AdminSidekiqQueuesDeleteJobsInput;

  factory CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AdminSidekiqQueuesDeleteJobsInput;

  TRes call({
    String? clientMutationId,
    String? user,
    String? project,
    String? rootNamespace,
    String? clientId,
    String? callerId,
    String? remoteIp,
    String? jobId,
    String? pipelineId,
    String? relatedClass,
    String? featureCategory,
    String? artifactSize,
    String? artifactsDependenciesSize,
    String? artifactsDependenciesCount,
    String? rootCallerId,
    String? subscriptionPlan,
    String? workerClass,
    String? queueName,
  });
}

class _CopyWithImpl$Input$AdminSidekiqQueuesDeleteJobsInput<TRes>
    implements CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput<TRes> {
  _CopyWithImpl$Input$AdminSidekiqQueuesDeleteJobsInput(
    this._instance,
    this._then,
  );

  final Input$AdminSidekiqQueuesDeleteJobsInput _instance;

  final TRes Function(Input$AdminSidekiqQueuesDeleteJobsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? user = _undefined,
    Object? project = _undefined,
    Object? rootNamespace = _undefined,
    Object? clientId = _undefined,
    Object? callerId = _undefined,
    Object? remoteIp = _undefined,
    Object? jobId = _undefined,
    Object? pipelineId = _undefined,
    Object? relatedClass = _undefined,
    Object? featureCategory = _undefined,
    Object? artifactSize = _undefined,
    Object? artifactsDependenciesSize = _undefined,
    Object? artifactsDependenciesCount = _undefined,
    Object? rootCallerId = _undefined,
    Object? subscriptionPlan = _undefined,
    Object? workerClass = _undefined,
    Object? queueName = _undefined,
  }) =>
      _then(Input$AdminSidekiqQueuesDeleteJobsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (user != _undefined) 'user': (user as String?),
        if (project != _undefined) 'project': (project as String?),
        if (rootNamespace != _undefined)
          'rootNamespace': (rootNamespace as String?),
        if (clientId != _undefined) 'clientId': (clientId as String?),
        if (callerId != _undefined) 'callerId': (callerId as String?),
        if (remoteIp != _undefined) 'remoteIp': (remoteIp as String?),
        if (jobId != _undefined) 'jobId': (jobId as String?),
        if (pipelineId != _undefined) 'pipelineId': (pipelineId as String?),
        if (relatedClass != _undefined)
          'relatedClass': (relatedClass as String?),
        if (featureCategory != _undefined)
          'featureCategory': (featureCategory as String?),
        if (artifactSize != _undefined)
          'artifactSize': (artifactSize as String?),
        if (artifactsDependenciesSize != _undefined)
          'artifactsDependenciesSize': (artifactsDependenciesSize as String?),
        if (artifactsDependenciesCount != _undefined)
          'artifactsDependenciesCount': (artifactsDependenciesCount as String?),
        if (rootCallerId != _undefined)
          'rootCallerId': (rootCallerId as String?),
        if (subscriptionPlan != _undefined)
          'subscriptionPlan': (subscriptionPlan as String?),
        if (workerClass != _undefined) 'workerClass': (workerClass as String?),
        if (queueName != _undefined && queueName != null)
          'queueName': (queueName as String),
      }));
}

class _CopyWithStubImpl$Input$AdminSidekiqQueuesDeleteJobsInput<TRes>
    implements CopyWith$Input$AdminSidekiqQueuesDeleteJobsInput<TRes> {
  _CopyWithStubImpl$Input$AdminSidekiqQueuesDeleteJobsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? user,
    String? project,
    String? rootNamespace,
    String? clientId,
    String? callerId,
    String? remoteIp,
    String? jobId,
    String? pipelineId,
    String? relatedClass,
    String? featureCategory,
    String? artifactSize,
    String? artifactsDependenciesSize,
    String? artifactsDependenciesCount,
    String? rootCallerId,
    String? subscriptionPlan,
    String? workerClass,
    String? queueName,
  }) =>
      _res;
}

class Input$AlertManagementPayloadAlertFieldInput {
  factory Input$AlertManagementPayloadAlertFieldInput({
    required Enum$AlertManagementPayloadAlertFieldName fieldName,
    required List<String> path,
    String? label,
    required Enum$AlertManagementPayloadAlertFieldType type,
  }) =>
      Input$AlertManagementPayloadAlertFieldInput._({
        r'fieldName': fieldName,
        r'path': path,
        if (label != null) r'label': label,
        r'type': type,
      });

  Input$AlertManagementPayloadAlertFieldInput._(this._$data);

  factory Input$AlertManagementPayloadAlertFieldInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$fieldName = data['fieldName'];
    result$data['fieldName'] =
        fromJson$Enum$AlertManagementPayloadAlertFieldName(
            (l$fieldName as String));
    final l$path = data['path'];
    result$data['path'] =
        (l$path as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('label')) {
      final l$label = data['label'];
      result$data['label'] = (l$label as String?);
    }
    final l$type = data['type'];
    result$data['type'] =
        fromJson$Enum$AlertManagementPayloadAlertFieldType((l$type as String));
    return Input$AlertManagementPayloadAlertFieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AlertManagementPayloadAlertFieldName get fieldName =>
      (_$data['fieldName'] as Enum$AlertManagementPayloadAlertFieldName);
  List<String> get path => (_$data['path'] as List<String>);
  String? get label => (_$data['label'] as String?);
  Enum$AlertManagementPayloadAlertFieldType get type =>
      (_$data['type'] as Enum$AlertManagementPayloadAlertFieldType);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$fieldName = fieldName;
    result$data['fieldName'] =
        toJson$Enum$AlertManagementPayloadAlertFieldName(l$fieldName);
    final l$path = path;
    result$data['path'] = l$path.map((e) => e).toList();
    if (_$data.containsKey('label')) {
      final l$label = label;
      result$data['label'] = l$label;
    }
    final l$type = type;
    result$data['type'] =
        toJson$Enum$AlertManagementPayloadAlertFieldType(l$type);
    return result$data;
  }

  CopyWith$Input$AlertManagementPayloadAlertFieldInput<
          Input$AlertManagementPayloadAlertFieldInput>
      get copyWith => CopyWith$Input$AlertManagementPayloadAlertFieldInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AlertManagementPayloadAlertFieldInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fieldName = fieldName;
    final lOther$fieldName = other.fieldName;
    if (l$fieldName != lOther$fieldName) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path.length != lOther$path.length) {
      return false;
    }
    for (int i = 0; i < l$path.length; i++) {
      final l$path$entry = l$path[i];
      final lOther$path$entry = lOther$path[i];
      if (l$path$entry != lOther$path$entry) {
        return false;
      }
    }
    final l$label = label;
    final lOther$label = other.label;
    if (_$data.containsKey('label') != other._$data.containsKey('label')) {
      return false;
    }
    if (l$label != lOther$label) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fieldName = fieldName;
    final l$path = path;
    final l$label = label;
    final l$type = type;
    return Object.hashAll([
      l$fieldName,
      Object.hashAll(l$path.map((v) => v)),
      _$data.containsKey('label') ? l$label : const {},
      l$type,
    ]);
  }
}

abstract class CopyWith$Input$AlertManagementPayloadAlertFieldInput<TRes> {
  factory CopyWith$Input$AlertManagementPayloadAlertFieldInput(
    Input$AlertManagementPayloadAlertFieldInput instance,
    TRes Function(Input$AlertManagementPayloadAlertFieldInput) then,
  ) = _CopyWithImpl$Input$AlertManagementPayloadAlertFieldInput;

  factory CopyWith$Input$AlertManagementPayloadAlertFieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AlertManagementPayloadAlertFieldInput;

  TRes call({
    Enum$AlertManagementPayloadAlertFieldName? fieldName,
    List<String>? path,
    String? label,
    Enum$AlertManagementPayloadAlertFieldType? type,
  });
}

class _CopyWithImpl$Input$AlertManagementPayloadAlertFieldInput<TRes>
    implements CopyWith$Input$AlertManagementPayloadAlertFieldInput<TRes> {
  _CopyWithImpl$Input$AlertManagementPayloadAlertFieldInput(
    this._instance,
    this._then,
  );

  final Input$AlertManagementPayloadAlertFieldInput _instance;

  final TRes Function(Input$AlertManagementPayloadAlertFieldInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fieldName = _undefined,
    Object? path = _undefined,
    Object? label = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$AlertManagementPayloadAlertFieldInput._({
        ..._instance._$data,
        if (fieldName != _undefined && fieldName != null)
          'fieldName': (fieldName as Enum$AlertManagementPayloadAlertFieldName),
        if (path != _undefined && path != null) 'path': (path as List<String>),
        if (label != _undefined) 'label': (label as String?),
        if (type != _undefined && type != null)
          'type': (type as Enum$AlertManagementPayloadAlertFieldType),
      }));
}

class _CopyWithStubImpl$Input$AlertManagementPayloadAlertFieldInput<TRes>
    implements CopyWith$Input$AlertManagementPayloadAlertFieldInput<TRes> {
  _CopyWithStubImpl$Input$AlertManagementPayloadAlertFieldInput(this._res);

  TRes _res;

  call({
    Enum$AlertManagementPayloadAlertFieldName? fieldName,
    List<String>? path,
    String? label,
    Enum$AlertManagementPayloadAlertFieldType? type,
  }) =>
      _res;
}

class Input$AlertSetAssigneesInput {
  factory Input$AlertSetAssigneesInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      Input$AlertSetAssigneesInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'assigneeUsernames': assigneeUsernames,
        if (operationMode != null) r'operationMode': operationMode,
      });

  Input$AlertSetAssigneesInput._(this._$data);

  factory Input$AlertSetAssigneesInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$assigneeUsernames = data['assigneeUsernames'];
    result$data['assigneeUsernames'] = (l$assigneeUsernames as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    if (data.containsKey('operationMode')) {
      final l$operationMode = data['operationMode'];
      result$data['operationMode'] = l$operationMode == null
          ? null
          : fromJson$Enum$MutationOperationMode((l$operationMode as String));
    }
    return Input$AlertSetAssigneesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get assigneeUsernames =>
      (_$data['assigneeUsernames'] as List<String>);
  Enum$MutationOperationMode? get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$assigneeUsernames = assigneeUsernames;
    result$data['assigneeUsernames'] =
        l$assigneeUsernames.map((e) => e).toList();
    if (_$data.containsKey('operationMode')) {
      final l$operationMode = operationMode;
      result$data['operationMode'] = l$operationMode == null
          ? null
          : toJson$Enum$MutationOperationMode(l$operationMode);
    }
    return result$data;
  }

  CopyWith$Input$AlertSetAssigneesInput<Input$AlertSetAssigneesInput>
      get copyWith => CopyWith$Input$AlertSetAssigneesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AlertSetAssigneesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$assigneeUsernames = assigneeUsernames;
    final lOther$assigneeUsernames = other.assigneeUsernames;
    if (l$assigneeUsernames.length != lOther$assigneeUsernames.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeUsernames.length; i++) {
      final l$assigneeUsernames$entry = l$assigneeUsernames[i];
      final lOther$assigneeUsernames$entry = lOther$assigneeUsernames[i];
      if (l$assigneeUsernames$entry != lOther$assigneeUsernames$entry) {
        return false;
      }
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (_$data.containsKey('operationMode') !=
        other._$data.containsKey('operationMode')) {
      return false;
    }
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$assigneeUsernames = assigneeUsernames;
    final l$operationMode = operationMode;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$assigneeUsernames.map((v) => v)),
      _$data.containsKey('operationMode') ? l$operationMode : const {},
    ]);
  }
}

abstract class CopyWith$Input$AlertSetAssigneesInput<TRes> {
  factory CopyWith$Input$AlertSetAssigneesInput(
    Input$AlertSetAssigneesInput instance,
    TRes Function(Input$AlertSetAssigneesInput) then,
  ) = _CopyWithImpl$Input$AlertSetAssigneesInput;

  factory CopyWith$Input$AlertSetAssigneesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AlertSetAssigneesInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  });
}

class _CopyWithImpl$Input$AlertSetAssigneesInput<TRes>
    implements CopyWith$Input$AlertSetAssigneesInput<TRes> {
  _CopyWithImpl$Input$AlertSetAssigneesInput(
    this._instance,
    this._then,
  );

  final Input$AlertSetAssigneesInput _instance;

  final TRes Function(Input$AlertSetAssigneesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? assigneeUsernames = _undefined,
    Object? operationMode = _undefined,
  }) =>
      _then(Input$AlertSetAssigneesInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (assigneeUsernames != _undefined && assigneeUsernames != null)
          'assigneeUsernames': (assigneeUsernames as List<String>),
        if (operationMode != _undefined)
          'operationMode': (operationMode as Enum$MutationOperationMode?),
      }));
}

class _CopyWithStubImpl$Input$AlertSetAssigneesInput<TRes>
    implements CopyWith$Input$AlertSetAssigneesInput<TRes> {
  _CopyWithStubImpl$Input$AlertSetAssigneesInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      _res;
}

class Input$AlertTodoCreateInput {
  factory Input$AlertTodoCreateInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
  }) =>
      Input$AlertTodoCreateInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AlertTodoCreateInput._(this._$data);

  factory Input$AlertTodoCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AlertTodoCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AlertTodoCreateInput<Input$AlertTodoCreateInput>
      get copyWith => CopyWith$Input$AlertTodoCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AlertTodoCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AlertTodoCreateInput<TRes> {
  factory CopyWith$Input$AlertTodoCreateInput(
    Input$AlertTodoCreateInput instance,
    TRes Function(Input$AlertTodoCreateInput) then,
  ) = _CopyWithImpl$Input$AlertTodoCreateInput;

  factory CopyWith$Input$AlertTodoCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AlertTodoCreateInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AlertTodoCreateInput<TRes>
    implements CopyWith$Input$AlertTodoCreateInput<TRes> {
  _CopyWithImpl$Input$AlertTodoCreateInput(
    this._instance,
    this._then,
  );

  final Input$AlertTodoCreateInput _instance;

  final TRes Function(Input$AlertTodoCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AlertTodoCreateInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AlertTodoCreateInput<TRes>
    implements CopyWith$Input$AlertTodoCreateInput<TRes> {
  _CopyWithStubImpl$Input$AlertTodoCreateInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ApiFuzzingCiConfigurationCreateInput {
  factory Input$ApiFuzzingCiConfigurationCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String apiSpecificationFile,
    String? authPassword,
    String? authUsername,
    required Enum$ApiFuzzingScanMode scanMode,
    String? scanProfile,
    required String target,
  }) =>
      Input$ApiFuzzingCiConfigurationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'apiSpecificationFile': apiSpecificationFile,
        if (authPassword != null) r'authPassword': authPassword,
        if (authUsername != null) r'authUsername': authUsername,
        r'scanMode': scanMode,
        if (scanProfile != null) r'scanProfile': scanProfile,
        r'target': target,
      });

  Input$ApiFuzzingCiConfigurationCreateInput._(this._$data);

  factory Input$ApiFuzzingCiConfigurationCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$apiSpecificationFile = data['apiSpecificationFile'];
    result$data['apiSpecificationFile'] = (l$apiSpecificationFile as String);
    if (data.containsKey('authPassword')) {
      final l$authPassword = data['authPassword'];
      result$data['authPassword'] = (l$authPassword as String?);
    }
    if (data.containsKey('authUsername')) {
      final l$authUsername = data['authUsername'];
      result$data['authUsername'] = (l$authUsername as String?);
    }
    final l$scanMode = data['scanMode'];
    result$data['scanMode'] =
        fromJson$Enum$ApiFuzzingScanMode((l$scanMode as String));
    if (data.containsKey('scanProfile')) {
      final l$scanProfile = data['scanProfile'];
      result$data['scanProfile'] = (l$scanProfile as String?);
    }
    final l$target = data['target'];
    result$data['target'] = (l$target as String);
    return Input$ApiFuzzingCiConfigurationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get apiSpecificationFile => (_$data['apiSpecificationFile'] as String);
  String? get authPassword => (_$data['authPassword'] as String?);
  String? get authUsername => (_$data['authUsername'] as String?);
  Enum$ApiFuzzingScanMode get scanMode =>
      (_$data['scanMode'] as Enum$ApiFuzzingScanMode);
  String? get scanProfile => (_$data['scanProfile'] as String?);
  String get target => (_$data['target'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$apiSpecificationFile = apiSpecificationFile;
    result$data['apiSpecificationFile'] = l$apiSpecificationFile;
    if (_$data.containsKey('authPassword')) {
      final l$authPassword = authPassword;
      result$data['authPassword'] = l$authPassword;
    }
    if (_$data.containsKey('authUsername')) {
      final l$authUsername = authUsername;
      result$data['authUsername'] = l$authUsername;
    }
    final l$scanMode = scanMode;
    result$data['scanMode'] = toJson$Enum$ApiFuzzingScanMode(l$scanMode);
    if (_$data.containsKey('scanProfile')) {
      final l$scanProfile = scanProfile;
      result$data['scanProfile'] = l$scanProfile;
    }
    final l$target = target;
    result$data['target'] = l$target;
    return result$data;
  }

  CopyWith$Input$ApiFuzzingCiConfigurationCreateInput<
          Input$ApiFuzzingCiConfigurationCreateInput>
      get copyWith => CopyWith$Input$ApiFuzzingCiConfigurationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApiFuzzingCiConfigurationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$apiSpecificationFile = apiSpecificationFile;
    final lOther$apiSpecificationFile = other.apiSpecificationFile;
    if (l$apiSpecificationFile != lOther$apiSpecificationFile) {
      return false;
    }
    final l$authPassword = authPassword;
    final lOther$authPassword = other.authPassword;
    if (_$data.containsKey('authPassword') !=
        other._$data.containsKey('authPassword')) {
      return false;
    }
    if (l$authPassword != lOther$authPassword) {
      return false;
    }
    final l$authUsername = authUsername;
    final lOther$authUsername = other.authUsername;
    if (_$data.containsKey('authUsername') !=
        other._$data.containsKey('authUsername')) {
      return false;
    }
    if (l$authUsername != lOther$authUsername) {
      return false;
    }
    final l$scanMode = scanMode;
    final lOther$scanMode = other.scanMode;
    if (l$scanMode != lOther$scanMode) {
      return false;
    }
    final l$scanProfile = scanProfile;
    final lOther$scanProfile = other.scanProfile;
    if (_$data.containsKey('scanProfile') !=
        other._$data.containsKey('scanProfile')) {
      return false;
    }
    if (l$scanProfile != lOther$scanProfile) {
      return false;
    }
    final l$target = target;
    final lOther$target = other.target;
    if (l$target != lOther$target) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$apiSpecificationFile = apiSpecificationFile;
    final l$authPassword = authPassword;
    final l$authUsername = authUsername;
    final l$scanMode = scanMode;
    final l$scanProfile = scanProfile;
    final l$target = target;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$apiSpecificationFile,
      _$data.containsKey('authPassword') ? l$authPassword : const {},
      _$data.containsKey('authUsername') ? l$authUsername : const {},
      l$scanMode,
      _$data.containsKey('scanProfile') ? l$scanProfile : const {},
      l$target,
    ]);
  }
}

abstract class CopyWith$Input$ApiFuzzingCiConfigurationCreateInput<TRes> {
  factory CopyWith$Input$ApiFuzzingCiConfigurationCreateInput(
    Input$ApiFuzzingCiConfigurationCreateInput instance,
    TRes Function(Input$ApiFuzzingCiConfigurationCreateInput) then,
  ) = _CopyWithImpl$Input$ApiFuzzingCiConfigurationCreateInput;

  factory CopyWith$Input$ApiFuzzingCiConfigurationCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApiFuzzingCiConfigurationCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? apiSpecificationFile,
    String? authPassword,
    String? authUsername,
    Enum$ApiFuzzingScanMode? scanMode,
    String? scanProfile,
    String? target,
  });
}

class _CopyWithImpl$Input$ApiFuzzingCiConfigurationCreateInput<TRes>
    implements CopyWith$Input$ApiFuzzingCiConfigurationCreateInput<TRes> {
  _CopyWithImpl$Input$ApiFuzzingCiConfigurationCreateInput(
    this._instance,
    this._then,
  );

  final Input$ApiFuzzingCiConfigurationCreateInput _instance;

  final TRes Function(Input$ApiFuzzingCiConfigurationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? apiSpecificationFile = _undefined,
    Object? authPassword = _undefined,
    Object? authUsername = _undefined,
    Object? scanMode = _undefined,
    Object? scanProfile = _undefined,
    Object? target = _undefined,
  }) =>
      _then(Input$ApiFuzzingCiConfigurationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (apiSpecificationFile != _undefined && apiSpecificationFile != null)
          'apiSpecificationFile': (apiSpecificationFile as String),
        if (authPassword != _undefined)
          'authPassword': (authPassword as String?),
        if (authUsername != _undefined)
          'authUsername': (authUsername as String?),
        if (scanMode != _undefined && scanMode != null)
          'scanMode': (scanMode as Enum$ApiFuzzingScanMode),
        if (scanProfile != _undefined) 'scanProfile': (scanProfile as String?),
        if (target != _undefined && target != null)
          'target': (target as String),
      }));
}

class _CopyWithStubImpl$Input$ApiFuzzingCiConfigurationCreateInput<TRes>
    implements CopyWith$Input$ApiFuzzingCiConfigurationCreateInput<TRes> {
  _CopyWithStubImpl$Input$ApiFuzzingCiConfigurationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? apiSpecificationFile,
    String? authPassword,
    String? authUsername,
    Enum$ApiFuzzingScanMode? scanMode,
    String? scanProfile,
    String? target,
  }) =>
      _res;
}

class Input$AuditEventsStreamingHeadersCreateInput {
  factory Input$AuditEventsStreamingHeadersCreateInput({
    String? clientMutationId,
    required String key,
    required String value,
    required String destinationId,
  }) =>
      Input$AuditEventsStreamingHeadersCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'key': key,
        r'value': value,
        r'destinationId': destinationId,
      });

  Input$AuditEventsStreamingHeadersCreateInput._(this._$data);

  factory Input$AuditEventsStreamingHeadersCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    final l$destinationId = data['destinationId'];
    result$data['destinationId'] = (l$destinationId as String);
    return Input$AuditEventsStreamingHeadersCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get key => (_$data['key'] as String);
  String get value => (_$data['value'] as String);
  String get destinationId => (_$data['destinationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$key = key;
    result$data['key'] = l$key;
    final l$value = value;
    result$data['value'] = l$value;
    final l$destinationId = destinationId;
    result$data['destinationId'] = l$destinationId;
    return result$data;
  }

  CopyWith$Input$AuditEventsStreamingHeadersCreateInput<
          Input$AuditEventsStreamingHeadersCreateInput>
      get copyWith => CopyWith$Input$AuditEventsStreamingHeadersCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AuditEventsStreamingHeadersCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    final l$destinationId = destinationId;
    final lOther$destinationId = other.destinationId;
    if (l$destinationId != lOther$destinationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$key = key;
    final l$value = value;
    final l$destinationId = destinationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$key,
      l$value,
      l$destinationId,
    ]);
  }
}

abstract class CopyWith$Input$AuditEventsStreamingHeadersCreateInput<TRes> {
  factory CopyWith$Input$AuditEventsStreamingHeadersCreateInput(
    Input$AuditEventsStreamingHeadersCreateInput instance,
    TRes Function(Input$AuditEventsStreamingHeadersCreateInput) then,
  ) = _CopyWithImpl$Input$AuditEventsStreamingHeadersCreateInput;

  factory CopyWith$Input$AuditEventsStreamingHeadersCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AuditEventsStreamingHeadersCreateInput;

  TRes call({
    String? clientMutationId,
    String? key,
    String? value,
    String? destinationId,
  });
}

class _CopyWithImpl$Input$AuditEventsStreamingHeadersCreateInput<TRes>
    implements CopyWith$Input$AuditEventsStreamingHeadersCreateInput<TRes> {
  _CopyWithImpl$Input$AuditEventsStreamingHeadersCreateInput(
    this._instance,
    this._then,
  );

  final Input$AuditEventsStreamingHeadersCreateInput _instance;

  final TRes Function(Input$AuditEventsStreamingHeadersCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? key = _undefined,
    Object? value = _undefined,
    Object? destinationId = _undefined,
  }) =>
      _then(Input$AuditEventsStreamingHeadersCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (key != _undefined && key != null) 'key': (key as String),
        if (value != _undefined && value != null) 'value': (value as String),
        if (destinationId != _undefined && destinationId != null)
          'destinationId': (destinationId as String),
      }));
}

class _CopyWithStubImpl$Input$AuditEventsStreamingHeadersCreateInput<TRes>
    implements CopyWith$Input$AuditEventsStreamingHeadersCreateInput<TRes> {
  _CopyWithStubImpl$Input$AuditEventsStreamingHeadersCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? key,
    String? value,
    String? destinationId,
  }) =>
      _res;
}

class Input$AuditEventsStreamingHeadersDestroyInput {
  factory Input$AuditEventsStreamingHeadersDestroyInput({
    String? clientMutationId,
    required String headerId,
  }) =>
      Input$AuditEventsStreamingHeadersDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'headerId': headerId,
      });

  Input$AuditEventsStreamingHeadersDestroyInput._(this._$data);

  factory Input$AuditEventsStreamingHeadersDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$headerId = data['headerId'];
    result$data['headerId'] = (l$headerId as String);
    return Input$AuditEventsStreamingHeadersDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get headerId => (_$data['headerId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$headerId = headerId;
    result$data['headerId'] = l$headerId;
    return result$data;
  }

  CopyWith$Input$AuditEventsStreamingHeadersDestroyInput<
          Input$AuditEventsStreamingHeadersDestroyInput>
      get copyWith => CopyWith$Input$AuditEventsStreamingHeadersDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AuditEventsStreamingHeadersDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$headerId = headerId;
    final lOther$headerId = other.headerId;
    if (l$headerId != lOther$headerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$headerId = headerId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$headerId,
    ]);
  }
}

abstract class CopyWith$Input$AuditEventsStreamingHeadersDestroyInput<TRes> {
  factory CopyWith$Input$AuditEventsStreamingHeadersDestroyInput(
    Input$AuditEventsStreamingHeadersDestroyInput instance,
    TRes Function(Input$AuditEventsStreamingHeadersDestroyInput) then,
  ) = _CopyWithImpl$Input$AuditEventsStreamingHeadersDestroyInput;

  factory CopyWith$Input$AuditEventsStreamingHeadersDestroyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$AuditEventsStreamingHeadersDestroyInput;

  TRes call({
    String? clientMutationId,
    String? headerId,
  });
}

class _CopyWithImpl$Input$AuditEventsStreamingHeadersDestroyInput<TRes>
    implements CopyWith$Input$AuditEventsStreamingHeadersDestroyInput<TRes> {
  _CopyWithImpl$Input$AuditEventsStreamingHeadersDestroyInput(
    this._instance,
    this._then,
  );

  final Input$AuditEventsStreamingHeadersDestroyInput _instance;

  final TRes Function(Input$AuditEventsStreamingHeadersDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? headerId = _undefined,
  }) =>
      _then(Input$AuditEventsStreamingHeadersDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (headerId != _undefined && headerId != null)
          'headerId': (headerId as String),
      }));
}

class _CopyWithStubImpl$Input$AuditEventsStreamingHeadersDestroyInput<TRes>
    implements CopyWith$Input$AuditEventsStreamingHeadersDestroyInput<TRes> {
  _CopyWithStubImpl$Input$AuditEventsStreamingHeadersDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? headerId,
  }) =>
      _res;
}

class Input$AuditEventsStreamingHeadersUpdateInput {
  factory Input$AuditEventsStreamingHeadersUpdateInput({
    String? clientMutationId,
    required String headerId,
    required String key,
    required String value,
  }) =>
      Input$AuditEventsStreamingHeadersUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'headerId': headerId,
        r'key': key,
        r'value': value,
      });

  Input$AuditEventsStreamingHeadersUpdateInput._(this._$data);

  factory Input$AuditEventsStreamingHeadersUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$headerId = data['headerId'];
    result$data['headerId'] = (l$headerId as String);
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$AuditEventsStreamingHeadersUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get headerId => (_$data['headerId'] as String);
  String get key => (_$data['key'] as String);
  String get value => (_$data['value'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$headerId = headerId;
    result$data['headerId'] = l$headerId;
    final l$key = key;
    result$data['key'] = l$key;
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$AuditEventsStreamingHeadersUpdateInput<
          Input$AuditEventsStreamingHeadersUpdateInput>
      get copyWith => CopyWith$Input$AuditEventsStreamingHeadersUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AuditEventsStreamingHeadersUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$headerId = headerId;
    final lOther$headerId = other.headerId;
    if (l$headerId != lOther$headerId) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$headerId = headerId;
    final l$key = key;
    final l$value = value;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$headerId,
      l$key,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$AuditEventsStreamingHeadersUpdateInput<TRes> {
  factory CopyWith$Input$AuditEventsStreamingHeadersUpdateInput(
    Input$AuditEventsStreamingHeadersUpdateInput instance,
    TRes Function(Input$AuditEventsStreamingHeadersUpdateInput) then,
  ) = _CopyWithImpl$Input$AuditEventsStreamingHeadersUpdateInput;

  factory CopyWith$Input$AuditEventsStreamingHeadersUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AuditEventsStreamingHeadersUpdateInput;

  TRes call({
    String? clientMutationId,
    String? headerId,
    String? key,
    String? value,
  });
}

class _CopyWithImpl$Input$AuditEventsStreamingHeadersUpdateInput<TRes>
    implements CopyWith$Input$AuditEventsStreamingHeadersUpdateInput<TRes> {
  _CopyWithImpl$Input$AuditEventsStreamingHeadersUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AuditEventsStreamingHeadersUpdateInput _instance;

  final TRes Function(Input$AuditEventsStreamingHeadersUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? headerId = _undefined,
    Object? key = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$AuditEventsStreamingHeadersUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (headerId != _undefined && headerId != null)
          'headerId': (headerId as String),
        if (key != _undefined && key != null) 'key': (key as String),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$AuditEventsStreamingHeadersUpdateInput<TRes>
    implements CopyWith$Input$AuditEventsStreamingHeadersUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AuditEventsStreamingHeadersUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? headerId,
    String? key,
    String? value,
  }) =>
      _res;
}

class Input$AwardEmojiAddInput {
  factory Input$AwardEmojiAddInput({
    required String awardableId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$AwardEmojiAddInput._({
        r'awardableId': awardableId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AwardEmojiAddInput._(this._$data);

  factory Input$AwardEmojiAddInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$awardableId = data['awardableId'];
    result$data['awardableId'] = (l$awardableId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AwardEmojiAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get awardableId => (_$data['awardableId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$awardableId = awardableId;
    result$data['awardableId'] = l$awardableId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AwardEmojiAddInput<Input$AwardEmojiAddInput> get copyWith =>
      CopyWith$Input$AwardEmojiAddInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AwardEmojiAddInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$awardableId = awardableId;
    final lOther$awardableId = other.awardableId;
    if (l$awardableId != lOther$awardableId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$awardableId = awardableId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$awardableId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AwardEmojiAddInput<TRes> {
  factory CopyWith$Input$AwardEmojiAddInput(
    Input$AwardEmojiAddInput instance,
    TRes Function(Input$AwardEmojiAddInput) then,
  ) = _CopyWithImpl$Input$AwardEmojiAddInput;

  factory CopyWith$Input$AwardEmojiAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AwardEmojiAddInput;

  TRes call({
    String? awardableId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AwardEmojiAddInput<TRes>
    implements CopyWith$Input$AwardEmojiAddInput<TRes> {
  _CopyWithImpl$Input$AwardEmojiAddInput(
    this._instance,
    this._then,
  );

  final Input$AwardEmojiAddInput _instance;

  final TRes Function(Input$AwardEmojiAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? awardableId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AwardEmojiAddInput._({
        ..._instance._$data,
        if (awardableId != _undefined && awardableId != null)
          'awardableId': (awardableId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AwardEmojiAddInput<TRes>
    implements CopyWith$Input$AwardEmojiAddInput<TRes> {
  _CopyWithStubImpl$Input$AwardEmojiAddInput(this._res);

  TRes _res;

  call({
    String? awardableId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AwardEmojiRemoveInput {
  factory Input$AwardEmojiRemoveInput({
    required String awardableId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$AwardEmojiRemoveInput._({
        r'awardableId': awardableId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AwardEmojiRemoveInput._(this._$data);

  factory Input$AwardEmojiRemoveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$awardableId = data['awardableId'];
    result$data['awardableId'] = (l$awardableId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AwardEmojiRemoveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get awardableId => (_$data['awardableId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$awardableId = awardableId;
    result$data['awardableId'] = l$awardableId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AwardEmojiRemoveInput<Input$AwardEmojiRemoveInput>
      get copyWith => CopyWith$Input$AwardEmojiRemoveInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AwardEmojiRemoveInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$awardableId = awardableId;
    final lOther$awardableId = other.awardableId;
    if (l$awardableId != lOther$awardableId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$awardableId = awardableId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$awardableId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AwardEmojiRemoveInput<TRes> {
  factory CopyWith$Input$AwardEmojiRemoveInput(
    Input$AwardEmojiRemoveInput instance,
    TRes Function(Input$AwardEmojiRemoveInput) then,
  ) = _CopyWithImpl$Input$AwardEmojiRemoveInput;

  factory CopyWith$Input$AwardEmojiRemoveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AwardEmojiRemoveInput;

  TRes call({
    String? awardableId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AwardEmojiRemoveInput<TRes>
    implements CopyWith$Input$AwardEmojiRemoveInput<TRes> {
  _CopyWithImpl$Input$AwardEmojiRemoveInput(
    this._instance,
    this._then,
  );

  final Input$AwardEmojiRemoveInput _instance;

  final TRes Function(Input$AwardEmojiRemoveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? awardableId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AwardEmojiRemoveInput._({
        ..._instance._$data,
        if (awardableId != _undefined && awardableId != null)
          'awardableId': (awardableId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AwardEmojiRemoveInput<TRes>
    implements CopyWith$Input$AwardEmojiRemoveInput<TRes> {
  _CopyWithStubImpl$Input$AwardEmojiRemoveInput(this._res);

  TRes _res;

  call({
    String? awardableId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AwardEmojiToggleInput {
  factory Input$AwardEmojiToggleInput({
    required String awardableId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$AwardEmojiToggleInput._({
        r'awardableId': awardableId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AwardEmojiToggleInput._(this._$data);

  factory Input$AwardEmojiToggleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$awardableId = data['awardableId'];
    result$data['awardableId'] = (l$awardableId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AwardEmojiToggleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get awardableId => (_$data['awardableId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$awardableId = awardableId;
    result$data['awardableId'] = l$awardableId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AwardEmojiToggleInput<Input$AwardEmojiToggleInput>
      get copyWith => CopyWith$Input$AwardEmojiToggleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AwardEmojiToggleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$awardableId = awardableId;
    final lOther$awardableId = other.awardableId;
    if (l$awardableId != lOther$awardableId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$awardableId = awardableId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$awardableId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AwardEmojiToggleInput<TRes> {
  factory CopyWith$Input$AwardEmojiToggleInput(
    Input$AwardEmojiToggleInput instance,
    TRes Function(Input$AwardEmojiToggleInput) then,
  ) = _CopyWithImpl$Input$AwardEmojiToggleInput;

  factory CopyWith$Input$AwardEmojiToggleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AwardEmojiToggleInput;

  TRes call({
    String? awardableId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AwardEmojiToggleInput<TRes>
    implements CopyWith$Input$AwardEmojiToggleInput<TRes> {
  _CopyWithImpl$Input$AwardEmojiToggleInput(
    this._instance,
    this._then,
  );

  final Input$AwardEmojiToggleInput _instance;

  final TRes Function(Input$AwardEmojiToggleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? awardableId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AwardEmojiToggleInput._({
        ..._instance._$data,
        if (awardableId != _undefined && awardableId != null)
          'awardableId': (awardableId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AwardEmojiToggleInput<TRes>
    implements CopyWith$Input$AwardEmojiToggleInput<TRes> {
  _CopyWithStubImpl$Input$AwardEmojiToggleInput(this._res);

  TRes _res;

  call({
    String? awardableId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$BoardEpicCreateInput {
  factory Input$BoardEpicCreateInput({
    String? clientMutationId,
    required String groupPath,
    required String boardId,
    required String listId,
    required String title,
  }) =>
      Input$BoardEpicCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        r'boardId': boardId,
        r'listId': listId,
        r'title': title,
      });

  Input$BoardEpicCreateInput._(this._$data);

  factory Input$BoardEpicCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    final l$boardId = data['boardId'];
    result$data['boardId'] = (l$boardId as String);
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$BoardEpicCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  String get boardId => (_$data['boardId'] as String);
  String get listId => (_$data['listId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    final l$boardId = boardId;
    result$data['boardId'] = l$boardId;
    final l$listId = listId;
    result$data['listId'] = l$listId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$BoardEpicCreateInput<Input$BoardEpicCreateInput>
      get copyWith => CopyWith$Input$BoardEpicCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoardEpicCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$boardId = boardId;
    final lOther$boardId = other.boardId;
    if (l$boardId != lOther$boardId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$boardId = boardId;
    final l$listId = listId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      l$boardId,
      l$listId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$BoardEpicCreateInput<TRes> {
  factory CopyWith$Input$BoardEpicCreateInput(
    Input$BoardEpicCreateInput instance,
    TRes Function(Input$BoardEpicCreateInput) then,
  ) = _CopyWithImpl$Input$BoardEpicCreateInput;

  factory CopyWith$Input$BoardEpicCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BoardEpicCreateInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    String? boardId,
    String? listId,
    String? title,
  });
}

class _CopyWithImpl$Input$BoardEpicCreateInput<TRes>
    implements CopyWith$Input$BoardEpicCreateInput<TRes> {
  _CopyWithImpl$Input$BoardEpicCreateInput(
    this._instance,
    this._then,
  );

  final Input$BoardEpicCreateInput _instance;

  final TRes Function(Input$BoardEpicCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? boardId = _undefined,
    Object? listId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$BoardEpicCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (boardId != _undefined && boardId != null)
          'boardId': (boardId as String),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$BoardEpicCreateInput<TRes>
    implements CopyWith$Input$BoardEpicCreateInput<TRes> {
  _CopyWithStubImpl$Input$BoardEpicCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    String? boardId,
    String? listId,
    String? title,
  }) =>
      _res;
}

class Input$BoardIssueInput {
  factory Input$BoardIssueInput({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    List<String>? iids,
    String? milestoneTitle,
    List<String?>? assigneeUsername,
    String? releaseTag,
    List<Enum$IssueType>? types,
    Enum$MilestoneWildcardId? milestoneWildcardId,
    String? epicId,
    String? iterationTitle,
    String? weight,
    List<String>? iterationId,
    Input$NegatedBoardIssueInput? not,
    String? search,
    Enum$AssigneeWildcardId? assigneeWildcardId,
    bool? confidential,
    Enum$EpicWildcardId? epicWildcardId,
    Enum$IterationWildcardId? iterationWildcardId,
    List<String>? iterationCadenceId,
    Enum$WeightWildcardId? weightWildcardId,
  }) =>
      Input$BoardIssueInput._({
        if (labelName != null) r'labelName': labelName,
        if (authorUsername != null) r'authorUsername': authorUsername,
        if (myReactionEmoji != null) r'myReactionEmoji': myReactionEmoji,
        if (iids != null) r'iids': iids,
        if (milestoneTitle != null) r'milestoneTitle': milestoneTitle,
        if (assigneeUsername != null) r'assigneeUsername': assigneeUsername,
        if (releaseTag != null) r'releaseTag': releaseTag,
        if (types != null) r'types': types,
        if (milestoneWildcardId != null)
          r'milestoneWildcardId': milestoneWildcardId,
        if (epicId != null) r'epicId': epicId,
        if (iterationTitle != null) r'iterationTitle': iterationTitle,
        if (weight != null) r'weight': weight,
        if (iterationId != null) r'iterationId': iterationId,
        if (not != null) r'not': not,
        if (search != null) r'search': search,
        if (assigneeWildcardId != null)
          r'assigneeWildcardId': assigneeWildcardId,
        if (confidential != null) r'confidential': confidential,
        if (epicWildcardId != null) r'epicWildcardId': epicWildcardId,
        if (iterationWildcardId != null)
          r'iterationWildcardId': iterationWildcardId,
        if (iterationCadenceId != null)
          r'iterationCadenceId': iterationCadenceId,
        if (weightWildcardId != null) r'weightWildcardId': weightWildcardId,
      });

  Input$BoardIssueInput._(this._$data);

  factory Input$BoardIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('labelName')) {
      final l$labelName = data['labelName'];
      result$data['labelName'] =
          (l$labelName as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as String?);
    }
    if (data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = data['myReactionEmoji'];
      result$data['myReactionEmoji'] = (l$myReactionEmoji as String?);
    }
    if (data.containsKey('iids')) {
      final l$iids = data['iids'];
      result$data['iids'] =
          (l$iids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = data['milestoneTitle'];
      result$data['milestoneTitle'] = (l$milestoneTitle as String?);
    }
    if (data.containsKey('assigneeUsername')) {
      final l$assigneeUsername = data['assigneeUsername'];
      result$data['assigneeUsername'] = (l$assigneeUsername as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('releaseTag')) {
      final l$releaseTag = data['releaseTag'];
      result$data['releaseTag'] = (l$releaseTag as String?);
    }
    if (data.containsKey('types')) {
      final l$types = data['types'];
      result$data['types'] = (l$types as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IssueType((e as String)))
          .toList();
    }
    if (data.containsKey('milestoneWildcardId')) {
      final l$milestoneWildcardId = data['milestoneWildcardId'];
      result$data['milestoneWildcardId'] = l$milestoneWildcardId == null
          ? null
          : fromJson$Enum$MilestoneWildcardId(
              (l$milestoneWildcardId as String));
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    if (data.containsKey('iterationTitle')) {
      final l$iterationTitle = data['iterationTitle'];
      result$data['iterationTitle'] = (l$iterationTitle as String?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] =
          (l$iterationId as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NegatedBoardIssueInput.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('assigneeWildcardId')) {
      final l$assigneeWildcardId = data['assigneeWildcardId'];
      result$data['assigneeWildcardId'] = l$assigneeWildcardId == null
          ? null
          : fromJson$Enum$AssigneeWildcardId((l$assigneeWildcardId as String));
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('epicWildcardId')) {
      final l$epicWildcardId = data['epicWildcardId'];
      result$data['epicWildcardId'] = l$epicWildcardId == null
          ? null
          : fromJson$Enum$EpicWildcardId((l$epicWildcardId as String));
    }
    if (data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = data['iterationWildcardId'];
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : fromJson$Enum$IterationWildcardId(
              (l$iterationWildcardId as String));
    }
    if (data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = data['iterationCadenceId'];
      result$data['iterationCadenceId'] =
          (l$iterationCadenceId as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('weightWildcardId')) {
      final l$weightWildcardId = data['weightWildcardId'];
      result$data['weightWildcardId'] = l$weightWildcardId == null
          ? null
          : fromJson$Enum$WeightWildcardId((l$weightWildcardId as String));
    }
    return Input$BoardIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get labelName => (_$data['labelName'] as List<String?>?);
  String? get authorUsername => (_$data['authorUsername'] as String?);
  String? get myReactionEmoji => (_$data['myReactionEmoji'] as String?);
  List<String>? get iids => (_$data['iids'] as List<String>?);
  String? get milestoneTitle => (_$data['milestoneTitle'] as String?);
  List<String?>? get assigneeUsername =>
      (_$data['assigneeUsername'] as List<String?>?);
  String? get releaseTag => (_$data['releaseTag'] as String?);
  List<Enum$IssueType>? get types => (_$data['types'] as List<Enum$IssueType>?);
  Enum$MilestoneWildcardId? get milestoneWildcardId =>
      (_$data['milestoneWildcardId'] as Enum$MilestoneWildcardId?);
  String? get epicId => (_$data['epicId'] as String?);
  String? get iterationTitle => (_$data['iterationTitle'] as String?);
  String? get weight => (_$data['weight'] as String?);
  List<String>? get iterationId => (_$data['iterationId'] as List<String>?);
  Input$NegatedBoardIssueInput? get not =>
      (_$data['not'] as Input$NegatedBoardIssueInput?);
  String? get search => (_$data['search'] as String?);
  Enum$AssigneeWildcardId? get assigneeWildcardId =>
      (_$data['assigneeWildcardId'] as Enum$AssigneeWildcardId?);
  bool? get confidential => (_$data['confidential'] as bool?);
  Enum$EpicWildcardId? get epicWildcardId =>
      (_$data['epicWildcardId'] as Enum$EpicWildcardId?);
  Enum$IterationWildcardId? get iterationWildcardId =>
      (_$data['iterationWildcardId'] as Enum$IterationWildcardId?);
  List<String>? get iterationCadenceId =>
      (_$data['iterationCadenceId'] as List<String>?);
  Enum$WeightWildcardId? get weightWildcardId =>
      (_$data['weightWildcardId'] as Enum$WeightWildcardId?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('labelName')) {
      final l$labelName = labelName;
      result$data['labelName'] = l$labelName?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername;
    }
    if (_$data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = myReactionEmoji;
      result$data['myReactionEmoji'] = l$myReactionEmoji;
    }
    if (_$data.containsKey('iids')) {
      final l$iids = iids;
      result$data['iids'] = l$iids?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = milestoneTitle;
      result$data['milestoneTitle'] = l$milestoneTitle;
    }
    if (_$data.containsKey('assigneeUsername')) {
      final l$assigneeUsername = assigneeUsername;
      result$data['assigneeUsername'] =
          l$assigneeUsername?.map((e) => e).toList();
    }
    if (_$data.containsKey('releaseTag')) {
      final l$releaseTag = releaseTag;
      result$data['releaseTag'] = l$releaseTag;
    }
    if (_$data.containsKey('types')) {
      final l$types = types;
      result$data['types'] =
          l$types?.map((e) => toJson$Enum$IssueType(e)).toList();
    }
    if (_$data.containsKey('milestoneWildcardId')) {
      final l$milestoneWildcardId = milestoneWildcardId;
      result$data['milestoneWildcardId'] = l$milestoneWildcardId == null
          ? null
          : toJson$Enum$MilestoneWildcardId(l$milestoneWildcardId);
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    if (_$data.containsKey('iterationTitle')) {
      final l$iterationTitle = iterationTitle;
      result$data['iterationTitle'] = l$iterationTitle;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId?.map((e) => e).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('assigneeWildcardId')) {
      final l$assigneeWildcardId = assigneeWildcardId;
      result$data['assigneeWildcardId'] = l$assigneeWildcardId == null
          ? null
          : toJson$Enum$AssigneeWildcardId(l$assigneeWildcardId);
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('epicWildcardId')) {
      final l$epicWildcardId = epicWildcardId;
      result$data['epicWildcardId'] = l$epicWildcardId == null
          ? null
          : toJson$Enum$EpicWildcardId(l$epicWildcardId);
    }
    if (_$data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = iterationWildcardId;
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : toJson$Enum$IterationWildcardId(l$iterationWildcardId);
    }
    if (_$data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = iterationCadenceId;
      result$data['iterationCadenceId'] =
          l$iterationCadenceId?.map((e) => e).toList();
    }
    if (_$data.containsKey('weightWildcardId')) {
      final l$weightWildcardId = weightWildcardId;
      result$data['weightWildcardId'] = l$weightWildcardId == null
          ? null
          : toJson$Enum$WeightWildcardId(l$weightWildcardId);
    }
    return result$data;
  }

  CopyWith$Input$BoardIssueInput<Input$BoardIssueInput> get copyWith =>
      CopyWith$Input$BoardIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoardIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelName = labelName;
    final lOther$labelName = other.labelName;
    if (_$data.containsKey('labelName') !=
        other._$data.containsKey('labelName')) {
      return false;
    }
    if (l$labelName != null && lOther$labelName != null) {
      if (l$labelName.length != lOther$labelName.length) {
        return false;
      }
      for (int i = 0; i < l$labelName.length; i++) {
        final l$labelName$entry = l$labelName[i];
        final lOther$labelName$entry = lOther$labelName[i];
        if (l$labelName$entry != lOther$labelName$entry) {
          return false;
        }
      }
    } else if (l$labelName != lOther$labelName) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$myReactionEmoji = myReactionEmoji;
    final lOther$myReactionEmoji = other.myReactionEmoji;
    if (_$data.containsKey('myReactionEmoji') !=
        other._$data.containsKey('myReactionEmoji')) {
      return false;
    }
    if (l$myReactionEmoji != lOther$myReactionEmoji) {
      return false;
    }
    final l$iids = iids;
    final lOther$iids = other.iids;
    if (_$data.containsKey('iids') != other._$data.containsKey('iids')) {
      return false;
    }
    if (l$iids != null && lOther$iids != null) {
      if (l$iids.length != lOther$iids.length) {
        return false;
      }
      for (int i = 0; i < l$iids.length; i++) {
        final l$iids$entry = l$iids[i];
        final lOther$iids$entry = lOther$iids[i];
        if (l$iids$entry != lOther$iids$entry) {
          return false;
        }
      }
    } else if (l$iids != lOther$iids) {
      return false;
    }
    final l$milestoneTitle = milestoneTitle;
    final lOther$milestoneTitle = other.milestoneTitle;
    if (_$data.containsKey('milestoneTitle') !=
        other._$data.containsKey('milestoneTitle')) {
      return false;
    }
    if (l$milestoneTitle != lOther$milestoneTitle) {
      return false;
    }
    final l$assigneeUsername = assigneeUsername;
    final lOther$assigneeUsername = other.assigneeUsername;
    if (_$data.containsKey('assigneeUsername') !=
        other._$data.containsKey('assigneeUsername')) {
      return false;
    }
    if (l$assigneeUsername != null && lOther$assigneeUsername != null) {
      if (l$assigneeUsername.length != lOther$assigneeUsername.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeUsername.length; i++) {
        final l$assigneeUsername$entry = l$assigneeUsername[i];
        final lOther$assigneeUsername$entry = lOther$assigneeUsername[i];
        if (l$assigneeUsername$entry != lOther$assigneeUsername$entry) {
          return false;
        }
      }
    } else if (l$assigneeUsername != lOther$assigneeUsername) {
      return false;
    }
    final l$releaseTag = releaseTag;
    final lOther$releaseTag = other.releaseTag;
    if (_$data.containsKey('releaseTag') !=
        other._$data.containsKey('releaseTag')) {
      return false;
    }
    if (l$releaseTag != lOther$releaseTag) {
      return false;
    }
    final l$types = types;
    final lOther$types = other.types;
    if (_$data.containsKey('types') != other._$data.containsKey('types')) {
      return false;
    }
    if (l$types != null && lOther$types != null) {
      if (l$types.length != lOther$types.length) {
        return false;
      }
      for (int i = 0; i < l$types.length; i++) {
        final l$types$entry = l$types[i];
        final lOther$types$entry = lOther$types[i];
        if (l$types$entry != lOther$types$entry) {
          return false;
        }
      }
    } else if (l$types != lOther$types) {
      return false;
    }
    final l$milestoneWildcardId = milestoneWildcardId;
    final lOther$milestoneWildcardId = other.milestoneWildcardId;
    if (_$data.containsKey('milestoneWildcardId') !=
        other._$data.containsKey('milestoneWildcardId')) {
      return false;
    }
    if (l$milestoneWildcardId != lOther$milestoneWildcardId) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    final l$iterationTitle = iterationTitle;
    final lOther$iterationTitle = other.iterationTitle;
    if (_$data.containsKey('iterationTitle') !=
        other._$data.containsKey('iterationTitle')) {
      return false;
    }
    if (l$iterationTitle != lOther$iterationTitle) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != null && lOther$iterationId != null) {
      if (l$iterationId.length != lOther$iterationId.length) {
        return false;
      }
      for (int i = 0; i < l$iterationId.length; i++) {
        final l$iterationId$entry = l$iterationId[i];
        final lOther$iterationId$entry = lOther$iterationId[i];
        if (l$iterationId$entry != lOther$iterationId$entry) {
          return false;
        }
      }
    } else if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$assigneeWildcardId = assigneeWildcardId;
    final lOther$assigneeWildcardId = other.assigneeWildcardId;
    if (_$data.containsKey('assigneeWildcardId') !=
        other._$data.containsKey('assigneeWildcardId')) {
      return false;
    }
    if (l$assigneeWildcardId != lOther$assigneeWildcardId) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$epicWildcardId = epicWildcardId;
    final lOther$epicWildcardId = other.epicWildcardId;
    if (_$data.containsKey('epicWildcardId') !=
        other._$data.containsKey('epicWildcardId')) {
      return false;
    }
    if (l$epicWildcardId != lOther$epicWildcardId) {
      return false;
    }
    final l$iterationWildcardId = iterationWildcardId;
    final lOther$iterationWildcardId = other.iterationWildcardId;
    if (_$data.containsKey('iterationWildcardId') !=
        other._$data.containsKey('iterationWildcardId')) {
      return false;
    }
    if (l$iterationWildcardId != lOther$iterationWildcardId) {
      return false;
    }
    final l$iterationCadenceId = iterationCadenceId;
    final lOther$iterationCadenceId = other.iterationCadenceId;
    if (_$data.containsKey('iterationCadenceId') !=
        other._$data.containsKey('iterationCadenceId')) {
      return false;
    }
    if (l$iterationCadenceId != null && lOther$iterationCadenceId != null) {
      if (l$iterationCadenceId.length != lOther$iterationCadenceId.length) {
        return false;
      }
      for (int i = 0; i < l$iterationCadenceId.length; i++) {
        final l$iterationCadenceId$entry = l$iterationCadenceId[i];
        final lOther$iterationCadenceId$entry = lOther$iterationCadenceId[i];
        if (l$iterationCadenceId$entry != lOther$iterationCadenceId$entry) {
          return false;
        }
      }
    } else if (l$iterationCadenceId != lOther$iterationCadenceId) {
      return false;
    }
    final l$weightWildcardId = weightWildcardId;
    final lOther$weightWildcardId = other.weightWildcardId;
    if (_$data.containsKey('weightWildcardId') !=
        other._$data.containsKey('weightWildcardId')) {
      return false;
    }
    if (l$weightWildcardId != lOther$weightWildcardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelName = labelName;
    final l$authorUsername = authorUsername;
    final l$myReactionEmoji = myReactionEmoji;
    final l$iids = iids;
    final l$milestoneTitle = milestoneTitle;
    final l$assigneeUsername = assigneeUsername;
    final l$releaseTag = releaseTag;
    final l$types = types;
    final l$milestoneWildcardId = milestoneWildcardId;
    final l$epicId = epicId;
    final l$iterationTitle = iterationTitle;
    final l$weight = weight;
    final l$iterationId = iterationId;
    final l$not = not;
    final l$search = search;
    final l$assigneeWildcardId = assigneeWildcardId;
    final l$confidential = confidential;
    final l$epicWildcardId = epicWildcardId;
    final l$iterationWildcardId = iterationWildcardId;
    final l$iterationCadenceId = iterationCadenceId;
    final l$weightWildcardId = weightWildcardId;
    return Object.hashAll([
      _$data.containsKey('labelName')
          ? l$labelName == null
              ? null
              : Object.hashAll(l$labelName.map((v) => v))
          : const {},
      _$data.containsKey('authorUsername') ? l$authorUsername : const {},
      _$data.containsKey('myReactionEmoji') ? l$myReactionEmoji : const {},
      _$data.containsKey('iids')
          ? l$iids == null
              ? null
              : Object.hashAll(l$iids.map((v) => v))
          : const {},
      _$data.containsKey('milestoneTitle') ? l$milestoneTitle : const {},
      _$data.containsKey('assigneeUsername')
          ? l$assigneeUsername == null
              ? null
              : Object.hashAll(l$assigneeUsername.map((v) => v))
          : const {},
      _$data.containsKey('releaseTag') ? l$releaseTag : const {},
      _$data.containsKey('types')
          ? l$types == null
              ? null
              : Object.hashAll(l$types.map((v) => v))
          : const {},
      _$data.containsKey('milestoneWildcardId')
          ? l$milestoneWildcardId
          : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
      _$data.containsKey('iterationTitle') ? l$iterationTitle : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('iterationId')
          ? l$iterationId == null
              ? null
              : Object.hashAll(l$iterationId.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('assigneeWildcardId')
          ? l$assigneeWildcardId
          : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('epicWildcardId') ? l$epicWildcardId : const {},
      _$data.containsKey('iterationWildcardId')
          ? l$iterationWildcardId
          : const {},
      _$data.containsKey('iterationCadenceId')
          ? l$iterationCadenceId == null
              ? null
              : Object.hashAll(l$iterationCadenceId.map((v) => v))
          : const {},
      _$data.containsKey('weightWildcardId') ? l$weightWildcardId : const {},
    ]);
  }
}

abstract class CopyWith$Input$BoardIssueInput<TRes> {
  factory CopyWith$Input$BoardIssueInput(
    Input$BoardIssueInput instance,
    TRes Function(Input$BoardIssueInput) then,
  ) = _CopyWithImpl$Input$BoardIssueInput;

  factory CopyWith$Input$BoardIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BoardIssueInput;

  TRes call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    List<String>? iids,
    String? milestoneTitle,
    List<String?>? assigneeUsername,
    String? releaseTag,
    List<Enum$IssueType>? types,
    Enum$MilestoneWildcardId? milestoneWildcardId,
    String? epicId,
    String? iterationTitle,
    String? weight,
    List<String>? iterationId,
    Input$NegatedBoardIssueInput? not,
    String? search,
    Enum$AssigneeWildcardId? assigneeWildcardId,
    bool? confidential,
    Enum$EpicWildcardId? epicWildcardId,
    Enum$IterationWildcardId? iterationWildcardId,
    List<String>? iterationCadenceId,
    Enum$WeightWildcardId? weightWildcardId,
  });
  CopyWith$Input$NegatedBoardIssueInput<TRes> get not;
}

class _CopyWithImpl$Input$BoardIssueInput<TRes>
    implements CopyWith$Input$BoardIssueInput<TRes> {
  _CopyWithImpl$Input$BoardIssueInput(
    this._instance,
    this._then,
  );

  final Input$BoardIssueInput _instance;

  final TRes Function(Input$BoardIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? labelName = _undefined,
    Object? authorUsername = _undefined,
    Object? myReactionEmoji = _undefined,
    Object? iids = _undefined,
    Object? milestoneTitle = _undefined,
    Object? assigneeUsername = _undefined,
    Object? releaseTag = _undefined,
    Object? types = _undefined,
    Object? milestoneWildcardId = _undefined,
    Object? epicId = _undefined,
    Object? iterationTitle = _undefined,
    Object? weight = _undefined,
    Object? iterationId = _undefined,
    Object? not = _undefined,
    Object? search = _undefined,
    Object? assigneeWildcardId = _undefined,
    Object? confidential = _undefined,
    Object? epicWildcardId = _undefined,
    Object? iterationWildcardId = _undefined,
    Object? iterationCadenceId = _undefined,
    Object? weightWildcardId = _undefined,
  }) =>
      _then(Input$BoardIssueInput._({
        ..._instance._$data,
        if (labelName != _undefined) 'labelName': (labelName as List<String?>?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as String?),
        if (myReactionEmoji != _undefined)
          'myReactionEmoji': (myReactionEmoji as String?),
        if (iids != _undefined) 'iids': (iids as List<String>?),
        if (milestoneTitle != _undefined)
          'milestoneTitle': (milestoneTitle as String?),
        if (assigneeUsername != _undefined)
          'assigneeUsername': (assigneeUsername as List<String?>?),
        if (releaseTag != _undefined) 'releaseTag': (releaseTag as String?),
        if (types != _undefined) 'types': (types as List<Enum$IssueType>?),
        if (milestoneWildcardId != _undefined)
          'milestoneWildcardId':
              (milestoneWildcardId as Enum$MilestoneWildcardId?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
        if (iterationTitle != _undefined)
          'iterationTitle': (iterationTitle as String?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (iterationId != _undefined)
          'iterationId': (iterationId as List<String>?),
        if (not != _undefined) 'not': (not as Input$NegatedBoardIssueInput?),
        if (search != _undefined) 'search': (search as String?),
        if (assigneeWildcardId != _undefined)
          'assigneeWildcardId':
              (assigneeWildcardId as Enum$AssigneeWildcardId?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (epicWildcardId != _undefined)
          'epicWildcardId': (epicWildcardId as Enum$EpicWildcardId?),
        if (iterationWildcardId != _undefined)
          'iterationWildcardId':
              (iterationWildcardId as Enum$IterationWildcardId?),
        if (iterationCadenceId != _undefined)
          'iterationCadenceId': (iterationCadenceId as List<String>?),
        if (weightWildcardId != _undefined)
          'weightWildcardId': (weightWildcardId as Enum$WeightWildcardId?),
      }));
  CopyWith$Input$NegatedBoardIssueInput<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NegatedBoardIssueInput.stub(_then(_instance))
        : CopyWith$Input$NegatedBoardIssueInput(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$BoardIssueInput<TRes>
    implements CopyWith$Input$BoardIssueInput<TRes> {
  _CopyWithStubImpl$Input$BoardIssueInput(this._res);

  TRes _res;

  call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    List<String>? iids,
    String? milestoneTitle,
    List<String?>? assigneeUsername,
    String? releaseTag,
    List<Enum$IssueType>? types,
    Enum$MilestoneWildcardId? milestoneWildcardId,
    String? epicId,
    String? iterationTitle,
    String? weight,
    List<String>? iterationId,
    Input$NegatedBoardIssueInput? not,
    String? search,
    Enum$AssigneeWildcardId? assigneeWildcardId,
    bool? confidential,
    Enum$EpicWildcardId? epicWildcardId,
    Enum$IterationWildcardId? iterationWildcardId,
    List<String>? iterationCadenceId,
    Enum$WeightWildcardId? weightWildcardId,
  }) =>
      _res;
  CopyWith$Input$NegatedBoardIssueInput<TRes> get not =>
      CopyWith$Input$NegatedBoardIssueInput.stub(_res);
}

class Input$BoardListCreateInput {
  factory Input$BoardListCreateInput({
    bool? backlog,
    String? labelId,
    String? clientMutationId,
    required String boardId,
    String? milestoneId,
    String? iterationId,
    String? assigneeId,
  }) =>
      Input$BoardListCreateInput._({
        if (backlog != null) r'backlog': backlog,
        if (labelId != null) r'labelId': labelId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'boardId': boardId,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (iterationId != null) r'iterationId': iterationId,
        if (assigneeId != null) r'assigneeId': assigneeId,
      });

  Input$BoardListCreateInput._(this._$data);

  factory Input$BoardListCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('backlog')) {
      final l$backlog = data['backlog'];
      result$data['backlog'] = (l$backlog as bool?);
    }
    if (data.containsKey('labelId')) {
      final l$labelId = data['labelId'];
      result$data['labelId'] = (l$labelId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$boardId = data['boardId'];
    result$data['boardId'] = (l$boardId as String);
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    if (data.containsKey('assigneeId')) {
      final l$assigneeId = data['assigneeId'];
      result$data['assigneeId'] = (l$assigneeId as String?);
    }
    return Input$BoardListCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get backlog => (_$data['backlog'] as bool?);
  String? get labelId => (_$data['labelId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get boardId => (_$data['boardId'] as String);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  String? get iterationId => (_$data['iterationId'] as String?);
  String? get assigneeId => (_$data['assigneeId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('backlog')) {
      final l$backlog = backlog;
      result$data['backlog'] = l$backlog;
    }
    if (_$data.containsKey('labelId')) {
      final l$labelId = labelId;
      result$data['labelId'] = l$labelId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$boardId = boardId;
    result$data['boardId'] = l$boardId;
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    if (_$data.containsKey('assigneeId')) {
      final l$assigneeId = assigneeId;
      result$data['assigneeId'] = l$assigneeId;
    }
    return result$data;
  }

  CopyWith$Input$BoardListCreateInput<Input$BoardListCreateInput>
      get copyWith => CopyWith$Input$BoardListCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoardListCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$backlog = backlog;
    final lOther$backlog = other.backlog;
    if (_$data.containsKey('backlog') != other._$data.containsKey('backlog')) {
      return false;
    }
    if (l$backlog != lOther$backlog) {
      return false;
    }
    final l$labelId = labelId;
    final lOther$labelId = other.labelId;
    if (_$data.containsKey('labelId') != other._$data.containsKey('labelId')) {
      return false;
    }
    if (l$labelId != lOther$labelId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$boardId = boardId;
    final lOther$boardId = other.boardId;
    if (l$boardId != lOther$boardId) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$assigneeId = assigneeId;
    final lOther$assigneeId = other.assigneeId;
    if (_$data.containsKey('assigneeId') !=
        other._$data.containsKey('assigneeId')) {
      return false;
    }
    if (l$assigneeId != lOther$assigneeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$backlog = backlog;
    final l$labelId = labelId;
    final l$clientMutationId = clientMutationId;
    final l$boardId = boardId;
    final l$milestoneId = milestoneId;
    final l$iterationId = iterationId;
    final l$assigneeId = assigneeId;
    return Object.hashAll([
      _$data.containsKey('backlog') ? l$backlog : const {},
      _$data.containsKey('labelId') ? l$labelId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$boardId,
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
      _$data.containsKey('assigneeId') ? l$assigneeId : const {},
    ]);
  }
}

abstract class CopyWith$Input$BoardListCreateInput<TRes> {
  factory CopyWith$Input$BoardListCreateInput(
    Input$BoardListCreateInput instance,
    TRes Function(Input$BoardListCreateInput) then,
  ) = _CopyWithImpl$Input$BoardListCreateInput;

  factory CopyWith$Input$BoardListCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BoardListCreateInput;

  TRes call({
    bool? backlog,
    String? labelId,
    String? clientMutationId,
    String? boardId,
    String? milestoneId,
    String? iterationId,
    String? assigneeId,
  });
}

class _CopyWithImpl$Input$BoardListCreateInput<TRes>
    implements CopyWith$Input$BoardListCreateInput<TRes> {
  _CopyWithImpl$Input$BoardListCreateInput(
    this._instance,
    this._then,
  );

  final Input$BoardListCreateInput _instance;

  final TRes Function(Input$BoardListCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? backlog = _undefined,
    Object? labelId = _undefined,
    Object? clientMutationId = _undefined,
    Object? boardId = _undefined,
    Object? milestoneId = _undefined,
    Object? iterationId = _undefined,
    Object? assigneeId = _undefined,
  }) =>
      _then(Input$BoardListCreateInput._({
        ..._instance._$data,
        if (backlog != _undefined) 'backlog': (backlog as bool?),
        if (labelId != _undefined) 'labelId': (labelId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (boardId != _undefined && boardId != null)
          'boardId': (boardId as String),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
        if (assigneeId != _undefined) 'assigneeId': (assigneeId as String?),
      }));
}

class _CopyWithStubImpl$Input$BoardListCreateInput<TRes>
    implements CopyWith$Input$BoardListCreateInput<TRes> {
  _CopyWithStubImpl$Input$BoardListCreateInput(this._res);

  TRes _res;

  call({
    bool? backlog,
    String? labelId,
    String? clientMutationId,
    String? boardId,
    String? milestoneId,
    String? iterationId,
    String? assigneeId,
  }) =>
      _res;
}

class Input$BoardListUpdateLimitMetricsInput {
  factory Input$BoardListUpdateLimitMetricsInput({
    String? clientMutationId,
    required String listId,
    Enum$ListLimitMetric? limitMetric,
    int? maxIssueCount,
    int? maxIssueWeight,
  }) =>
      Input$BoardListUpdateLimitMetricsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
        if (limitMetric != null) r'limitMetric': limitMetric,
        if (maxIssueCount != null) r'maxIssueCount': maxIssueCount,
        if (maxIssueWeight != null) r'maxIssueWeight': maxIssueWeight,
      });

  Input$BoardListUpdateLimitMetricsInput._(this._$data);

  factory Input$BoardListUpdateLimitMetricsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    if (data.containsKey('limitMetric')) {
      final l$limitMetric = data['limitMetric'];
      result$data['limitMetric'] = l$limitMetric == null
          ? null
          : fromJson$Enum$ListLimitMetric((l$limitMetric as String));
    }
    if (data.containsKey('maxIssueCount')) {
      final l$maxIssueCount = data['maxIssueCount'];
      result$data['maxIssueCount'] = (l$maxIssueCount as int?);
    }
    if (data.containsKey('maxIssueWeight')) {
      final l$maxIssueWeight = data['maxIssueWeight'];
      result$data['maxIssueWeight'] = (l$maxIssueWeight as int?);
    }
    return Input$BoardListUpdateLimitMetricsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get listId => (_$data['listId'] as String);
  Enum$ListLimitMetric? get limitMetric =>
      (_$data['limitMetric'] as Enum$ListLimitMetric?);
  int? get maxIssueCount => (_$data['maxIssueCount'] as int?);
  int? get maxIssueWeight => (_$data['maxIssueWeight'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    if (_$data.containsKey('limitMetric')) {
      final l$limitMetric = limitMetric;
      result$data['limitMetric'] = l$limitMetric == null
          ? null
          : toJson$Enum$ListLimitMetric(l$limitMetric);
    }
    if (_$data.containsKey('maxIssueCount')) {
      final l$maxIssueCount = maxIssueCount;
      result$data['maxIssueCount'] = l$maxIssueCount;
    }
    if (_$data.containsKey('maxIssueWeight')) {
      final l$maxIssueWeight = maxIssueWeight;
      result$data['maxIssueWeight'] = l$maxIssueWeight;
    }
    return result$data;
  }

  CopyWith$Input$BoardListUpdateLimitMetricsInput<
          Input$BoardListUpdateLimitMetricsInput>
      get copyWith => CopyWith$Input$BoardListUpdateLimitMetricsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoardListUpdateLimitMetricsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    final l$limitMetric = limitMetric;
    final lOther$limitMetric = other.limitMetric;
    if (_$data.containsKey('limitMetric') !=
        other._$data.containsKey('limitMetric')) {
      return false;
    }
    if (l$limitMetric != lOther$limitMetric) {
      return false;
    }
    final l$maxIssueCount = maxIssueCount;
    final lOther$maxIssueCount = other.maxIssueCount;
    if (_$data.containsKey('maxIssueCount') !=
        other._$data.containsKey('maxIssueCount')) {
      return false;
    }
    if (l$maxIssueCount != lOther$maxIssueCount) {
      return false;
    }
    final l$maxIssueWeight = maxIssueWeight;
    final lOther$maxIssueWeight = other.maxIssueWeight;
    if (_$data.containsKey('maxIssueWeight') !=
        other._$data.containsKey('maxIssueWeight')) {
      return false;
    }
    if (l$maxIssueWeight != lOther$maxIssueWeight) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    final l$limitMetric = limitMetric;
    final l$maxIssueCount = maxIssueCount;
    final l$maxIssueWeight = maxIssueWeight;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
      _$data.containsKey('limitMetric') ? l$limitMetric : const {},
      _$data.containsKey('maxIssueCount') ? l$maxIssueCount : const {},
      _$data.containsKey('maxIssueWeight') ? l$maxIssueWeight : const {},
    ]);
  }
}

abstract class CopyWith$Input$BoardListUpdateLimitMetricsInput<TRes> {
  factory CopyWith$Input$BoardListUpdateLimitMetricsInput(
    Input$BoardListUpdateLimitMetricsInput instance,
    TRes Function(Input$BoardListUpdateLimitMetricsInput) then,
  ) = _CopyWithImpl$Input$BoardListUpdateLimitMetricsInput;

  factory CopyWith$Input$BoardListUpdateLimitMetricsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BoardListUpdateLimitMetricsInput;

  TRes call({
    String? clientMutationId,
    String? listId,
    Enum$ListLimitMetric? limitMetric,
    int? maxIssueCount,
    int? maxIssueWeight,
  });
}

class _CopyWithImpl$Input$BoardListUpdateLimitMetricsInput<TRes>
    implements CopyWith$Input$BoardListUpdateLimitMetricsInput<TRes> {
  _CopyWithImpl$Input$BoardListUpdateLimitMetricsInput(
    this._instance,
    this._then,
  );

  final Input$BoardListUpdateLimitMetricsInput _instance;

  final TRes Function(Input$BoardListUpdateLimitMetricsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
    Object? limitMetric = _undefined,
    Object? maxIssueCount = _undefined,
    Object? maxIssueWeight = _undefined,
  }) =>
      _then(Input$BoardListUpdateLimitMetricsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
        if (limitMetric != _undefined)
          'limitMetric': (limitMetric as Enum$ListLimitMetric?),
        if (maxIssueCount != _undefined)
          'maxIssueCount': (maxIssueCount as int?),
        if (maxIssueWeight != _undefined)
          'maxIssueWeight': (maxIssueWeight as int?),
      }));
}

class _CopyWithStubImpl$Input$BoardListUpdateLimitMetricsInput<TRes>
    implements CopyWith$Input$BoardListUpdateLimitMetricsInput<TRes> {
  _CopyWithStubImpl$Input$BoardListUpdateLimitMetricsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? listId,
    Enum$ListLimitMetric? limitMetric,
    int? maxIssueCount,
    int? maxIssueWeight,
  }) =>
      _res;
}

class Input$BulkEnableDevopsAdoptionNamespacesInput {
  factory Input$BulkEnableDevopsAdoptionNamespacesInput({
    String? clientMutationId,
    required List<String> namespaceIds,
    String? displayNamespaceId,
  }) =>
      Input$BulkEnableDevopsAdoptionNamespacesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'namespaceIds': namespaceIds,
        if (displayNamespaceId != null)
          r'displayNamespaceId': displayNamespaceId,
      });

  Input$BulkEnableDevopsAdoptionNamespacesInput._(this._$data);

  factory Input$BulkEnableDevopsAdoptionNamespacesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$namespaceIds = data['namespaceIds'];
    result$data['namespaceIds'] =
        (l$namespaceIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('displayNamespaceId')) {
      final l$displayNamespaceId = data['displayNamespaceId'];
      result$data['displayNamespaceId'] = (l$displayNamespaceId as String?);
    }
    return Input$BulkEnableDevopsAdoptionNamespacesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get namespaceIds => (_$data['namespaceIds'] as List<String>);
  String? get displayNamespaceId => (_$data['displayNamespaceId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$namespaceIds = namespaceIds;
    result$data['namespaceIds'] = l$namespaceIds.map((e) => e).toList();
    if (_$data.containsKey('displayNamespaceId')) {
      final l$displayNamespaceId = displayNamespaceId;
      result$data['displayNamespaceId'] = l$displayNamespaceId;
    }
    return result$data;
  }

  CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput<
          Input$BulkEnableDevopsAdoptionNamespacesInput>
      get copyWith => CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BulkEnableDevopsAdoptionNamespacesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$namespaceIds = namespaceIds;
    final lOther$namespaceIds = other.namespaceIds;
    if (l$namespaceIds.length != lOther$namespaceIds.length) {
      return false;
    }
    for (int i = 0; i < l$namespaceIds.length; i++) {
      final l$namespaceIds$entry = l$namespaceIds[i];
      final lOther$namespaceIds$entry = lOther$namespaceIds[i];
      if (l$namespaceIds$entry != lOther$namespaceIds$entry) {
        return false;
      }
    }
    final l$displayNamespaceId = displayNamespaceId;
    final lOther$displayNamespaceId = other.displayNamespaceId;
    if (_$data.containsKey('displayNamespaceId') !=
        other._$data.containsKey('displayNamespaceId')) {
      return false;
    }
    if (l$displayNamespaceId != lOther$displayNamespaceId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$namespaceIds = namespaceIds;
    final l$displayNamespaceId = displayNamespaceId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$namespaceIds.map((v) => v)),
      _$data.containsKey('displayNamespaceId')
          ? l$displayNamespaceId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput<TRes> {
  factory CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput(
    Input$BulkEnableDevopsAdoptionNamespacesInput instance,
    TRes Function(Input$BulkEnableDevopsAdoptionNamespacesInput) then,
  ) = _CopyWithImpl$Input$BulkEnableDevopsAdoptionNamespacesInput;

  factory CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BulkEnableDevopsAdoptionNamespacesInput;

  TRes call({
    String? clientMutationId,
    List<String>? namespaceIds,
    String? displayNamespaceId,
  });
}

class _CopyWithImpl$Input$BulkEnableDevopsAdoptionNamespacesInput<TRes>
    implements CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput<TRes> {
  _CopyWithImpl$Input$BulkEnableDevopsAdoptionNamespacesInput(
    this._instance,
    this._then,
  );

  final Input$BulkEnableDevopsAdoptionNamespacesInput _instance;

  final TRes Function(Input$BulkEnableDevopsAdoptionNamespacesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? namespaceIds = _undefined,
    Object? displayNamespaceId = _undefined,
  }) =>
      _then(Input$BulkEnableDevopsAdoptionNamespacesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (namespaceIds != _undefined && namespaceIds != null)
          'namespaceIds': (namespaceIds as List<String>),
        if (displayNamespaceId != _undefined)
          'displayNamespaceId': (displayNamespaceId as String?),
      }));
}

class _CopyWithStubImpl$Input$BulkEnableDevopsAdoptionNamespacesInput<TRes>
    implements CopyWith$Input$BulkEnableDevopsAdoptionNamespacesInput<TRes> {
  _CopyWithStubImpl$Input$BulkEnableDevopsAdoptionNamespacesInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? namespaceIds,
    String? displayNamespaceId,
  }) =>
      _res;
}

class Input$BulkRunnerDeleteInput {
  factory Input$BulkRunnerDeleteInput({
    String? clientMutationId,
    List<String>? ids,
  }) =>
      Input$BulkRunnerDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (ids != null) r'ids': ids,
      });

  Input$BulkRunnerDeleteInput._(this._$data);

  factory Input$BulkRunnerDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$BulkRunnerDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String>? get ids => (_$data['ids'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$BulkRunnerDeleteInput<Input$BulkRunnerDeleteInput>
      get copyWith => CopyWith$Input$BulkRunnerDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BulkRunnerDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$BulkRunnerDeleteInput<TRes> {
  factory CopyWith$Input$BulkRunnerDeleteInput(
    Input$BulkRunnerDeleteInput instance,
    TRes Function(Input$BulkRunnerDeleteInput) then,
  ) = _CopyWithImpl$Input$BulkRunnerDeleteInput;

  factory CopyWith$Input$BulkRunnerDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BulkRunnerDeleteInput;

  TRes call({
    String? clientMutationId,
    List<String>? ids,
  });
}

class _CopyWithImpl$Input$BulkRunnerDeleteInput<TRes>
    implements CopyWith$Input$BulkRunnerDeleteInput<TRes> {
  _CopyWithImpl$Input$BulkRunnerDeleteInput(
    this._instance,
    this._then,
  );

  final Input$BulkRunnerDeleteInput _instance;

  final TRes Function(Input$BulkRunnerDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$BulkRunnerDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$BulkRunnerDeleteInput<TRes>
    implements CopyWith$Input$BulkRunnerDeleteInput<TRes> {
  _CopyWithStubImpl$Input$BulkRunnerDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? ids,
  }) =>
      _res;
}

class Input$CiCdSettingsUpdateInput {
  factory Input$CiCdSettingsUpdateInput({
    required String fullPath,
    bool? keepLatestArtifact,
    bool? jobTokenScopeEnabled,
    bool? mergePipelinesEnabled,
    bool? mergeTrainsEnabled,
    String? clientMutationId,
  }) =>
      Input$CiCdSettingsUpdateInput._({
        r'fullPath': fullPath,
        if (keepLatestArtifact != null)
          r'keepLatestArtifact': keepLatestArtifact,
        if (jobTokenScopeEnabled != null)
          r'jobTokenScopeEnabled': jobTokenScopeEnabled,
        if (mergePipelinesEnabled != null)
          r'mergePipelinesEnabled': mergePipelinesEnabled,
        if (mergeTrainsEnabled != null)
          r'mergeTrainsEnabled': mergeTrainsEnabled,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CiCdSettingsUpdateInput._(this._$data);

  factory Input$CiCdSettingsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    if (data.containsKey('keepLatestArtifact')) {
      final l$keepLatestArtifact = data['keepLatestArtifact'];
      result$data['keepLatestArtifact'] = (l$keepLatestArtifact as bool?);
    }
    if (data.containsKey('jobTokenScopeEnabled')) {
      final l$jobTokenScopeEnabled = data['jobTokenScopeEnabled'];
      result$data['jobTokenScopeEnabled'] = (l$jobTokenScopeEnabled as bool?);
    }
    if (data.containsKey('mergePipelinesEnabled')) {
      final l$mergePipelinesEnabled = data['mergePipelinesEnabled'];
      result$data['mergePipelinesEnabled'] = (l$mergePipelinesEnabled as bool?);
    }
    if (data.containsKey('mergeTrainsEnabled')) {
      final l$mergeTrainsEnabled = data['mergeTrainsEnabled'];
      result$data['mergeTrainsEnabled'] = (l$mergeTrainsEnabled as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CiCdSettingsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get fullPath => (_$data['fullPath'] as String);
  bool? get keepLatestArtifact => (_$data['keepLatestArtifact'] as bool?);
  bool? get jobTokenScopeEnabled => (_$data['jobTokenScopeEnabled'] as bool?);
  bool? get mergePipelinesEnabled => (_$data['mergePipelinesEnabled'] as bool?);
  bool? get mergeTrainsEnabled => (_$data['mergeTrainsEnabled'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    if (_$data.containsKey('keepLatestArtifact')) {
      final l$keepLatestArtifact = keepLatestArtifact;
      result$data['keepLatestArtifact'] = l$keepLatestArtifact;
    }
    if (_$data.containsKey('jobTokenScopeEnabled')) {
      final l$jobTokenScopeEnabled = jobTokenScopeEnabled;
      result$data['jobTokenScopeEnabled'] = l$jobTokenScopeEnabled;
    }
    if (_$data.containsKey('mergePipelinesEnabled')) {
      final l$mergePipelinesEnabled = mergePipelinesEnabled;
      result$data['mergePipelinesEnabled'] = l$mergePipelinesEnabled;
    }
    if (_$data.containsKey('mergeTrainsEnabled')) {
      final l$mergeTrainsEnabled = mergeTrainsEnabled;
      result$data['mergeTrainsEnabled'] = l$mergeTrainsEnabled;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CiCdSettingsUpdateInput<Input$CiCdSettingsUpdateInput>
      get copyWith => CopyWith$Input$CiCdSettingsUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CiCdSettingsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$keepLatestArtifact = keepLatestArtifact;
    final lOther$keepLatestArtifact = other.keepLatestArtifact;
    if (_$data.containsKey('keepLatestArtifact') !=
        other._$data.containsKey('keepLatestArtifact')) {
      return false;
    }
    if (l$keepLatestArtifact != lOther$keepLatestArtifact) {
      return false;
    }
    final l$jobTokenScopeEnabled = jobTokenScopeEnabled;
    final lOther$jobTokenScopeEnabled = other.jobTokenScopeEnabled;
    if (_$data.containsKey('jobTokenScopeEnabled') !=
        other._$data.containsKey('jobTokenScopeEnabled')) {
      return false;
    }
    if (l$jobTokenScopeEnabled != lOther$jobTokenScopeEnabled) {
      return false;
    }
    final l$mergePipelinesEnabled = mergePipelinesEnabled;
    final lOther$mergePipelinesEnabled = other.mergePipelinesEnabled;
    if (_$data.containsKey('mergePipelinesEnabled') !=
        other._$data.containsKey('mergePipelinesEnabled')) {
      return false;
    }
    if (l$mergePipelinesEnabled != lOther$mergePipelinesEnabled) {
      return false;
    }
    final l$mergeTrainsEnabled = mergeTrainsEnabled;
    final lOther$mergeTrainsEnabled = other.mergeTrainsEnabled;
    if (_$data.containsKey('mergeTrainsEnabled') !=
        other._$data.containsKey('mergeTrainsEnabled')) {
      return false;
    }
    if (l$mergeTrainsEnabled != lOther$mergeTrainsEnabled) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fullPath = fullPath;
    final l$keepLatestArtifact = keepLatestArtifact;
    final l$jobTokenScopeEnabled = jobTokenScopeEnabled;
    final l$mergePipelinesEnabled = mergePipelinesEnabled;
    final l$mergeTrainsEnabled = mergeTrainsEnabled;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$fullPath,
      _$data.containsKey('keepLatestArtifact')
          ? l$keepLatestArtifact
          : const {},
      _$data.containsKey('jobTokenScopeEnabled')
          ? l$jobTokenScopeEnabled
          : const {},
      _$data.containsKey('mergePipelinesEnabled')
          ? l$mergePipelinesEnabled
          : const {},
      _$data.containsKey('mergeTrainsEnabled')
          ? l$mergeTrainsEnabled
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CiCdSettingsUpdateInput<TRes> {
  factory CopyWith$Input$CiCdSettingsUpdateInput(
    Input$CiCdSettingsUpdateInput instance,
    TRes Function(Input$CiCdSettingsUpdateInput) then,
  ) = _CopyWithImpl$Input$CiCdSettingsUpdateInput;

  factory CopyWith$Input$CiCdSettingsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CiCdSettingsUpdateInput;

  TRes call({
    String? fullPath,
    bool? keepLatestArtifact,
    bool? jobTokenScopeEnabled,
    bool? mergePipelinesEnabled,
    bool? mergeTrainsEnabled,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CiCdSettingsUpdateInput<TRes>
    implements CopyWith$Input$CiCdSettingsUpdateInput<TRes> {
  _CopyWithImpl$Input$CiCdSettingsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CiCdSettingsUpdateInput _instance;

  final TRes Function(Input$CiCdSettingsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fullPath = _undefined,
    Object? keepLatestArtifact = _undefined,
    Object? jobTokenScopeEnabled = _undefined,
    Object? mergePipelinesEnabled = _undefined,
    Object? mergeTrainsEnabled = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CiCdSettingsUpdateInput._({
        ..._instance._$data,
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (keepLatestArtifact != _undefined)
          'keepLatestArtifact': (keepLatestArtifact as bool?),
        if (jobTokenScopeEnabled != _undefined)
          'jobTokenScopeEnabled': (jobTokenScopeEnabled as bool?),
        if (mergePipelinesEnabled != _undefined)
          'mergePipelinesEnabled': (mergePipelinesEnabled as bool?),
        if (mergeTrainsEnabled != _undefined)
          'mergeTrainsEnabled': (mergeTrainsEnabled as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CiCdSettingsUpdateInput<TRes>
    implements CopyWith$Input$CiCdSettingsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CiCdSettingsUpdateInput(this._res);

  TRes _res;

  call({
    String? fullPath,
    bool? keepLatestArtifact,
    bool? jobTokenScopeEnabled,
    bool? mergePipelinesEnabled,
    bool? mergeTrainsEnabled,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CiJobTokenScopeAddProjectInput {
  factory Input$CiJobTokenScopeAddProjectInput({
    String? clientMutationId,
    required String projectPath,
    required String targetProjectPath,
  }) =>
      Input$CiJobTokenScopeAddProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'targetProjectPath': targetProjectPath,
      });

  Input$CiJobTokenScopeAddProjectInput._(this._$data);

  factory Input$CiJobTokenScopeAddProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$targetProjectPath = data['targetProjectPath'];
    result$data['targetProjectPath'] = (l$targetProjectPath as String);
    return Input$CiJobTokenScopeAddProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get targetProjectPath => (_$data['targetProjectPath'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$targetProjectPath = targetProjectPath;
    result$data['targetProjectPath'] = l$targetProjectPath;
    return result$data;
  }

  CopyWith$Input$CiJobTokenScopeAddProjectInput<
          Input$CiJobTokenScopeAddProjectInput>
      get copyWith => CopyWith$Input$CiJobTokenScopeAddProjectInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CiJobTokenScopeAddProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$targetProjectPath = targetProjectPath;
    final lOther$targetProjectPath = other.targetProjectPath;
    if (l$targetProjectPath != lOther$targetProjectPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$targetProjectPath = targetProjectPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$targetProjectPath,
    ]);
  }
}

abstract class CopyWith$Input$CiJobTokenScopeAddProjectInput<TRes> {
  factory CopyWith$Input$CiJobTokenScopeAddProjectInput(
    Input$CiJobTokenScopeAddProjectInput instance,
    TRes Function(Input$CiJobTokenScopeAddProjectInput) then,
  ) = _CopyWithImpl$Input$CiJobTokenScopeAddProjectInput;

  factory CopyWith$Input$CiJobTokenScopeAddProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CiJobTokenScopeAddProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? targetProjectPath,
  });
}

class _CopyWithImpl$Input$CiJobTokenScopeAddProjectInput<TRes>
    implements CopyWith$Input$CiJobTokenScopeAddProjectInput<TRes> {
  _CopyWithImpl$Input$CiJobTokenScopeAddProjectInput(
    this._instance,
    this._then,
  );

  final Input$CiJobTokenScopeAddProjectInput _instance;

  final TRes Function(Input$CiJobTokenScopeAddProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? targetProjectPath = _undefined,
  }) =>
      _then(Input$CiJobTokenScopeAddProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (targetProjectPath != _undefined && targetProjectPath != null)
          'targetProjectPath': (targetProjectPath as String),
      }));
}

class _CopyWithStubImpl$Input$CiJobTokenScopeAddProjectInput<TRes>
    implements CopyWith$Input$CiJobTokenScopeAddProjectInput<TRes> {
  _CopyWithStubImpl$Input$CiJobTokenScopeAddProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? targetProjectPath,
  }) =>
      _res;
}

class Input$CiJobTokenScopeRemoveProjectInput {
  factory Input$CiJobTokenScopeRemoveProjectInput({
    String? clientMutationId,
    required String projectPath,
    required String targetProjectPath,
  }) =>
      Input$CiJobTokenScopeRemoveProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'targetProjectPath': targetProjectPath,
      });

  Input$CiJobTokenScopeRemoveProjectInput._(this._$data);

  factory Input$CiJobTokenScopeRemoveProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$targetProjectPath = data['targetProjectPath'];
    result$data['targetProjectPath'] = (l$targetProjectPath as String);
    return Input$CiJobTokenScopeRemoveProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get targetProjectPath => (_$data['targetProjectPath'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$targetProjectPath = targetProjectPath;
    result$data['targetProjectPath'] = l$targetProjectPath;
    return result$data;
  }

  CopyWith$Input$CiJobTokenScopeRemoveProjectInput<
          Input$CiJobTokenScopeRemoveProjectInput>
      get copyWith => CopyWith$Input$CiJobTokenScopeRemoveProjectInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CiJobTokenScopeRemoveProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$targetProjectPath = targetProjectPath;
    final lOther$targetProjectPath = other.targetProjectPath;
    if (l$targetProjectPath != lOther$targetProjectPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$targetProjectPath = targetProjectPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$targetProjectPath,
    ]);
  }
}

abstract class CopyWith$Input$CiJobTokenScopeRemoveProjectInput<TRes> {
  factory CopyWith$Input$CiJobTokenScopeRemoveProjectInput(
    Input$CiJobTokenScopeRemoveProjectInput instance,
    TRes Function(Input$CiJobTokenScopeRemoveProjectInput) then,
  ) = _CopyWithImpl$Input$CiJobTokenScopeRemoveProjectInput;

  factory CopyWith$Input$CiJobTokenScopeRemoveProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CiJobTokenScopeRemoveProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? targetProjectPath,
  });
}

class _CopyWithImpl$Input$CiJobTokenScopeRemoveProjectInput<TRes>
    implements CopyWith$Input$CiJobTokenScopeRemoveProjectInput<TRes> {
  _CopyWithImpl$Input$CiJobTokenScopeRemoveProjectInput(
    this._instance,
    this._then,
  );

  final Input$CiJobTokenScopeRemoveProjectInput _instance;

  final TRes Function(Input$CiJobTokenScopeRemoveProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? targetProjectPath = _undefined,
  }) =>
      _then(Input$CiJobTokenScopeRemoveProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (targetProjectPath != _undefined && targetProjectPath != null)
          'targetProjectPath': (targetProjectPath as String),
      }));
}

class _CopyWithStubImpl$Input$CiJobTokenScopeRemoveProjectInput<TRes>
    implements CopyWith$Input$CiJobTokenScopeRemoveProjectInput<TRes> {
  _CopyWithStubImpl$Input$CiJobTokenScopeRemoveProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? targetProjectPath,
  }) =>
      _res;
}

class Input$CiVariableInput {
  factory Input$CiVariableInput({
    required String key,
    required String value,
  }) =>
      Input$CiVariableInput._({
        r'key': key,
        r'value': value,
      });

  Input$CiVariableInput._(this._$data);

  factory Input$CiVariableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$CiVariableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get key => (_$data['key'] as String);
  String get value => (_$data['value'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$key = key;
    result$data['key'] = l$key;
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$CiVariableInput<Input$CiVariableInput> get copyWith =>
      CopyWith$Input$CiVariableInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CiVariableInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$key = key;
    final l$value = value;
    return Object.hashAll([
      l$key,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$CiVariableInput<TRes> {
  factory CopyWith$Input$CiVariableInput(
    Input$CiVariableInput instance,
    TRes Function(Input$CiVariableInput) then,
  ) = _CopyWithImpl$Input$CiVariableInput;

  factory CopyWith$Input$CiVariableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CiVariableInput;

  TRes call({
    String? key,
    String? value,
  });
}

class _CopyWithImpl$Input$CiVariableInput<TRes>
    implements CopyWith$Input$CiVariableInput<TRes> {
  _CopyWithImpl$Input$CiVariableInput(
    this._instance,
    this._then,
  );

  final Input$CiVariableInput _instance;

  final TRes Function(Input$CiVariableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? key = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$CiVariableInput._({
        ..._instance._$data,
        if (key != _undefined && key != null) 'key': (key as String),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$CiVariableInput<TRes>
    implements CopyWith$Input$CiVariableInput<TRes> {
  _CopyWithStubImpl$Input$CiVariableInput(this._res);

  TRes _res;

  call({
    String? key,
    String? value,
  }) =>
      _res;
}

class Input$ClusterAgentDeleteInput {
  factory Input$ClusterAgentDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$ClusterAgentDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$ClusterAgentDeleteInput._(this._$data);

  factory Input$ClusterAgentDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ClusterAgentDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ClusterAgentDeleteInput<Input$ClusterAgentDeleteInput>
      get copyWith => CopyWith$Input$ClusterAgentDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClusterAgentDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ClusterAgentDeleteInput<TRes> {
  factory CopyWith$Input$ClusterAgentDeleteInput(
    Input$ClusterAgentDeleteInput instance,
    TRes Function(Input$ClusterAgentDeleteInput) then,
  ) = _CopyWithImpl$Input$ClusterAgentDeleteInput;

  factory CopyWith$Input$ClusterAgentDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClusterAgentDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$ClusterAgentDeleteInput<TRes>
    implements CopyWith$Input$ClusterAgentDeleteInput<TRes> {
  _CopyWithImpl$Input$ClusterAgentDeleteInput(
    this._instance,
    this._then,
  );

  final Input$ClusterAgentDeleteInput _instance;

  final TRes Function(Input$ClusterAgentDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ClusterAgentDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$ClusterAgentDeleteInput<TRes>
    implements CopyWith$Input$ClusterAgentDeleteInput<TRes> {
  _CopyWithStubImpl$Input$ClusterAgentDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$ClusterAgentTokenCreateInput {
  factory Input$ClusterAgentTokenCreateInput({
    String? clientMutationId,
    required String clusterAgentId,
    String? description,
    required String name,
  }) =>
      Input$ClusterAgentTokenCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'clusterAgentId': clusterAgentId,
        if (description != null) r'description': description,
        r'name': name,
      });

  Input$ClusterAgentTokenCreateInput._(this._$data);

  factory Input$ClusterAgentTokenCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$clusterAgentId = data['clusterAgentId'];
    result$data['clusterAgentId'] = (l$clusterAgentId as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$ClusterAgentTokenCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get clusterAgentId => (_$data['clusterAgentId'] as String);
  String? get description => (_$data['description'] as String?);
  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$clusterAgentId = clusterAgentId;
    result$data['clusterAgentId'] = l$clusterAgentId;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$ClusterAgentTokenCreateInput<
          Input$ClusterAgentTokenCreateInput>
      get copyWith => CopyWith$Input$ClusterAgentTokenCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClusterAgentTokenCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$clusterAgentId = clusterAgentId;
    final lOther$clusterAgentId = other.clusterAgentId;
    if (l$clusterAgentId != lOther$clusterAgentId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$clusterAgentId = clusterAgentId;
    final l$description = description;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$clusterAgentId,
      _$data.containsKey('description') ? l$description : const {},
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$ClusterAgentTokenCreateInput<TRes> {
  factory CopyWith$Input$ClusterAgentTokenCreateInput(
    Input$ClusterAgentTokenCreateInput instance,
    TRes Function(Input$ClusterAgentTokenCreateInput) then,
  ) = _CopyWithImpl$Input$ClusterAgentTokenCreateInput;

  factory CopyWith$Input$ClusterAgentTokenCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClusterAgentTokenCreateInput;

  TRes call({
    String? clientMutationId,
    String? clusterAgentId,
    String? description,
    String? name,
  });
}

class _CopyWithImpl$Input$ClusterAgentTokenCreateInput<TRes>
    implements CopyWith$Input$ClusterAgentTokenCreateInput<TRes> {
  _CopyWithImpl$Input$ClusterAgentTokenCreateInput(
    this._instance,
    this._then,
  );

  final Input$ClusterAgentTokenCreateInput _instance;

  final TRes Function(Input$ClusterAgentTokenCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? clusterAgentId = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ClusterAgentTokenCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (clusterAgentId != _undefined && clusterAgentId != null)
          'clusterAgentId': (clusterAgentId as String),
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$ClusterAgentTokenCreateInput<TRes>
    implements CopyWith$Input$ClusterAgentTokenCreateInput<TRes> {
  _CopyWithStubImpl$Input$ClusterAgentTokenCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? clusterAgentId,
    String? description,
    String? name,
  }) =>
      _res;
}

class Input$ClusterAgentTokenRevokeInput {
  factory Input$ClusterAgentTokenRevokeInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$ClusterAgentTokenRevokeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$ClusterAgentTokenRevokeInput._(this._$data);

  factory Input$ClusterAgentTokenRevokeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ClusterAgentTokenRevokeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ClusterAgentTokenRevokeInput<
          Input$ClusterAgentTokenRevokeInput>
      get copyWith => CopyWith$Input$ClusterAgentTokenRevokeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClusterAgentTokenRevokeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ClusterAgentTokenRevokeInput<TRes> {
  factory CopyWith$Input$ClusterAgentTokenRevokeInput(
    Input$ClusterAgentTokenRevokeInput instance,
    TRes Function(Input$ClusterAgentTokenRevokeInput) then,
  ) = _CopyWithImpl$Input$ClusterAgentTokenRevokeInput;

  factory CopyWith$Input$ClusterAgentTokenRevokeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClusterAgentTokenRevokeInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$ClusterAgentTokenRevokeInput<TRes>
    implements CopyWith$Input$ClusterAgentTokenRevokeInput<TRes> {
  _CopyWithImpl$Input$ClusterAgentTokenRevokeInput(
    this._instance,
    this._then,
  );

  final Input$ClusterAgentTokenRevokeInput _instance;

  final TRes Function(Input$ClusterAgentTokenRevokeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ClusterAgentTokenRevokeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$ClusterAgentTokenRevokeInput<TRes>
    implements CopyWith$Input$ClusterAgentTokenRevokeInput<TRes> {
  _CopyWithStubImpl$Input$ClusterAgentTokenRevokeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$CommitAction {
  factory Input$CommitAction({
    required Enum$CommitActionMode action,
    String? content,
    Enum$CommitEncoding? encoding,
    bool? executeFilemode,
    required String filePath,
    String? lastCommitId,
    String? previousPath,
  }) =>
      Input$CommitAction._({
        r'action': action,
        if (content != null) r'content': content,
        if (encoding != null) r'encoding': encoding,
        if (executeFilemode != null) r'executeFilemode': executeFilemode,
        r'filePath': filePath,
        if (lastCommitId != null) r'lastCommitId': lastCommitId,
        if (previousPath != null) r'previousPath': previousPath,
      });

  Input$CommitAction._(this._$data);

  factory Input$CommitAction.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$action = data['action'];
    result$data['action'] =
        fromJson$Enum$CommitActionMode((l$action as String));
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('encoding')) {
      final l$encoding = data['encoding'];
      result$data['encoding'] = l$encoding == null
          ? null
          : fromJson$Enum$CommitEncoding((l$encoding as String));
    }
    if (data.containsKey('executeFilemode')) {
      final l$executeFilemode = data['executeFilemode'];
      result$data['executeFilemode'] = (l$executeFilemode as bool?);
    }
    final l$filePath = data['filePath'];
    result$data['filePath'] = (l$filePath as String);
    if (data.containsKey('lastCommitId')) {
      final l$lastCommitId = data['lastCommitId'];
      result$data['lastCommitId'] = (l$lastCommitId as String?);
    }
    if (data.containsKey('previousPath')) {
      final l$previousPath = data['previousPath'];
      result$data['previousPath'] = (l$previousPath as String?);
    }
    return Input$CommitAction._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CommitActionMode get action =>
      (_$data['action'] as Enum$CommitActionMode);
  String? get content => (_$data['content'] as String?);
  Enum$CommitEncoding? get encoding =>
      (_$data['encoding'] as Enum$CommitEncoding?);
  bool? get executeFilemode => (_$data['executeFilemode'] as bool?);
  String get filePath => (_$data['filePath'] as String);
  String? get lastCommitId => (_$data['lastCommitId'] as String?);
  String? get previousPath => (_$data['previousPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$action = action;
    result$data['action'] = toJson$Enum$CommitActionMode(l$action);
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('encoding')) {
      final l$encoding = encoding;
      result$data['encoding'] =
          l$encoding == null ? null : toJson$Enum$CommitEncoding(l$encoding);
    }
    if (_$data.containsKey('executeFilemode')) {
      final l$executeFilemode = executeFilemode;
      result$data['executeFilemode'] = l$executeFilemode;
    }
    final l$filePath = filePath;
    result$data['filePath'] = l$filePath;
    if (_$data.containsKey('lastCommitId')) {
      final l$lastCommitId = lastCommitId;
      result$data['lastCommitId'] = l$lastCommitId;
    }
    if (_$data.containsKey('previousPath')) {
      final l$previousPath = previousPath;
      result$data['previousPath'] = l$previousPath;
    }
    return result$data;
  }

  CopyWith$Input$CommitAction<Input$CommitAction> get copyWith =>
      CopyWith$Input$CommitAction(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitAction) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (l$action != lOther$action) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$encoding = encoding;
    final lOther$encoding = other.encoding;
    if (_$data.containsKey('encoding') !=
        other._$data.containsKey('encoding')) {
      return false;
    }
    if (l$encoding != lOther$encoding) {
      return false;
    }
    final l$executeFilemode = executeFilemode;
    final lOther$executeFilemode = other.executeFilemode;
    if (_$data.containsKey('executeFilemode') !=
        other._$data.containsKey('executeFilemode')) {
      return false;
    }
    if (l$executeFilemode != lOther$executeFilemode) {
      return false;
    }
    final l$filePath = filePath;
    final lOther$filePath = other.filePath;
    if (l$filePath != lOther$filePath) {
      return false;
    }
    final l$lastCommitId = lastCommitId;
    final lOther$lastCommitId = other.lastCommitId;
    if (_$data.containsKey('lastCommitId') !=
        other._$data.containsKey('lastCommitId')) {
      return false;
    }
    if (l$lastCommitId != lOther$lastCommitId) {
      return false;
    }
    final l$previousPath = previousPath;
    final lOther$previousPath = other.previousPath;
    if (_$data.containsKey('previousPath') !=
        other._$data.containsKey('previousPath')) {
      return false;
    }
    if (l$previousPath != lOther$previousPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$action = action;
    final l$content = content;
    final l$encoding = encoding;
    final l$executeFilemode = executeFilemode;
    final l$filePath = filePath;
    final l$lastCommitId = lastCommitId;
    final l$previousPath = previousPath;
    return Object.hashAll([
      l$action,
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('encoding') ? l$encoding : const {},
      _$data.containsKey('executeFilemode') ? l$executeFilemode : const {},
      l$filePath,
      _$data.containsKey('lastCommitId') ? l$lastCommitId : const {},
      _$data.containsKey('previousPath') ? l$previousPath : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommitAction<TRes> {
  factory CopyWith$Input$CommitAction(
    Input$CommitAction instance,
    TRes Function(Input$CommitAction) then,
  ) = _CopyWithImpl$Input$CommitAction;

  factory CopyWith$Input$CommitAction.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitAction;

  TRes call({
    Enum$CommitActionMode? action,
    String? content,
    Enum$CommitEncoding? encoding,
    bool? executeFilemode,
    String? filePath,
    String? lastCommitId,
    String? previousPath,
  });
}

class _CopyWithImpl$Input$CommitAction<TRes>
    implements CopyWith$Input$CommitAction<TRes> {
  _CopyWithImpl$Input$CommitAction(
    this._instance,
    this._then,
  );

  final Input$CommitAction _instance;

  final TRes Function(Input$CommitAction) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? action = _undefined,
    Object? content = _undefined,
    Object? encoding = _undefined,
    Object? executeFilemode = _undefined,
    Object? filePath = _undefined,
    Object? lastCommitId = _undefined,
    Object? previousPath = _undefined,
  }) =>
      _then(Input$CommitAction._({
        ..._instance._$data,
        if (action != _undefined && action != null)
          'action': (action as Enum$CommitActionMode),
        if (content != _undefined) 'content': (content as String?),
        if (encoding != _undefined)
          'encoding': (encoding as Enum$CommitEncoding?),
        if (executeFilemode != _undefined)
          'executeFilemode': (executeFilemode as bool?),
        if (filePath != _undefined && filePath != null)
          'filePath': (filePath as String),
        if (lastCommitId != _undefined)
          'lastCommitId': (lastCommitId as String?),
        if (previousPath != _undefined)
          'previousPath': (previousPath as String?),
      }));
}

class _CopyWithStubImpl$Input$CommitAction<TRes>
    implements CopyWith$Input$CommitAction<TRes> {
  _CopyWithStubImpl$Input$CommitAction(this._res);

  TRes _res;

  call({
    Enum$CommitActionMode? action,
    String? content,
    Enum$CommitEncoding? encoding,
    bool? executeFilemode,
    String? filePath,
    String? lastCommitId,
    String? previousPath,
  }) =>
      _res;
}

class Input$CommitCreateInput {
  factory Input$CommitCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String branch,
    String? startBranch,
    required String message,
    required List<Input$CommitAction> actions,
  }) =>
      Input$CommitCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'branch': branch,
        if (startBranch != null) r'startBranch': startBranch,
        r'message': message,
        r'actions': actions,
      });

  Input$CommitCreateInput._(this._$data);

  factory Input$CommitCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$branch = data['branch'];
    result$data['branch'] = (l$branch as String);
    if (data.containsKey('startBranch')) {
      final l$startBranch = data['startBranch'];
      result$data['startBranch'] = (l$startBranch as String?);
    }
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    final l$actions = data['actions'];
    result$data['actions'] = (l$actions as List<dynamic>)
        .map((e) => Input$CommitAction.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$CommitCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get branch => (_$data['branch'] as String);
  String? get startBranch => (_$data['startBranch'] as String?);
  String get message => (_$data['message'] as String);
  List<Input$CommitAction> get actions =>
      (_$data['actions'] as List<Input$CommitAction>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$branch = branch;
    result$data['branch'] = l$branch;
    if (_$data.containsKey('startBranch')) {
      final l$startBranch = startBranch;
      result$data['startBranch'] = l$startBranch;
    }
    final l$message = message;
    result$data['message'] = l$message;
    final l$actions = actions;
    result$data['actions'] = l$actions.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$CommitCreateInput<Input$CommitCreateInput> get copyWith =>
      CopyWith$Input$CommitCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$branch = branch;
    final lOther$branch = other.branch;
    if (l$branch != lOther$branch) {
      return false;
    }
    final l$startBranch = startBranch;
    final lOther$startBranch = other.startBranch;
    if (_$data.containsKey('startBranch') !=
        other._$data.containsKey('startBranch')) {
      return false;
    }
    if (l$startBranch != lOther$startBranch) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (l$actions.length != lOther$actions.length) {
      return false;
    }
    for (int i = 0; i < l$actions.length; i++) {
      final l$actions$entry = l$actions[i];
      final lOther$actions$entry = lOther$actions[i];
      if (l$actions$entry != lOther$actions$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$branch = branch;
    final l$startBranch = startBranch;
    final l$message = message;
    final l$actions = actions;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$branch,
      _$data.containsKey('startBranch') ? l$startBranch : const {},
      l$message,
      Object.hashAll(l$actions.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$CommitCreateInput<TRes> {
  factory CopyWith$Input$CommitCreateInput(
    Input$CommitCreateInput instance,
    TRes Function(Input$CommitCreateInput) then,
  ) = _CopyWithImpl$Input$CommitCreateInput;

  factory CopyWith$Input$CommitCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? branch,
    String? startBranch,
    String? message,
    List<Input$CommitAction>? actions,
  });
  TRes actions(
      Iterable<Input$CommitAction> Function(
              Iterable<CopyWith$Input$CommitAction<Input$CommitAction>>)
          _fn);
}

class _CopyWithImpl$Input$CommitCreateInput<TRes>
    implements CopyWith$Input$CommitCreateInput<TRes> {
  _CopyWithImpl$Input$CommitCreateInput(
    this._instance,
    this._then,
  );

  final Input$CommitCreateInput _instance;

  final TRes Function(Input$CommitCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? branch = _undefined,
    Object? startBranch = _undefined,
    Object? message = _undefined,
    Object? actions = _undefined,
  }) =>
      _then(Input$CommitCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (branch != _undefined && branch != null)
          'branch': (branch as String),
        if (startBranch != _undefined) 'startBranch': (startBranch as String?),
        if (message != _undefined && message != null)
          'message': (message as String),
        if (actions != _undefined && actions != null)
          'actions': (actions as List<Input$CommitAction>),
      }));
  TRes actions(
          Iterable<Input$CommitAction> Function(
                  Iterable<CopyWith$Input$CommitAction<Input$CommitAction>>)
              _fn) =>
      call(
          actions: _fn(_instance.actions.map((e) => CopyWith$Input$CommitAction(
                e,
                (i) => i,
              ))).toList());
}

class _CopyWithStubImpl$Input$CommitCreateInput<TRes>
    implements CopyWith$Input$CommitCreateInput<TRes> {
  _CopyWithStubImpl$Input$CommitCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? branch,
    String? startBranch,
    String? message,
    List<Input$CommitAction>? actions,
  }) =>
      _res;
  actions(_fn) => _res;
}

class Input$ComplianceFrameworkInput {
  factory Input$ComplianceFrameworkInput({
    String? name,
    String? description,
    String? color,
    String? pipelineConfigurationFullPath,
  }) =>
      Input$ComplianceFrameworkInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (color != null) r'color': color,
        if (pipelineConfigurationFullPath != null)
          r'pipelineConfigurationFullPath': pipelineConfigurationFullPath,
      });

  Input$ComplianceFrameworkInput._(this._$data);

  factory Input$ComplianceFrameworkInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = (l$color as String?);
    }
    if (data.containsKey('pipelineConfigurationFullPath')) {
      final l$pipelineConfigurationFullPath =
          data['pipelineConfigurationFullPath'];
      result$data['pipelineConfigurationFullPath'] =
          (l$pipelineConfigurationFullPath as String?);
    }
    return Input$ComplianceFrameworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get color => (_$data['color'] as String?);
  String? get pipelineConfigurationFullPath =>
      (_$data['pipelineConfigurationFullPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color;
    }
    if (_$data.containsKey('pipelineConfigurationFullPath')) {
      final l$pipelineConfigurationFullPath = pipelineConfigurationFullPath;
      result$data['pipelineConfigurationFullPath'] =
          l$pipelineConfigurationFullPath;
    }
    return result$data;
  }

  CopyWith$Input$ComplianceFrameworkInput<Input$ComplianceFrameworkInput>
      get copyWith => CopyWith$Input$ComplianceFrameworkInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComplianceFrameworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$pipelineConfigurationFullPath = pipelineConfigurationFullPath;
    final lOther$pipelineConfigurationFullPath =
        other.pipelineConfigurationFullPath;
    if (_$data.containsKey('pipelineConfigurationFullPath') !=
        other._$data.containsKey('pipelineConfigurationFullPath')) {
      return false;
    }
    if (l$pipelineConfigurationFullPath !=
        lOther$pipelineConfigurationFullPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$color = color;
    final l$pipelineConfigurationFullPath = pipelineConfigurationFullPath;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('pipelineConfigurationFullPath')
          ? l$pipelineConfigurationFullPath
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComplianceFrameworkInput<TRes> {
  factory CopyWith$Input$ComplianceFrameworkInput(
    Input$ComplianceFrameworkInput instance,
    TRes Function(Input$ComplianceFrameworkInput) then,
  ) = _CopyWithImpl$Input$ComplianceFrameworkInput;

  factory CopyWith$Input$ComplianceFrameworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ComplianceFrameworkInput;

  TRes call({
    String? name,
    String? description,
    String? color,
    String? pipelineConfigurationFullPath,
  });
}

class _CopyWithImpl$Input$ComplianceFrameworkInput<TRes>
    implements CopyWith$Input$ComplianceFrameworkInput<TRes> {
  _CopyWithImpl$Input$ComplianceFrameworkInput(
    this._instance,
    this._then,
  );

  final Input$ComplianceFrameworkInput _instance;

  final TRes Function(Input$ComplianceFrameworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? color = _undefined,
    Object? pipelineConfigurationFullPath = _undefined,
  }) =>
      _then(Input$ComplianceFrameworkInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (color != _undefined) 'color': (color as String?),
        if (pipelineConfigurationFullPath != _undefined)
          'pipelineConfigurationFullPath':
              (pipelineConfigurationFullPath as String?),
      }));
}

class _CopyWithStubImpl$Input$ComplianceFrameworkInput<TRes>
    implements CopyWith$Input$ComplianceFrameworkInput<TRes> {
  _CopyWithStubImpl$Input$ComplianceFrameworkInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    String? color,
    String? pipelineConfigurationFullPath,
  }) =>
      _res;
}

class Input$ComplianceViolationInput {
  factory Input$ComplianceViolationInput({
    List<String>? projectIds,
    String? mergedBefore,
    String? mergedAfter,
  }) =>
      Input$ComplianceViolationInput._({
        if (projectIds != null) r'projectIds': projectIds,
        if (mergedBefore != null) r'mergedBefore': mergedBefore,
        if (mergedAfter != null) r'mergedAfter': mergedAfter,
      });

  Input$ComplianceViolationInput._(this._$data);

  factory Input$ComplianceViolationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('mergedBefore')) {
      final l$mergedBefore = data['mergedBefore'];
      result$data['mergedBefore'] = (l$mergedBefore as String?);
    }
    if (data.containsKey('mergedAfter')) {
      final l$mergedAfter = data['mergedAfter'];
      result$data['mergedAfter'] = (l$mergedAfter as String?);
    }
    return Input$ComplianceViolationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  String? get mergedBefore => (_$data['mergedBefore'] as String?);
  String? get mergedAfter => (_$data['mergedAfter'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('mergedBefore')) {
      final l$mergedBefore = mergedBefore;
      result$data['mergedBefore'] = l$mergedBefore;
    }
    if (_$data.containsKey('mergedAfter')) {
      final l$mergedAfter = mergedAfter;
      result$data['mergedAfter'] = l$mergedAfter;
    }
    return result$data;
  }

  CopyWith$Input$ComplianceViolationInput<Input$ComplianceViolationInput>
      get copyWith => CopyWith$Input$ComplianceViolationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ComplianceViolationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$mergedBefore = mergedBefore;
    final lOther$mergedBefore = other.mergedBefore;
    if (_$data.containsKey('mergedBefore') !=
        other._$data.containsKey('mergedBefore')) {
      return false;
    }
    if (l$mergedBefore != lOther$mergedBefore) {
      return false;
    }
    final l$mergedAfter = mergedAfter;
    final lOther$mergedAfter = other.mergedAfter;
    if (_$data.containsKey('mergedAfter') !=
        other._$data.containsKey('mergedAfter')) {
      return false;
    }
    if (l$mergedAfter != lOther$mergedAfter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectIds = projectIds;
    final l$mergedBefore = mergedBefore;
    final l$mergedAfter = mergedAfter;
    return Object.hashAll([
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('mergedBefore') ? l$mergedBefore : const {},
      _$data.containsKey('mergedAfter') ? l$mergedAfter : const {},
    ]);
  }
}

abstract class CopyWith$Input$ComplianceViolationInput<TRes> {
  factory CopyWith$Input$ComplianceViolationInput(
    Input$ComplianceViolationInput instance,
    TRes Function(Input$ComplianceViolationInput) then,
  ) = _CopyWithImpl$Input$ComplianceViolationInput;

  factory CopyWith$Input$ComplianceViolationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ComplianceViolationInput;

  TRes call({
    List<String>? projectIds,
    String? mergedBefore,
    String? mergedAfter,
  });
}

class _CopyWithImpl$Input$ComplianceViolationInput<TRes>
    implements CopyWith$Input$ComplianceViolationInput<TRes> {
  _CopyWithImpl$Input$ComplianceViolationInput(
    this._instance,
    this._then,
  );

  final Input$ComplianceViolationInput _instance;

  final TRes Function(Input$ComplianceViolationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectIds = _undefined,
    Object? mergedBefore = _undefined,
    Object? mergedAfter = _undefined,
  }) =>
      _then(Input$ComplianceViolationInput._({
        ..._instance._$data,
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (mergedBefore != _undefined)
          'mergedBefore': (mergedBefore as String?),
        if (mergedAfter != _undefined) 'mergedAfter': (mergedAfter as String?),
      }));
}

class _CopyWithStubImpl$Input$ComplianceViolationInput<TRes>
    implements CopyWith$Input$ComplianceViolationInput<TRes> {
  _CopyWithStubImpl$Input$ComplianceViolationInput(this._res);

  TRes _res;

  call({
    List<String>? projectIds,
    String? mergedBefore,
    String? mergedAfter,
  }) =>
      _res;
}

class Input$ConfigureContainerScanningInput {
  factory Input$ConfigureContainerScanningInput({
    required String projectPath,
    String? clientMutationId,
  }) =>
      Input$ConfigureContainerScanningInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ConfigureContainerScanningInput._(this._$data);

  factory Input$ConfigureContainerScanningInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ConfigureContainerScanningInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ConfigureContainerScanningInput<
          Input$ConfigureContainerScanningInput>
      get copyWith => CopyWith$Input$ConfigureContainerScanningInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConfigureContainerScanningInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConfigureContainerScanningInput<TRes> {
  factory CopyWith$Input$ConfigureContainerScanningInput(
    Input$ConfigureContainerScanningInput instance,
    TRes Function(Input$ConfigureContainerScanningInput) then,
  ) = _CopyWithImpl$Input$ConfigureContainerScanningInput;

  factory CopyWith$Input$ConfigureContainerScanningInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConfigureContainerScanningInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ConfigureContainerScanningInput<TRes>
    implements CopyWith$Input$ConfigureContainerScanningInput<TRes> {
  _CopyWithImpl$Input$ConfigureContainerScanningInput(
    this._instance,
    this._then,
  );

  final Input$ConfigureContainerScanningInput _instance;

  final TRes Function(Input$ConfigureContainerScanningInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ConfigureContainerScanningInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ConfigureContainerScanningInput<TRes>
    implements CopyWith$Input$ConfigureContainerScanningInput<TRes> {
  _CopyWithStubImpl$Input$ConfigureContainerScanningInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ConfigureDependencyScanningInput {
  factory Input$ConfigureDependencyScanningInput({
    required String projectPath,
    String? clientMutationId,
  }) =>
      Input$ConfigureDependencyScanningInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ConfigureDependencyScanningInput._(this._$data);

  factory Input$ConfigureDependencyScanningInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ConfigureDependencyScanningInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ConfigureDependencyScanningInput<
          Input$ConfigureDependencyScanningInput>
      get copyWith => CopyWith$Input$ConfigureDependencyScanningInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConfigureDependencyScanningInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConfigureDependencyScanningInput<TRes> {
  factory CopyWith$Input$ConfigureDependencyScanningInput(
    Input$ConfigureDependencyScanningInput instance,
    TRes Function(Input$ConfigureDependencyScanningInput) then,
  ) = _CopyWithImpl$Input$ConfigureDependencyScanningInput;

  factory CopyWith$Input$ConfigureDependencyScanningInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConfigureDependencyScanningInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ConfigureDependencyScanningInput<TRes>
    implements CopyWith$Input$ConfigureDependencyScanningInput<TRes> {
  _CopyWithImpl$Input$ConfigureDependencyScanningInput(
    this._instance,
    this._then,
  );

  final Input$ConfigureDependencyScanningInput _instance;

  final TRes Function(Input$ConfigureDependencyScanningInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ConfigureDependencyScanningInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ConfigureDependencyScanningInput<TRes>
    implements CopyWith$Input$ConfigureDependencyScanningInput<TRes> {
  _CopyWithStubImpl$Input$ConfigureDependencyScanningInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ConfigureSastIacInput {
  factory Input$ConfigureSastIacInput({
    required String projectPath,
    String? clientMutationId,
  }) =>
      Input$ConfigureSastIacInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ConfigureSastIacInput._(this._$data);

  factory Input$ConfigureSastIacInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ConfigureSastIacInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ConfigureSastIacInput<Input$ConfigureSastIacInput>
      get copyWith => CopyWith$Input$ConfigureSastIacInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConfigureSastIacInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConfigureSastIacInput<TRes> {
  factory CopyWith$Input$ConfigureSastIacInput(
    Input$ConfigureSastIacInput instance,
    TRes Function(Input$ConfigureSastIacInput) then,
  ) = _CopyWithImpl$Input$ConfigureSastIacInput;

  factory CopyWith$Input$ConfigureSastIacInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConfigureSastIacInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ConfigureSastIacInput<TRes>
    implements CopyWith$Input$ConfigureSastIacInput<TRes> {
  _CopyWithImpl$Input$ConfigureSastIacInput(
    this._instance,
    this._then,
  );

  final Input$ConfigureSastIacInput _instance;

  final TRes Function(Input$ConfigureSastIacInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ConfigureSastIacInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ConfigureSastIacInput<TRes>
    implements CopyWith$Input$ConfigureSastIacInput<TRes> {
  _CopyWithStubImpl$Input$ConfigureSastIacInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ConfigureSastInput {
  factory Input$ConfigureSastInput({
    required String projectPath,
    String? clientMutationId,
    required Input$SastCiConfigurationInput configuration,
  }) =>
      Input$ConfigureSastInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'configuration': configuration,
      });

  Input$ConfigureSastInput._(this._$data);

  factory Input$ConfigureSastInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$configuration = data['configuration'];
    result$data['configuration'] = Input$SastCiConfigurationInput.fromJson(
        (l$configuration as Map<String, dynamic>));
    return Input$ConfigureSastInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Input$SastCiConfigurationInput get configuration =>
      (_$data['configuration'] as Input$SastCiConfigurationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$configuration = configuration;
    result$data['configuration'] = l$configuration.toJson();
    return result$data;
  }

  CopyWith$Input$ConfigureSastInput<Input$ConfigureSastInput> get copyWith =>
      CopyWith$Input$ConfigureSastInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConfigureSastInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$configuration = configuration;
    final lOther$configuration = other.configuration;
    if (l$configuration != lOther$configuration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    final l$configuration = configuration;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$configuration,
    ]);
  }
}

abstract class CopyWith$Input$ConfigureSastInput<TRes> {
  factory CopyWith$Input$ConfigureSastInput(
    Input$ConfigureSastInput instance,
    TRes Function(Input$ConfigureSastInput) then,
  ) = _CopyWithImpl$Input$ConfigureSastInput;

  factory CopyWith$Input$ConfigureSastInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConfigureSastInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
    Input$SastCiConfigurationInput? configuration,
  });
  CopyWith$Input$SastCiConfigurationInput<TRes> get configuration;
}

class _CopyWithImpl$Input$ConfigureSastInput<TRes>
    implements CopyWith$Input$ConfigureSastInput<TRes> {
  _CopyWithImpl$Input$ConfigureSastInput(
    this._instance,
    this._then,
  );

  final Input$ConfigureSastInput _instance;

  final TRes Function(Input$ConfigureSastInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? configuration = _undefined,
  }) =>
      _then(Input$ConfigureSastInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (configuration != _undefined && configuration != null)
          'configuration': (configuration as Input$SastCiConfigurationInput),
      }));
  CopyWith$Input$SastCiConfigurationInput<TRes> get configuration {
    final local$configuration = _instance.configuration;
    return CopyWith$Input$SastCiConfigurationInput(
        local$configuration, (e) => call(configuration: e));
  }
}

class _CopyWithStubImpl$Input$ConfigureSastInput<TRes>
    implements CopyWith$Input$ConfigureSastInput<TRes> {
  _CopyWithStubImpl$Input$ConfigureSastInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
    Input$SastCiConfigurationInput? configuration,
  }) =>
      _res;
  CopyWith$Input$SastCiConfigurationInput<TRes> get configuration =>
      CopyWith$Input$SastCiConfigurationInput.stub(_res);
}

class Input$ConfigureSecretDetectionInput {
  factory Input$ConfigureSecretDetectionInput({
    required String projectPath,
    String? clientMutationId,
  }) =>
      Input$ConfigureSecretDetectionInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ConfigureSecretDetectionInput._(this._$data);

  factory Input$ConfigureSecretDetectionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ConfigureSecretDetectionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ConfigureSecretDetectionInput<
          Input$ConfigureSecretDetectionInput>
      get copyWith => CopyWith$Input$ConfigureSecretDetectionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConfigureSecretDetectionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConfigureSecretDetectionInput<TRes> {
  factory CopyWith$Input$ConfigureSecretDetectionInput(
    Input$ConfigureSecretDetectionInput instance,
    TRes Function(Input$ConfigureSecretDetectionInput) then,
  ) = _CopyWithImpl$Input$ConfigureSecretDetectionInput;

  factory CopyWith$Input$ConfigureSecretDetectionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConfigureSecretDetectionInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ConfigureSecretDetectionInput<TRes>
    implements CopyWith$Input$ConfigureSecretDetectionInput<TRes> {
  _CopyWithImpl$Input$ConfigureSecretDetectionInput(
    this._instance,
    this._then,
  );

  final Input$ConfigureSecretDetectionInput _instance;

  final TRes Function(Input$ConfigureSecretDetectionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ConfigureSecretDetectionInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ConfigureSecretDetectionInput<TRes>
    implements CopyWith$Input$ConfigureSecretDetectionInput<TRes> {
  _CopyWithStubImpl$Input$ConfigureSecretDetectionInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CorpusCreateInput {
  factory Input$CorpusCreateInput({
    String? clientMutationId,
    required String packageId,
    required String fullPath,
  }) =>
      Input$CorpusCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'packageId': packageId,
        r'fullPath': fullPath,
      });

  Input$CorpusCreateInput._(this._$data);

  factory Input$CorpusCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$packageId = data['packageId'];
    result$data['packageId'] = (l$packageId as String);
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    return Input$CorpusCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get packageId => (_$data['packageId'] as String);
  String get fullPath => (_$data['fullPath'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$packageId = packageId;
    result$data['packageId'] = l$packageId;
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    return result$data;
  }

  CopyWith$Input$CorpusCreateInput<Input$CorpusCreateInput> get copyWith =>
      CopyWith$Input$CorpusCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CorpusCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$packageId = packageId;
    final lOther$packageId = other.packageId;
    if (l$packageId != lOther$packageId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$packageId = packageId;
    final l$fullPath = fullPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$packageId,
      l$fullPath,
    ]);
  }
}

abstract class CopyWith$Input$CorpusCreateInput<TRes> {
  factory CopyWith$Input$CorpusCreateInput(
    Input$CorpusCreateInput instance,
    TRes Function(Input$CorpusCreateInput) then,
  ) = _CopyWithImpl$Input$CorpusCreateInput;

  factory CopyWith$Input$CorpusCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CorpusCreateInput;

  TRes call({
    String? clientMutationId,
    String? packageId,
    String? fullPath,
  });
}

class _CopyWithImpl$Input$CorpusCreateInput<TRes>
    implements CopyWith$Input$CorpusCreateInput<TRes> {
  _CopyWithImpl$Input$CorpusCreateInput(
    this._instance,
    this._then,
  );

  final Input$CorpusCreateInput _instance;

  final TRes Function(Input$CorpusCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? packageId = _undefined,
    Object? fullPath = _undefined,
  }) =>
      _then(Input$CorpusCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (packageId != _undefined && packageId != null)
          'packageId': (packageId as String),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
      }));
}

class _CopyWithStubImpl$Input$CorpusCreateInput<TRes>
    implements CopyWith$Input$CorpusCreateInput<TRes> {
  _CopyWithStubImpl$Input$CorpusCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? packageId,
    String? fullPath,
  }) =>
      _res;
}

class Input$CreateAlertIssueInput {
  factory Input$CreateAlertIssueInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
  }) =>
      Input$CreateAlertIssueInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateAlertIssueInput._(this._$data);

  factory Input$CreateAlertIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateAlertIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateAlertIssueInput<Input$CreateAlertIssueInput>
      get copyWith => CopyWith$Input$CreateAlertIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateAlertIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateAlertIssueInput<TRes> {
  factory CopyWith$Input$CreateAlertIssueInput(
    Input$CreateAlertIssueInput instance,
    TRes Function(Input$CreateAlertIssueInput) then,
  ) = _CopyWithImpl$Input$CreateAlertIssueInput;

  factory CopyWith$Input$CreateAlertIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAlertIssueInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateAlertIssueInput<TRes>
    implements CopyWith$Input$CreateAlertIssueInput<TRes> {
  _CopyWithImpl$Input$CreateAlertIssueInput(
    this._instance,
    this._then,
  );

  final Input$CreateAlertIssueInput _instance;

  final TRes Function(Input$CreateAlertIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateAlertIssueInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateAlertIssueInput<TRes>
    implements CopyWith$Input$CreateAlertIssueInput<TRes> {
  _CopyWithStubImpl$Input$CreateAlertIssueInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateAnnotationInput {
  factory Input$CreateAnnotationInput({
    String? clientMutationId,
    String? environmentId,
    String? clusterId,
    required String startingAt,
    String? endingAt,
    required String dashboardPath,
    required String description,
  }) =>
      Input$CreateAnnotationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (environmentId != null) r'environmentId': environmentId,
        if (clusterId != null) r'clusterId': clusterId,
        r'startingAt': startingAt,
        if (endingAt != null) r'endingAt': endingAt,
        r'dashboardPath': dashboardPath,
        r'description': description,
      });

  Input$CreateAnnotationInput._(this._$data);

  factory Input$CreateAnnotationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('environmentId')) {
      final l$environmentId = data['environmentId'];
      result$data['environmentId'] = (l$environmentId as String?);
    }
    if (data.containsKey('clusterId')) {
      final l$clusterId = data['clusterId'];
      result$data['clusterId'] = (l$clusterId as String?);
    }
    final l$startingAt = data['startingAt'];
    result$data['startingAt'] = (l$startingAt as String);
    if (data.containsKey('endingAt')) {
      final l$endingAt = data['endingAt'];
      result$data['endingAt'] = (l$endingAt as String?);
    }
    final l$dashboardPath = data['dashboardPath'];
    result$data['dashboardPath'] = (l$dashboardPath as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    return Input$CreateAnnotationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get environmentId => (_$data['environmentId'] as String?);
  String? get clusterId => (_$data['clusterId'] as String?);
  String get startingAt => (_$data['startingAt'] as String);
  String? get endingAt => (_$data['endingAt'] as String?);
  String get dashboardPath => (_$data['dashboardPath'] as String);
  String get description => (_$data['description'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('environmentId')) {
      final l$environmentId = environmentId;
      result$data['environmentId'] = l$environmentId;
    }
    if (_$data.containsKey('clusterId')) {
      final l$clusterId = clusterId;
      result$data['clusterId'] = l$clusterId;
    }
    final l$startingAt = startingAt;
    result$data['startingAt'] = l$startingAt;
    if (_$data.containsKey('endingAt')) {
      final l$endingAt = endingAt;
      result$data['endingAt'] = l$endingAt;
    }
    final l$dashboardPath = dashboardPath;
    result$data['dashboardPath'] = l$dashboardPath;
    final l$description = description;
    result$data['description'] = l$description;
    return result$data;
  }

  CopyWith$Input$CreateAnnotationInput<Input$CreateAnnotationInput>
      get copyWith => CopyWith$Input$CreateAnnotationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateAnnotationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$environmentId = environmentId;
    final lOther$environmentId = other.environmentId;
    if (_$data.containsKey('environmentId') !=
        other._$data.containsKey('environmentId')) {
      return false;
    }
    if (l$environmentId != lOther$environmentId) {
      return false;
    }
    final l$clusterId = clusterId;
    final lOther$clusterId = other.clusterId;
    if (_$data.containsKey('clusterId') !=
        other._$data.containsKey('clusterId')) {
      return false;
    }
    if (l$clusterId != lOther$clusterId) {
      return false;
    }
    final l$startingAt = startingAt;
    final lOther$startingAt = other.startingAt;
    if (l$startingAt != lOther$startingAt) {
      return false;
    }
    final l$endingAt = endingAt;
    final lOther$endingAt = other.endingAt;
    if (_$data.containsKey('endingAt') !=
        other._$data.containsKey('endingAt')) {
      return false;
    }
    if (l$endingAt != lOther$endingAt) {
      return false;
    }
    final l$dashboardPath = dashboardPath;
    final lOther$dashboardPath = other.dashboardPath;
    if (l$dashboardPath != lOther$dashboardPath) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$environmentId = environmentId;
    final l$clusterId = clusterId;
    final l$startingAt = startingAt;
    final l$endingAt = endingAt;
    final l$dashboardPath = dashboardPath;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('environmentId') ? l$environmentId : const {},
      _$data.containsKey('clusterId') ? l$clusterId : const {},
      l$startingAt,
      _$data.containsKey('endingAt') ? l$endingAt : const {},
      l$dashboardPath,
      l$description,
    ]);
  }
}

abstract class CopyWith$Input$CreateAnnotationInput<TRes> {
  factory CopyWith$Input$CreateAnnotationInput(
    Input$CreateAnnotationInput instance,
    TRes Function(Input$CreateAnnotationInput) then,
  ) = _CopyWithImpl$Input$CreateAnnotationInput;

  factory CopyWith$Input$CreateAnnotationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAnnotationInput;

  TRes call({
    String? clientMutationId,
    String? environmentId,
    String? clusterId,
    String? startingAt,
    String? endingAt,
    String? dashboardPath,
    String? description,
  });
}

class _CopyWithImpl$Input$CreateAnnotationInput<TRes>
    implements CopyWith$Input$CreateAnnotationInput<TRes> {
  _CopyWithImpl$Input$CreateAnnotationInput(
    this._instance,
    this._then,
  );

  final Input$CreateAnnotationInput _instance;

  final TRes Function(Input$CreateAnnotationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? environmentId = _undefined,
    Object? clusterId = _undefined,
    Object? startingAt = _undefined,
    Object? endingAt = _undefined,
    Object? dashboardPath = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$CreateAnnotationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (environmentId != _undefined)
          'environmentId': (environmentId as String?),
        if (clusterId != _undefined) 'clusterId': (clusterId as String?),
        if (startingAt != _undefined && startingAt != null)
          'startingAt': (startingAt as String),
        if (endingAt != _undefined) 'endingAt': (endingAt as String?),
        if (dashboardPath != _undefined && dashboardPath != null)
          'dashboardPath': (dashboardPath as String),
        if (description != _undefined && description != null)
          'description': (description as String),
      }));
}

class _CopyWithStubImpl$Input$CreateAnnotationInput<TRes>
    implements CopyWith$Input$CreateAnnotationInput<TRes> {
  _CopyWithStubImpl$Input$CreateAnnotationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? environmentId,
    String? clusterId,
    String? startingAt,
    String? endingAt,
    String? dashboardPath,
    String? description,
  }) =>
      _res;
}

class Input$CreateBoardInput {
  factory Input$CreateBoardInput({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    String? assigneeId,
    String? milestoneId,
    String? iterationId,
    String? iterationCadenceId,
    int? weight,
    List<String>? labels,
    List<String>? labelIds,
  }) =>
      Input$CreateBoardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (projectPath != null) r'projectPath': projectPath,
        if (groupPath != null) r'groupPath': groupPath,
        if (name != null) r'name': name,
        if (hideBacklogList != null) r'hideBacklogList': hideBacklogList,
        if (hideClosedList != null) r'hideClosedList': hideClosedList,
        if (assigneeId != null) r'assigneeId': assigneeId,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (iterationId != null) r'iterationId': iterationId,
        if (iterationCadenceId != null)
          r'iterationCadenceId': iterationCadenceId,
        if (weight != null) r'weight': weight,
        if (labels != null) r'labels': labels,
        if (labelIds != null) r'labelIds': labelIds,
      });

  Input$CreateBoardInput._(this._$data);

  factory Input$CreateBoardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('projectPath')) {
      final l$projectPath = data['projectPath'];
      result$data['projectPath'] = (l$projectPath as String?);
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = data['hideBacklogList'];
      result$data['hideBacklogList'] = (l$hideBacklogList as bool?);
    }
    if (data.containsKey('hideClosedList')) {
      final l$hideClosedList = data['hideClosedList'];
      result$data['hideClosedList'] = (l$hideClosedList as bool?);
    }
    if (data.containsKey('assigneeId')) {
      final l$assigneeId = data['assigneeId'];
      result$data['assigneeId'] = (l$assigneeId as String?);
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    if (data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = data['iterationCadenceId'];
      result$data['iterationCadenceId'] = (l$iterationCadenceId as String?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as int?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$CreateBoardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get projectPath => (_$data['projectPath'] as String?);
  String? get groupPath => (_$data['groupPath'] as String?);
  String? get name => (_$data['name'] as String?);
  bool? get hideBacklogList => (_$data['hideBacklogList'] as bool?);
  bool? get hideClosedList => (_$data['hideClosedList'] as bool?);
  String? get assigneeId => (_$data['assigneeId'] as String?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  String? get iterationId => (_$data['iterationId'] as String?);
  String? get iterationCadenceId => (_$data['iterationCadenceId'] as String?);
  int? get weight => (_$data['weight'] as int?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('projectPath')) {
      final l$projectPath = projectPath;
      result$data['projectPath'] = l$projectPath;
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = hideBacklogList;
      result$data['hideBacklogList'] = l$hideBacklogList;
    }
    if (_$data.containsKey('hideClosedList')) {
      final l$hideClosedList = hideClosedList;
      result$data['hideClosedList'] = l$hideClosedList;
    }
    if (_$data.containsKey('assigneeId')) {
      final l$assigneeId = assigneeId;
      result$data['assigneeId'] = l$assigneeId;
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    if (_$data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = iterationCadenceId;
      result$data['iterationCadenceId'] = l$iterationCadenceId;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateBoardInput<Input$CreateBoardInput> get copyWith =>
      CopyWith$Input$CreateBoardInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateBoardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (_$data.containsKey('projectPath') !=
        other._$data.containsKey('projectPath')) {
      return false;
    }
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$hideBacklogList = hideBacklogList;
    final lOther$hideBacklogList = other.hideBacklogList;
    if (_$data.containsKey('hideBacklogList') !=
        other._$data.containsKey('hideBacklogList')) {
      return false;
    }
    if (l$hideBacklogList != lOther$hideBacklogList) {
      return false;
    }
    final l$hideClosedList = hideClosedList;
    final lOther$hideClosedList = other.hideClosedList;
    if (_$data.containsKey('hideClosedList') !=
        other._$data.containsKey('hideClosedList')) {
      return false;
    }
    if (l$hideClosedList != lOther$hideClosedList) {
      return false;
    }
    final l$assigneeId = assigneeId;
    final lOther$assigneeId = other.assigneeId;
    if (_$data.containsKey('assigneeId') !=
        other._$data.containsKey('assigneeId')) {
      return false;
    }
    if (l$assigneeId != lOther$assigneeId) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$iterationCadenceId = iterationCadenceId;
    final lOther$iterationCadenceId = other.iterationCadenceId;
    if (_$data.containsKey('iterationCadenceId') !=
        other._$data.containsKey('iterationCadenceId')) {
      return false;
    }
    if (l$iterationCadenceId != lOther$iterationCadenceId) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$groupPath = groupPath;
    final l$name = name;
    final l$hideBacklogList = hideBacklogList;
    final l$hideClosedList = hideClosedList;
    final l$assigneeId = assigneeId;
    final l$milestoneId = milestoneId;
    final l$iterationId = iterationId;
    final l$iterationCadenceId = iterationCadenceId;
    final l$weight = weight;
    final l$labels = labels;
    final l$labelIds = labelIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('projectPath') ? l$projectPath : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('hideBacklogList') ? l$hideBacklogList : const {},
      _$data.containsKey('hideClosedList') ? l$hideClosedList : const {},
      _$data.containsKey('assigneeId') ? l$assigneeId : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
      _$data.containsKey('iterationCadenceId')
          ? l$iterationCadenceId
          : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateBoardInput<TRes> {
  factory CopyWith$Input$CreateBoardInput(
    Input$CreateBoardInput instance,
    TRes Function(Input$CreateBoardInput) then,
  ) = _CopyWithImpl$Input$CreateBoardInput;

  factory CopyWith$Input$CreateBoardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateBoardInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    String? assigneeId,
    String? milestoneId,
    String? iterationId,
    String? iterationCadenceId,
    int? weight,
    List<String>? labels,
    List<String>? labelIds,
  });
}

class _CopyWithImpl$Input$CreateBoardInput<TRes>
    implements CopyWith$Input$CreateBoardInput<TRes> {
  _CopyWithImpl$Input$CreateBoardInput(
    this._instance,
    this._then,
  );

  final Input$CreateBoardInput _instance;

  final TRes Function(Input$CreateBoardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? groupPath = _undefined,
    Object? name = _undefined,
    Object? hideBacklogList = _undefined,
    Object? hideClosedList = _undefined,
    Object? assigneeId = _undefined,
    Object? milestoneId = _undefined,
    Object? iterationId = _undefined,
    Object? iterationCadenceId = _undefined,
    Object? weight = _undefined,
    Object? labels = _undefined,
    Object? labelIds = _undefined,
  }) =>
      _then(Input$CreateBoardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined) 'projectPath': (projectPath as String?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
        if (name != _undefined) 'name': (name as String?),
        if (hideBacklogList != _undefined)
          'hideBacklogList': (hideBacklogList as bool?),
        if (hideClosedList != _undefined)
          'hideClosedList': (hideClosedList as bool?),
        if (assigneeId != _undefined) 'assigneeId': (assigneeId as String?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
        if (iterationCadenceId != _undefined)
          'iterationCadenceId': (iterationCadenceId as String?),
        if (weight != _undefined) 'weight': (weight as int?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$CreateBoardInput<TRes>
    implements CopyWith$Input$CreateBoardInput<TRes> {
  _CopyWithStubImpl$Input$CreateBoardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    String? assigneeId,
    String? milestoneId,
    String? iterationId,
    String? iterationCadenceId,
    int? weight,
    List<String>? labels,
    List<String>? labelIds,
  }) =>
      _res;
}

class Input$CreateBranchInput {
  factory Input$CreateBranchInput({
    String? clientMutationId,
    required String projectPath,
    required String name,
    required String ref,
  }) =>
      Input$CreateBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'name': name,
        r'ref': ref,
      });

  Input$CreateBranchInput._(this._$data);

  factory Input$CreateBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ref = data['ref'];
    result$data['ref'] = (l$ref as String);
    return Input$CreateBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get name => (_$data['name'] as String);
  String get ref => (_$data['ref'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$name = name;
    result$data['name'] = l$name;
    final l$ref = ref;
    result$data['ref'] = l$ref;
    return result$data;
  }

  CopyWith$Input$CreateBranchInput<Input$CreateBranchInput> get copyWith =>
      CopyWith$Input$CreateBranchInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ref = ref;
    final lOther$ref = other.ref;
    if (l$ref != lOther$ref) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$name = name;
    final l$ref = ref;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$name,
      l$ref,
    ]);
  }
}

abstract class CopyWith$Input$CreateBranchInput<TRes> {
  factory CopyWith$Input$CreateBranchInput(
    Input$CreateBranchInput instance,
    TRes Function(Input$CreateBranchInput) then,
  ) = _CopyWithImpl$Input$CreateBranchInput;

  factory CopyWith$Input$CreateBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateBranchInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    String? ref,
  });
}

class _CopyWithImpl$Input$CreateBranchInput<TRes>
    implements CopyWith$Input$CreateBranchInput<TRes> {
  _CopyWithImpl$Input$CreateBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateBranchInput _instance;

  final TRes Function(Input$CreateBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? name = _undefined,
    Object? ref = _undefined,
  }) =>
      _then(Input$CreateBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ref != _undefined && ref != null) 'ref': (ref as String),
      }));
}

class _CopyWithStubImpl$Input$CreateBranchInput<TRes>
    implements CopyWith$Input$CreateBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    String? ref,
  }) =>
      _res;
}

class Input$CreateClusterAgentInput {
  factory Input$CreateClusterAgentInput({
    String? clientMutationId,
    required String projectPath,
    required String name,
  }) =>
      Input$CreateClusterAgentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'name': name,
      });

  Input$CreateClusterAgentInput._(this._$data);

  factory Input$CreateClusterAgentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$CreateClusterAgentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$CreateClusterAgentInput<Input$CreateClusterAgentInput>
      get copyWith => CopyWith$Input$CreateClusterAgentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateClusterAgentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$CreateClusterAgentInput<TRes> {
  factory CopyWith$Input$CreateClusterAgentInput(
    Input$CreateClusterAgentInput instance,
    TRes Function(Input$CreateClusterAgentInput) then,
  ) = _CopyWithImpl$Input$CreateClusterAgentInput;

  factory CopyWith$Input$CreateClusterAgentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateClusterAgentInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? name,
  });
}

class _CopyWithImpl$Input$CreateClusterAgentInput<TRes>
    implements CopyWith$Input$CreateClusterAgentInput<TRes> {
  _CopyWithImpl$Input$CreateClusterAgentInput(
    this._instance,
    this._then,
  );

  final Input$CreateClusterAgentInput _instance;

  final TRes Function(Input$CreateClusterAgentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CreateClusterAgentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$CreateClusterAgentInput<TRes>
    implements CopyWith$Input$CreateClusterAgentInput<TRes> {
  _CopyWithStubImpl$Input$CreateClusterAgentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? name,
  }) =>
      _res;
}

class Input$CreateComplianceFrameworkInput {
  factory Input$CreateComplianceFrameworkInput({
    String? clientMutationId,
    required String namespacePath,
    required Input$ComplianceFrameworkInput params,
  }) =>
      Input$CreateComplianceFrameworkInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'namespacePath': namespacePath,
        r'params': params,
      });

  Input$CreateComplianceFrameworkInput._(this._$data);

  factory Input$CreateComplianceFrameworkInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$namespacePath = data['namespacePath'];
    result$data['namespacePath'] = (l$namespacePath as String);
    final l$params = data['params'];
    result$data['params'] = Input$ComplianceFrameworkInput.fromJson(
        (l$params as Map<String, dynamic>));
    return Input$CreateComplianceFrameworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get namespacePath => (_$data['namespacePath'] as String);
  Input$ComplianceFrameworkInput get params =>
      (_$data['params'] as Input$ComplianceFrameworkInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$namespacePath = namespacePath;
    result$data['namespacePath'] = l$namespacePath;
    final l$params = params;
    result$data['params'] = l$params.toJson();
    return result$data;
  }

  CopyWith$Input$CreateComplianceFrameworkInput<
          Input$CreateComplianceFrameworkInput>
      get copyWith => CopyWith$Input$CreateComplianceFrameworkInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateComplianceFrameworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$namespacePath = namespacePath;
    final lOther$namespacePath = other.namespacePath;
    if (l$namespacePath != lOther$namespacePath) {
      return false;
    }
    final l$params = params;
    final lOther$params = other.params;
    if (l$params != lOther$params) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$namespacePath = namespacePath;
    final l$params = params;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$namespacePath,
      l$params,
    ]);
  }
}

abstract class CopyWith$Input$CreateComplianceFrameworkInput<TRes> {
  factory CopyWith$Input$CreateComplianceFrameworkInput(
    Input$CreateComplianceFrameworkInput instance,
    TRes Function(Input$CreateComplianceFrameworkInput) then,
  ) = _CopyWithImpl$Input$CreateComplianceFrameworkInput;

  factory CopyWith$Input$CreateComplianceFrameworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateComplianceFrameworkInput;

  TRes call({
    String? clientMutationId,
    String? namespacePath,
    Input$ComplianceFrameworkInput? params,
  });
  CopyWith$Input$ComplianceFrameworkInput<TRes> get params;
}

class _CopyWithImpl$Input$CreateComplianceFrameworkInput<TRes>
    implements CopyWith$Input$CreateComplianceFrameworkInput<TRes> {
  _CopyWithImpl$Input$CreateComplianceFrameworkInput(
    this._instance,
    this._then,
  );

  final Input$CreateComplianceFrameworkInput _instance;

  final TRes Function(Input$CreateComplianceFrameworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? namespacePath = _undefined,
    Object? params = _undefined,
  }) =>
      _then(Input$CreateComplianceFrameworkInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (namespacePath != _undefined && namespacePath != null)
          'namespacePath': (namespacePath as String),
        if (params != _undefined && params != null)
          'params': (params as Input$ComplianceFrameworkInput),
      }));
  CopyWith$Input$ComplianceFrameworkInput<TRes> get params {
    final local$params = _instance.params;
    return CopyWith$Input$ComplianceFrameworkInput(
        local$params, (e) => call(params: e));
  }
}

class _CopyWithStubImpl$Input$CreateComplianceFrameworkInput<TRes>
    implements CopyWith$Input$CreateComplianceFrameworkInput<TRes> {
  _CopyWithStubImpl$Input$CreateComplianceFrameworkInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? namespacePath,
    Input$ComplianceFrameworkInput? params,
  }) =>
      _res;
  CopyWith$Input$ComplianceFrameworkInput<TRes> get params =>
      CopyWith$Input$ComplianceFrameworkInput.stub(_res);
}

class Input$CreateCustomEmojiInput {
  factory Input$CreateCustomEmojiInput({
    String? clientMutationId,
    required String groupPath,
    required String name,
    required String url,
  }) =>
      Input$CreateCustomEmojiInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        r'name': name,
        r'url': url,
      });

  Input$CreateCustomEmojiInput._(this._$data);

  factory Input$CreateCustomEmojiInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    return Input$CreateCustomEmojiInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  String get name => (_$data['name'] as String);
  String get url => (_$data['url'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    final l$name = name;
    result$data['name'] = l$name;
    final l$url = url;
    result$data['url'] = l$url;
    return result$data;
  }

  CopyWith$Input$CreateCustomEmojiInput<Input$CreateCustomEmojiInput>
      get copyWith => CopyWith$Input$CreateCustomEmojiInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCustomEmojiInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$name = name;
    final l$url = url;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      l$name,
      l$url,
    ]);
  }
}

abstract class CopyWith$Input$CreateCustomEmojiInput<TRes> {
  factory CopyWith$Input$CreateCustomEmojiInput(
    Input$CreateCustomEmojiInput instance,
    TRes Function(Input$CreateCustomEmojiInput) then,
  ) = _CopyWithImpl$Input$CreateCustomEmojiInput;

  factory CopyWith$Input$CreateCustomEmojiInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCustomEmojiInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    String? name,
    String? url,
  });
}

class _CopyWithImpl$Input$CreateCustomEmojiInput<TRes>
    implements CopyWith$Input$CreateCustomEmojiInput<TRes> {
  _CopyWithImpl$Input$CreateCustomEmojiInput(
    this._instance,
    this._then,
  );

  final Input$CreateCustomEmojiInput _instance;

  final TRes Function(Input$CreateCustomEmojiInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? name = _undefined,
    Object? url = _undefined,
  }) =>
      _then(Input$CreateCustomEmojiInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined && url != null) 'url': (url as String),
      }));
}

class _CopyWithStubImpl$Input$CreateCustomEmojiInput<TRes>
    implements CopyWith$Input$CreateCustomEmojiInput<TRes> {
  _CopyWithStubImpl$Input$CreateCustomEmojiInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    String? name,
    String? url,
  }) =>
      _res;
}

class Input$CreateDiffNoteInput {
  factory Input$CreateDiffNoteInput({
    required String noteableId,
    required String body,
    bool? internal,
    String? clientMutationId,
    required Input$DiffPositionInput position,
  }) =>
      Input$CreateDiffNoteInput._({
        r'noteableId': noteableId,
        r'body': body,
        if (internal != null) r'internal': internal,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'position': position,
      });

  Input$CreateDiffNoteInput._(this._$data);

  factory Input$CreateDiffNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$noteableId = data['noteableId'];
    result$data['noteableId'] = (l$noteableId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('internal')) {
      final l$internal = data['internal'];
      result$data['internal'] = (l$internal as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$position = data['position'];
    result$data['position'] =
        Input$DiffPositionInput.fromJson((l$position as Map<String, dynamic>));
    return Input$CreateDiffNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get noteableId => (_$data['noteableId'] as String);
  String get body => (_$data['body'] as String);
  bool? get internal => (_$data['internal'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Input$DiffPositionInput get position =>
      (_$data['position'] as Input$DiffPositionInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$noteableId = noteableId;
    result$data['noteableId'] = l$noteableId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('internal')) {
      final l$internal = internal;
      result$data['internal'] = l$internal;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$position = position;
    result$data['position'] = l$position.toJson();
    return result$data;
  }

  CopyWith$Input$CreateDiffNoteInput<Input$CreateDiffNoteInput> get copyWith =>
      CopyWith$Input$CreateDiffNoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateDiffNoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$noteableId = noteableId;
    final lOther$noteableId = other.noteableId;
    if (l$noteableId != lOther$noteableId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$internal = internal;
    final lOther$internal = other.internal;
    if (_$data.containsKey('internal') !=
        other._$data.containsKey('internal')) {
      return false;
    }
    if (l$internal != lOther$internal) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$noteableId = noteableId;
    final l$body = body;
    final l$internal = internal;
    final l$clientMutationId = clientMutationId;
    final l$position = position;
    return Object.hashAll([
      l$noteableId,
      l$body,
      _$data.containsKey('internal') ? l$internal : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$position,
    ]);
  }
}

abstract class CopyWith$Input$CreateDiffNoteInput<TRes> {
  factory CopyWith$Input$CreateDiffNoteInput(
    Input$CreateDiffNoteInput instance,
    TRes Function(Input$CreateDiffNoteInput) then,
  ) = _CopyWithImpl$Input$CreateDiffNoteInput;

  factory CopyWith$Input$CreateDiffNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDiffNoteInput;

  TRes call({
    String? noteableId,
    String? body,
    bool? internal,
    String? clientMutationId,
    Input$DiffPositionInput? position,
  });
  CopyWith$Input$DiffPositionInput<TRes> get position;
}

class _CopyWithImpl$Input$CreateDiffNoteInput<TRes>
    implements CopyWith$Input$CreateDiffNoteInput<TRes> {
  _CopyWithImpl$Input$CreateDiffNoteInput(
    this._instance,
    this._then,
  );

  final Input$CreateDiffNoteInput _instance;

  final TRes Function(Input$CreateDiffNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? noteableId = _undefined,
    Object? body = _undefined,
    Object? internal = _undefined,
    Object? clientMutationId = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$CreateDiffNoteInput._({
        ..._instance._$data,
        if (noteableId != _undefined && noteableId != null)
          'noteableId': (noteableId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (internal != _undefined) 'internal': (internal as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (position != _undefined && position != null)
          'position': (position as Input$DiffPositionInput),
      }));
  CopyWith$Input$DiffPositionInput<TRes> get position {
    final local$position = _instance.position;
    return CopyWith$Input$DiffPositionInput(
        local$position, (e) => call(position: e));
  }
}

class _CopyWithStubImpl$Input$CreateDiffNoteInput<TRes>
    implements CopyWith$Input$CreateDiffNoteInput<TRes> {
  _CopyWithStubImpl$Input$CreateDiffNoteInput(this._res);

  TRes _res;

  call({
    String? noteableId,
    String? body,
    bool? internal,
    String? clientMutationId,
    Input$DiffPositionInput? position,
  }) =>
      _res;
  CopyWith$Input$DiffPositionInput<TRes> get position =>
      CopyWith$Input$DiffPositionInput.stub(_res);
}

class Input$CreateEpicInput {
  factory Input$CreateEpicInput({
    String? clientMutationId,
    required String groupPath,
    String? title,
    String? description,
    bool? confidential,
    String? startDateFixed,
    String? dueDateFixed,
    bool? startDateIsFixed,
    bool? dueDateIsFixed,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? addLabels,
    String? color,
  }) =>
      Input$CreateEpicInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (confidential != null) r'confidential': confidential,
        if (startDateFixed != null) r'startDateFixed': startDateFixed,
        if (dueDateFixed != null) r'dueDateFixed': dueDateFixed,
        if (startDateIsFixed != null) r'startDateIsFixed': startDateIsFixed,
        if (dueDateIsFixed != null) r'dueDateIsFixed': dueDateIsFixed,
        if (addLabelIds != null) r'addLabelIds': addLabelIds,
        if (removeLabelIds != null) r'removeLabelIds': removeLabelIds,
        if (addLabels != null) r'addLabels': addLabels,
        if (color != null) r'color': color,
      });

  Input$CreateEpicInput._(this._$data);

  factory Input$CreateEpicInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('startDateFixed')) {
      final l$startDateFixed = data['startDateFixed'];
      result$data['startDateFixed'] = (l$startDateFixed as String?);
    }
    if (data.containsKey('dueDateFixed')) {
      final l$dueDateFixed = data['dueDateFixed'];
      result$data['dueDateFixed'] = (l$dueDateFixed as String?);
    }
    if (data.containsKey('startDateIsFixed')) {
      final l$startDateIsFixed = data['startDateIsFixed'];
      result$data['startDateIsFixed'] = (l$startDateIsFixed as bool?);
    }
    if (data.containsKey('dueDateIsFixed')) {
      final l$dueDateIsFixed = data['dueDateIsFixed'];
      result$data['dueDateIsFixed'] = (l$dueDateIsFixed as bool?);
    }
    if (data.containsKey('addLabelIds')) {
      final l$addLabelIds = data['addLabelIds'];
      result$data['addLabelIds'] =
          (l$addLabelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeLabelIds')) {
      final l$removeLabelIds = data['removeLabelIds'];
      result$data['removeLabelIds'] = (l$removeLabelIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addLabels')) {
      final l$addLabels = data['addLabels'];
      result$data['addLabels'] =
          (l$addLabels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = (l$color as String?);
    }
    return Input$CreateEpicInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  String? get startDateFixed => (_$data['startDateFixed'] as String?);
  String? get dueDateFixed => (_$data['dueDateFixed'] as String?);
  bool? get startDateIsFixed => (_$data['startDateIsFixed'] as bool?);
  bool? get dueDateIsFixed => (_$data['dueDateIsFixed'] as bool?);
  List<String>? get addLabelIds => (_$data['addLabelIds'] as List<String>?);
  List<String>? get removeLabelIds =>
      (_$data['removeLabelIds'] as List<String>?);
  List<String>? get addLabels => (_$data['addLabels'] as List<String>?);
  String? get color => (_$data['color'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('startDateFixed')) {
      final l$startDateFixed = startDateFixed;
      result$data['startDateFixed'] = l$startDateFixed;
    }
    if (_$data.containsKey('dueDateFixed')) {
      final l$dueDateFixed = dueDateFixed;
      result$data['dueDateFixed'] = l$dueDateFixed;
    }
    if (_$data.containsKey('startDateIsFixed')) {
      final l$startDateIsFixed = startDateIsFixed;
      result$data['startDateIsFixed'] = l$startDateIsFixed;
    }
    if (_$data.containsKey('dueDateIsFixed')) {
      final l$dueDateIsFixed = dueDateIsFixed;
      result$data['dueDateIsFixed'] = l$dueDateIsFixed;
    }
    if (_$data.containsKey('addLabelIds')) {
      final l$addLabelIds = addLabelIds;
      result$data['addLabelIds'] = l$addLabelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeLabelIds')) {
      final l$removeLabelIds = removeLabelIds;
      result$data['removeLabelIds'] = l$removeLabelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('addLabels')) {
      final l$addLabels = addLabels;
      result$data['addLabels'] = l$addLabels?.map((e) => e).toList();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color;
    }
    return result$data;
  }

  CopyWith$Input$CreateEpicInput<Input$CreateEpicInput> get copyWith =>
      CopyWith$Input$CreateEpicInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEpicInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$startDateFixed = startDateFixed;
    final lOther$startDateFixed = other.startDateFixed;
    if (_$data.containsKey('startDateFixed') !=
        other._$data.containsKey('startDateFixed')) {
      return false;
    }
    if (l$startDateFixed != lOther$startDateFixed) {
      return false;
    }
    final l$dueDateFixed = dueDateFixed;
    final lOther$dueDateFixed = other.dueDateFixed;
    if (_$data.containsKey('dueDateFixed') !=
        other._$data.containsKey('dueDateFixed')) {
      return false;
    }
    if (l$dueDateFixed != lOther$dueDateFixed) {
      return false;
    }
    final l$startDateIsFixed = startDateIsFixed;
    final lOther$startDateIsFixed = other.startDateIsFixed;
    if (_$data.containsKey('startDateIsFixed') !=
        other._$data.containsKey('startDateIsFixed')) {
      return false;
    }
    if (l$startDateIsFixed != lOther$startDateIsFixed) {
      return false;
    }
    final l$dueDateIsFixed = dueDateIsFixed;
    final lOther$dueDateIsFixed = other.dueDateIsFixed;
    if (_$data.containsKey('dueDateIsFixed') !=
        other._$data.containsKey('dueDateIsFixed')) {
      return false;
    }
    if (l$dueDateIsFixed != lOther$dueDateIsFixed) {
      return false;
    }
    final l$addLabelIds = addLabelIds;
    final lOther$addLabelIds = other.addLabelIds;
    if (_$data.containsKey('addLabelIds') !=
        other._$data.containsKey('addLabelIds')) {
      return false;
    }
    if (l$addLabelIds != null && lOther$addLabelIds != null) {
      if (l$addLabelIds.length != lOther$addLabelIds.length) {
        return false;
      }
      for (int i = 0; i < l$addLabelIds.length; i++) {
        final l$addLabelIds$entry = l$addLabelIds[i];
        final lOther$addLabelIds$entry = lOther$addLabelIds[i];
        if (l$addLabelIds$entry != lOther$addLabelIds$entry) {
          return false;
        }
      }
    } else if (l$addLabelIds != lOther$addLabelIds) {
      return false;
    }
    final l$removeLabelIds = removeLabelIds;
    final lOther$removeLabelIds = other.removeLabelIds;
    if (_$data.containsKey('removeLabelIds') !=
        other._$data.containsKey('removeLabelIds')) {
      return false;
    }
    if (l$removeLabelIds != null && lOther$removeLabelIds != null) {
      if (l$removeLabelIds.length != lOther$removeLabelIds.length) {
        return false;
      }
      for (int i = 0; i < l$removeLabelIds.length; i++) {
        final l$removeLabelIds$entry = l$removeLabelIds[i];
        final lOther$removeLabelIds$entry = lOther$removeLabelIds[i];
        if (l$removeLabelIds$entry != lOther$removeLabelIds$entry) {
          return false;
        }
      }
    } else if (l$removeLabelIds != lOther$removeLabelIds) {
      return false;
    }
    final l$addLabels = addLabels;
    final lOther$addLabels = other.addLabels;
    if (_$data.containsKey('addLabels') !=
        other._$data.containsKey('addLabels')) {
      return false;
    }
    if (l$addLabels != null && lOther$addLabels != null) {
      if (l$addLabels.length != lOther$addLabels.length) {
        return false;
      }
      for (int i = 0; i < l$addLabels.length; i++) {
        final l$addLabels$entry = l$addLabels[i];
        final lOther$addLabels$entry = lOther$addLabels[i];
        if (l$addLabels$entry != lOther$addLabels$entry) {
          return false;
        }
      }
    } else if (l$addLabels != lOther$addLabels) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$title = title;
    final l$description = description;
    final l$confidential = confidential;
    final l$startDateFixed = startDateFixed;
    final l$dueDateFixed = dueDateFixed;
    final l$startDateIsFixed = startDateIsFixed;
    final l$dueDateIsFixed = dueDateIsFixed;
    final l$addLabelIds = addLabelIds;
    final l$removeLabelIds = removeLabelIds;
    final l$addLabels = addLabels;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('startDateFixed') ? l$startDateFixed : const {},
      _$data.containsKey('dueDateFixed') ? l$dueDateFixed : const {},
      _$data.containsKey('startDateIsFixed') ? l$startDateIsFixed : const {},
      _$data.containsKey('dueDateIsFixed') ? l$dueDateIsFixed : const {},
      _$data.containsKey('addLabelIds')
          ? l$addLabelIds == null
              ? null
              : Object.hashAll(l$addLabelIds.map((v) => v))
          : const {},
      _$data.containsKey('removeLabelIds')
          ? l$removeLabelIds == null
              ? null
              : Object.hashAll(l$removeLabelIds.map((v) => v))
          : const {},
      _$data.containsKey('addLabels')
          ? l$addLabels == null
              ? null
              : Object.hashAll(l$addLabels.map((v) => v))
          : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateEpicInput<TRes> {
  factory CopyWith$Input$CreateEpicInput(
    Input$CreateEpicInput instance,
    TRes Function(Input$CreateEpicInput) then,
  ) = _CopyWithImpl$Input$CreateEpicInput;

  factory CopyWith$Input$CreateEpicInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEpicInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    String? title,
    String? description,
    bool? confidential,
    String? startDateFixed,
    String? dueDateFixed,
    bool? startDateIsFixed,
    bool? dueDateIsFixed,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? addLabels,
    String? color,
  });
}

class _CopyWithImpl$Input$CreateEpicInput<TRes>
    implements CopyWith$Input$CreateEpicInput<TRes> {
  _CopyWithImpl$Input$CreateEpicInput(
    this._instance,
    this._then,
  );

  final Input$CreateEpicInput _instance;

  final TRes Function(Input$CreateEpicInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? confidential = _undefined,
    Object? startDateFixed = _undefined,
    Object? dueDateFixed = _undefined,
    Object? startDateIsFixed = _undefined,
    Object? dueDateIsFixed = _undefined,
    Object? addLabelIds = _undefined,
    Object? removeLabelIds = _undefined,
    Object? addLabels = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$CreateEpicInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (startDateFixed != _undefined)
          'startDateFixed': (startDateFixed as String?),
        if (dueDateFixed != _undefined)
          'dueDateFixed': (dueDateFixed as String?),
        if (startDateIsFixed != _undefined)
          'startDateIsFixed': (startDateIsFixed as bool?),
        if (dueDateIsFixed != _undefined)
          'dueDateIsFixed': (dueDateIsFixed as bool?),
        if (addLabelIds != _undefined)
          'addLabelIds': (addLabelIds as List<String>?),
        if (removeLabelIds != _undefined)
          'removeLabelIds': (removeLabelIds as List<String>?),
        if (addLabels != _undefined) 'addLabels': (addLabels as List<String>?),
        if (color != _undefined) 'color': (color as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateEpicInput<TRes>
    implements CopyWith$Input$CreateEpicInput<TRes> {
  _CopyWithStubImpl$Input$CreateEpicInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    String? title,
    String? description,
    bool? confidential,
    String? startDateFixed,
    String? dueDateFixed,
    bool? startDateIsFixed,
    bool? dueDateIsFixed,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? addLabels,
    String? color,
  }) =>
      _res;
}

class Input$CreateImageDiffNoteInput {
  factory Input$CreateImageDiffNoteInput({
    required String noteableId,
    required String body,
    bool? internal,
    String? clientMutationId,
    required Input$DiffImagePositionInput position,
  }) =>
      Input$CreateImageDiffNoteInput._({
        r'noteableId': noteableId,
        r'body': body,
        if (internal != null) r'internal': internal,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'position': position,
      });

  Input$CreateImageDiffNoteInput._(this._$data);

  factory Input$CreateImageDiffNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$noteableId = data['noteableId'];
    result$data['noteableId'] = (l$noteableId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('internal')) {
      final l$internal = data['internal'];
      result$data['internal'] = (l$internal as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$position = data['position'];
    result$data['position'] = Input$DiffImagePositionInput.fromJson(
        (l$position as Map<String, dynamic>));
    return Input$CreateImageDiffNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get noteableId => (_$data['noteableId'] as String);
  String get body => (_$data['body'] as String);
  bool? get internal => (_$data['internal'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Input$DiffImagePositionInput get position =>
      (_$data['position'] as Input$DiffImagePositionInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$noteableId = noteableId;
    result$data['noteableId'] = l$noteableId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('internal')) {
      final l$internal = internal;
      result$data['internal'] = l$internal;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$position = position;
    result$data['position'] = l$position.toJson();
    return result$data;
  }

  CopyWith$Input$CreateImageDiffNoteInput<Input$CreateImageDiffNoteInput>
      get copyWith => CopyWith$Input$CreateImageDiffNoteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateImageDiffNoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$noteableId = noteableId;
    final lOther$noteableId = other.noteableId;
    if (l$noteableId != lOther$noteableId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$internal = internal;
    final lOther$internal = other.internal;
    if (_$data.containsKey('internal') !=
        other._$data.containsKey('internal')) {
      return false;
    }
    if (l$internal != lOther$internal) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$noteableId = noteableId;
    final l$body = body;
    final l$internal = internal;
    final l$clientMutationId = clientMutationId;
    final l$position = position;
    return Object.hashAll([
      l$noteableId,
      l$body,
      _$data.containsKey('internal') ? l$internal : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$position,
    ]);
  }
}

abstract class CopyWith$Input$CreateImageDiffNoteInput<TRes> {
  factory CopyWith$Input$CreateImageDiffNoteInput(
    Input$CreateImageDiffNoteInput instance,
    TRes Function(Input$CreateImageDiffNoteInput) then,
  ) = _CopyWithImpl$Input$CreateImageDiffNoteInput;

  factory CopyWith$Input$CreateImageDiffNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateImageDiffNoteInput;

  TRes call({
    String? noteableId,
    String? body,
    bool? internal,
    String? clientMutationId,
    Input$DiffImagePositionInput? position,
  });
  CopyWith$Input$DiffImagePositionInput<TRes> get position;
}

class _CopyWithImpl$Input$CreateImageDiffNoteInput<TRes>
    implements CopyWith$Input$CreateImageDiffNoteInput<TRes> {
  _CopyWithImpl$Input$CreateImageDiffNoteInput(
    this._instance,
    this._then,
  );

  final Input$CreateImageDiffNoteInput _instance;

  final TRes Function(Input$CreateImageDiffNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? noteableId = _undefined,
    Object? body = _undefined,
    Object? internal = _undefined,
    Object? clientMutationId = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$CreateImageDiffNoteInput._({
        ..._instance._$data,
        if (noteableId != _undefined && noteableId != null)
          'noteableId': (noteableId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (internal != _undefined) 'internal': (internal as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (position != _undefined && position != null)
          'position': (position as Input$DiffImagePositionInput),
      }));
  CopyWith$Input$DiffImagePositionInput<TRes> get position {
    final local$position = _instance.position;
    return CopyWith$Input$DiffImagePositionInput(
        local$position, (e) => call(position: e));
  }
}

class _CopyWithStubImpl$Input$CreateImageDiffNoteInput<TRes>
    implements CopyWith$Input$CreateImageDiffNoteInput<TRes> {
  _CopyWithStubImpl$Input$CreateImageDiffNoteInput(this._res);

  TRes _res;

  call({
    String? noteableId,
    String? body,
    bool? internal,
    String? clientMutationId,
    Input$DiffImagePositionInput? position,
  }) =>
      _res;
  CopyWith$Input$DiffImagePositionInput<TRes> get position =>
      CopyWith$Input$DiffImagePositionInput.stub(_res);
}

class Input$CreateIssueInput {
  factory Input$CreateIssueInput({
    String? clientMutationId,
    String? description,
    String? dueDate,
    bool? confidential,
    bool? locked,
    Enum$IssueType? type,
    required String projectPath,
    int? iid,
    required String title,
    String? milestoneId,
    List<String>? labels,
    List<String>? labelIds,
    String? createdAt,
    String? mergeRequestToResolveDiscussionsOf,
    String? discussionToResolve,
    List<String>? assigneeIds,
    String? moveBeforeId,
    String? moveAfterId,
    Enum$HealthStatus? healthStatus,
    int? weight,
    String? epicId,
    String? iterationId,
    Enum$IssueCreationIterationWildcardId? iterationWildcardId,
    String? iterationCadenceId,
  }) =>
      Input$CreateIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        if (dueDate != null) r'dueDate': dueDate,
        if (confidential != null) r'confidential': confidential,
        if (locked != null) r'locked': locked,
        if (type != null) r'type': type,
        r'projectPath': projectPath,
        if (iid != null) r'iid': iid,
        r'title': title,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labels != null) r'labels': labels,
        if (labelIds != null) r'labelIds': labelIds,
        if (createdAt != null) r'createdAt': createdAt,
        if (mergeRequestToResolveDiscussionsOf != null)
          r'mergeRequestToResolveDiscussionsOf':
              mergeRequestToResolveDiscussionsOf,
        if (discussionToResolve != null)
          r'discussionToResolve': discussionToResolve,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (moveBeforeId != null) r'moveBeforeId': moveBeforeId,
        if (moveAfterId != null) r'moveAfterId': moveAfterId,
        if (healthStatus != null) r'healthStatus': healthStatus,
        if (weight != null) r'weight': weight,
        if (epicId != null) r'epicId': epicId,
        if (iterationId != null) r'iterationId': iterationId,
        if (iterationWildcardId != null)
          r'iterationWildcardId': iterationWildcardId,
        if (iterationCadenceId != null)
          r'iterationCadenceId': iterationCadenceId,
      });

  Input$CreateIssueInput._(this._$data);

  factory Input$CreateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('locked')) {
      final l$locked = data['locked'];
      result$data['locked'] = (l$locked as bool?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          l$type == null ? null : fromJson$Enum$IssueType((l$type as String));
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('iid')) {
      final l$iid = data['iid'];
      result$data['iid'] = (l$iid as int?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('mergeRequestToResolveDiscussionsOf')) {
      final l$mergeRequestToResolveDiscussionsOf =
          data['mergeRequestToResolveDiscussionsOf'];
      result$data['mergeRequestToResolveDiscussionsOf'] =
          (l$mergeRequestToResolveDiscussionsOf as String?);
    }
    if (data.containsKey('discussionToResolve')) {
      final l$discussionToResolve = data['discussionToResolve'];
      result$data['discussionToResolve'] = (l$discussionToResolve as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('moveBeforeId')) {
      final l$moveBeforeId = data['moveBeforeId'];
      result$data['moveBeforeId'] = (l$moveBeforeId as String?);
    }
    if (data.containsKey('moveAfterId')) {
      final l$moveAfterId = data['moveAfterId'];
      result$data['moveAfterId'] = (l$moveAfterId as String?);
    }
    if (data.containsKey('healthStatus')) {
      final l$healthStatus = data['healthStatus'];
      result$data['healthStatus'] = l$healthStatus == null
          ? null
          : fromJson$Enum$HealthStatus((l$healthStatus as String));
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as int?);
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    if (data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = data['iterationWildcardId'];
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : fromJson$Enum$IssueCreationIterationWildcardId(
              (l$iterationWildcardId as String));
    }
    if (data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = data['iterationCadenceId'];
      result$data['iterationCadenceId'] = (l$iterationCadenceId as String?);
    }
    return Input$CreateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get dueDate => (_$data['dueDate'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  bool? get locked => (_$data['locked'] as bool?);
  Enum$IssueType? get type => (_$data['type'] as Enum$IssueType?);
  String get projectPath => (_$data['projectPath'] as String);
  int? get iid => (_$data['iid'] as int?);
  String get title => (_$data['title'] as String);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get mergeRequestToResolveDiscussionsOf =>
      (_$data['mergeRequestToResolveDiscussionsOf'] as String?);
  String? get discussionToResolve => (_$data['discussionToResolve'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get moveBeforeId => (_$data['moveBeforeId'] as String?);
  String? get moveAfterId => (_$data['moveAfterId'] as String?);
  Enum$HealthStatus? get healthStatus =>
      (_$data['healthStatus'] as Enum$HealthStatus?);
  int? get weight => (_$data['weight'] as int?);
  String? get epicId => (_$data['epicId'] as String?);
  String? get iterationId => (_$data['iterationId'] as String?);
  Enum$IssueCreationIterationWildcardId? get iterationWildcardId =>
      (_$data['iterationWildcardId'] as Enum$IssueCreationIterationWildcardId?);
  String? get iterationCadenceId => (_$data['iterationCadenceId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('locked')) {
      final l$locked = locked;
      result$data['locked'] = l$locked;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$IssueType(l$type);
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('iid')) {
      final l$iid = iid;
      result$data['iid'] = l$iid;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('mergeRequestToResolveDiscussionsOf')) {
      final l$mergeRequestToResolveDiscussionsOf =
          mergeRequestToResolveDiscussionsOf;
      result$data['mergeRequestToResolveDiscussionsOf'] =
          l$mergeRequestToResolveDiscussionsOf;
    }
    if (_$data.containsKey('discussionToResolve')) {
      final l$discussionToResolve = discussionToResolve;
      result$data['discussionToResolve'] = l$discussionToResolve;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('moveBeforeId')) {
      final l$moveBeforeId = moveBeforeId;
      result$data['moveBeforeId'] = l$moveBeforeId;
    }
    if (_$data.containsKey('moveAfterId')) {
      final l$moveAfterId = moveAfterId;
      result$data['moveAfterId'] = l$moveAfterId;
    }
    if (_$data.containsKey('healthStatus')) {
      final l$healthStatus = healthStatus;
      result$data['healthStatus'] = l$healthStatus == null
          ? null
          : toJson$Enum$HealthStatus(l$healthStatus);
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    if (_$data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = iterationWildcardId;
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : toJson$Enum$IssueCreationIterationWildcardId(l$iterationWildcardId);
    }
    if (_$data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = iterationCadenceId;
      result$data['iterationCadenceId'] = l$iterationCadenceId;
    }
    return result$data;
  }

  CopyWith$Input$CreateIssueInput<Input$CreateIssueInput> get copyWith =>
      CopyWith$Input$CreateIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$locked = locked;
    final lOther$locked = other.locked;
    if (_$data.containsKey('locked') != other._$data.containsKey('locked')) {
      return false;
    }
    if (l$locked != lOther$locked) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (_$data.containsKey('iid') != other._$data.containsKey('iid')) {
      return false;
    }
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$mergeRequestToResolveDiscussionsOf =
        mergeRequestToResolveDiscussionsOf;
    final lOther$mergeRequestToResolveDiscussionsOf =
        other.mergeRequestToResolveDiscussionsOf;
    if (_$data.containsKey('mergeRequestToResolveDiscussionsOf') !=
        other._$data.containsKey('mergeRequestToResolveDiscussionsOf')) {
      return false;
    }
    if (l$mergeRequestToResolveDiscussionsOf !=
        lOther$mergeRequestToResolveDiscussionsOf) {
      return false;
    }
    final l$discussionToResolve = discussionToResolve;
    final lOther$discussionToResolve = other.discussionToResolve;
    if (_$data.containsKey('discussionToResolve') !=
        other._$data.containsKey('discussionToResolve')) {
      return false;
    }
    if (l$discussionToResolve != lOther$discussionToResolve) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$moveBeforeId = moveBeforeId;
    final lOther$moveBeforeId = other.moveBeforeId;
    if (_$data.containsKey('moveBeforeId') !=
        other._$data.containsKey('moveBeforeId')) {
      return false;
    }
    if (l$moveBeforeId != lOther$moveBeforeId) {
      return false;
    }
    final l$moveAfterId = moveAfterId;
    final lOther$moveAfterId = other.moveAfterId;
    if (_$data.containsKey('moveAfterId') !=
        other._$data.containsKey('moveAfterId')) {
      return false;
    }
    if (l$moveAfterId != lOther$moveAfterId) {
      return false;
    }
    final l$healthStatus = healthStatus;
    final lOther$healthStatus = other.healthStatus;
    if (_$data.containsKey('healthStatus') !=
        other._$data.containsKey('healthStatus')) {
      return false;
    }
    if (l$healthStatus != lOther$healthStatus) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$iterationWildcardId = iterationWildcardId;
    final lOther$iterationWildcardId = other.iterationWildcardId;
    if (_$data.containsKey('iterationWildcardId') !=
        other._$data.containsKey('iterationWildcardId')) {
      return false;
    }
    if (l$iterationWildcardId != lOther$iterationWildcardId) {
      return false;
    }
    final l$iterationCadenceId = iterationCadenceId;
    final lOther$iterationCadenceId = other.iterationCadenceId;
    if (_$data.containsKey('iterationCadenceId') !=
        other._$data.containsKey('iterationCadenceId')) {
      return false;
    }
    if (l$iterationCadenceId != lOther$iterationCadenceId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$dueDate = dueDate;
    final l$confidential = confidential;
    final l$locked = locked;
    final l$type = type;
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$title = title;
    final l$milestoneId = milestoneId;
    final l$labels = labels;
    final l$labelIds = labelIds;
    final l$createdAt = createdAt;
    final l$mergeRequestToResolveDiscussionsOf =
        mergeRequestToResolveDiscussionsOf;
    final l$discussionToResolve = discussionToResolve;
    final l$assigneeIds = assigneeIds;
    final l$moveBeforeId = moveBeforeId;
    final l$moveAfterId = moveAfterId;
    final l$healthStatus = healthStatus;
    final l$weight = weight;
    final l$epicId = epicId;
    final l$iterationId = iterationId;
    final l$iterationWildcardId = iterationWildcardId;
    final l$iterationCadenceId = iterationCadenceId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('dueDate') ? l$dueDate : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('locked') ? l$locked : const {},
      _$data.containsKey('type') ? l$type : const {},
      l$projectPath,
      _$data.containsKey('iid') ? l$iid : const {},
      l$title,
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('mergeRequestToResolveDiscussionsOf')
          ? l$mergeRequestToResolveDiscussionsOf
          : const {},
      _$data.containsKey('discussionToResolve')
          ? l$discussionToResolve
          : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('moveBeforeId') ? l$moveBeforeId : const {},
      _$data.containsKey('moveAfterId') ? l$moveAfterId : const {},
      _$data.containsKey('healthStatus') ? l$healthStatus : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
      _$data.containsKey('iterationWildcardId')
          ? l$iterationWildcardId
          : const {},
      _$data.containsKey('iterationCadenceId')
          ? l$iterationCadenceId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateIssueInput<TRes> {
  factory CopyWith$Input$CreateIssueInput(
    Input$CreateIssueInput instance,
    TRes Function(Input$CreateIssueInput) then,
  ) = _CopyWithImpl$Input$CreateIssueInput;

  factory CopyWith$Input$CreateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIssueInput;

  TRes call({
    String? clientMutationId,
    String? description,
    String? dueDate,
    bool? confidential,
    bool? locked,
    Enum$IssueType? type,
    String? projectPath,
    int? iid,
    String? title,
    String? milestoneId,
    List<String>? labels,
    List<String>? labelIds,
    String? createdAt,
    String? mergeRequestToResolveDiscussionsOf,
    String? discussionToResolve,
    List<String>? assigneeIds,
    String? moveBeforeId,
    String? moveAfterId,
    Enum$HealthStatus? healthStatus,
    int? weight,
    String? epicId,
    String? iterationId,
    Enum$IssueCreationIterationWildcardId? iterationWildcardId,
    String? iterationCadenceId,
  });
}

class _CopyWithImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithImpl$Input$CreateIssueInput(
    this._instance,
    this._then,
  );

  final Input$CreateIssueInput _instance;

  final TRes Function(Input$CreateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? dueDate = _undefined,
    Object? confidential = _undefined,
    Object? locked = _undefined,
    Object? type = _undefined,
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? title = _undefined,
    Object? milestoneId = _undefined,
    Object? labels = _undefined,
    Object? labelIds = _undefined,
    Object? createdAt = _undefined,
    Object? mergeRequestToResolveDiscussionsOf = _undefined,
    Object? discussionToResolve = _undefined,
    Object? assigneeIds = _undefined,
    Object? moveBeforeId = _undefined,
    Object? moveAfterId = _undefined,
    Object? healthStatus = _undefined,
    Object? weight = _undefined,
    Object? epicId = _undefined,
    Object? iterationId = _undefined,
    Object? iterationWildcardId = _undefined,
    Object? iterationCadenceId = _undefined,
  }) =>
      _then(Input$CreateIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (locked != _undefined) 'locked': (locked as bool?),
        if (type != _undefined) 'type': (type as Enum$IssueType?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined) 'iid': (iid as int?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (mergeRequestToResolveDiscussionsOf != _undefined)
          'mergeRequestToResolveDiscussionsOf':
              (mergeRequestToResolveDiscussionsOf as String?),
        if (discussionToResolve != _undefined)
          'discussionToResolve': (discussionToResolve as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (moveBeforeId != _undefined)
          'moveBeforeId': (moveBeforeId as String?),
        if (moveAfterId != _undefined) 'moveAfterId': (moveAfterId as String?),
        if (healthStatus != _undefined)
          'healthStatus': (healthStatus as Enum$HealthStatus?),
        if (weight != _undefined) 'weight': (weight as int?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
        if (iterationWildcardId != _undefined)
          'iterationWildcardId':
              (iterationWildcardId as Enum$IssueCreationIterationWildcardId?),
        if (iterationCadenceId != _undefined)
          'iterationCadenceId': (iterationCadenceId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithStubImpl$Input$CreateIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? description,
    String? dueDate,
    bool? confidential,
    bool? locked,
    Enum$IssueType? type,
    String? projectPath,
    int? iid,
    String? title,
    String? milestoneId,
    List<String>? labels,
    List<String>? labelIds,
    String? createdAt,
    String? mergeRequestToResolveDiscussionsOf,
    String? discussionToResolve,
    List<String>? assigneeIds,
    String? moveBeforeId,
    String? moveAfterId,
    Enum$HealthStatus? healthStatus,
    int? weight,
    String? epicId,
    String? iterationId,
    Enum$IssueCreationIterationWildcardId? iterationWildcardId,
    String? iterationCadenceId,
  }) =>
      _res;
}

class Input$CreateIterationInput {
  factory Input$CreateIterationInput({
    String? projectPath,
    String? groupPath,
    String? iterationsCadenceId,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
    String? clientMutationId,
  }) =>
      Input$CreateIterationInput._({
        if (projectPath != null) r'projectPath': projectPath,
        if (groupPath != null) r'groupPath': groupPath,
        if (iterationsCadenceId != null)
          r'iterationsCadenceId': iterationsCadenceId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (startDate != null) r'startDate': startDate,
        if (dueDate != null) r'dueDate': dueDate,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateIterationInput._(this._$data);

  factory Input$CreateIterationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectPath')) {
      final l$projectPath = data['projectPath'];
      result$data['projectPath'] = (l$projectPath as String?);
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    if (data.containsKey('iterationsCadenceId')) {
      final l$iterationsCadenceId = data['iterationsCadenceId'];
      result$data['iterationsCadenceId'] = (l$iterationsCadenceId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateIterationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get projectPath => (_$data['projectPath'] as String?);
  String? get groupPath => (_$data['groupPath'] as String?);
  String? get iterationsCadenceId => (_$data['iterationsCadenceId'] as String?);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get startDate => (_$data['startDate'] as String?);
  String? get dueDate => (_$data['dueDate'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectPath')) {
      final l$projectPath = projectPath;
      result$data['projectPath'] = l$projectPath;
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    if (_$data.containsKey('iterationsCadenceId')) {
      final l$iterationsCadenceId = iterationsCadenceId;
      result$data['iterationsCadenceId'] = l$iterationsCadenceId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateIterationInput<Input$CreateIterationInput>
      get copyWith => CopyWith$Input$CreateIterationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateIterationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (_$data.containsKey('projectPath') !=
        other._$data.containsKey('projectPath')) {
      return false;
    }
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$iterationsCadenceId = iterationsCadenceId;
    final lOther$iterationsCadenceId = other.iterationsCadenceId;
    if (_$data.containsKey('iterationsCadenceId') !=
        other._$data.containsKey('iterationsCadenceId')) {
      return false;
    }
    if (l$iterationsCadenceId != lOther$iterationsCadenceId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$groupPath = groupPath;
    final l$iterationsCadenceId = iterationsCadenceId;
    final l$title = title;
    final l$description = description;
    final l$startDate = startDate;
    final l$dueDate = dueDate;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('projectPath') ? l$projectPath : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
      _$data.containsKey('iterationsCadenceId')
          ? l$iterationsCadenceId
          : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('dueDate') ? l$dueDate : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateIterationInput<TRes> {
  factory CopyWith$Input$CreateIterationInput(
    Input$CreateIterationInput instance,
    TRes Function(Input$CreateIterationInput) then,
  ) = _CopyWithImpl$Input$CreateIterationInput;

  factory CopyWith$Input$CreateIterationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIterationInput;

  TRes call({
    String? projectPath,
    String? groupPath,
    String? iterationsCadenceId,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateIterationInput<TRes>
    implements CopyWith$Input$CreateIterationInput<TRes> {
  _CopyWithImpl$Input$CreateIterationInput(
    this._instance,
    this._then,
  );

  final Input$CreateIterationInput _instance;

  final TRes Function(Input$CreateIterationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? groupPath = _undefined,
    Object? iterationsCadenceId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? startDate = _undefined,
    Object? dueDate = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateIterationInput._({
        ..._instance._$data,
        if (projectPath != _undefined) 'projectPath': (projectPath as String?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
        if (iterationsCadenceId != _undefined)
          'iterationsCadenceId': (iterationsCadenceId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateIterationInput<TRes>
    implements CopyWith$Input$CreateIterationInput<TRes> {
  _CopyWithStubImpl$Input$CreateIterationInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? groupPath,
    String? iterationsCadenceId,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateNoteInput {
  factory Input$CreateNoteInput({
    required String noteableId,
    required String body,
    bool? internal,
    String? clientMutationId,
    String? discussionId,
    String? mergeRequestDiffHeadSha,
  }) =>
      Input$CreateNoteInput._({
        r'noteableId': noteableId,
        r'body': body,
        if (internal != null) r'internal': internal,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (discussionId != null) r'discussionId': discussionId,
        if (mergeRequestDiffHeadSha != null)
          r'mergeRequestDiffHeadSha': mergeRequestDiffHeadSha,
      });

  Input$CreateNoteInput._(this._$data);

  factory Input$CreateNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$noteableId = data['noteableId'];
    result$data['noteableId'] = (l$noteableId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('internal')) {
      final l$internal = data['internal'];
      result$data['internal'] = (l$internal as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('discussionId')) {
      final l$discussionId = data['discussionId'];
      result$data['discussionId'] = (l$discussionId as String?);
    }
    if (data.containsKey('mergeRequestDiffHeadSha')) {
      final l$mergeRequestDiffHeadSha = data['mergeRequestDiffHeadSha'];
      result$data['mergeRequestDiffHeadSha'] =
          (l$mergeRequestDiffHeadSha as String?);
    }
    return Input$CreateNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get noteableId => (_$data['noteableId'] as String);
  String get body => (_$data['body'] as String);
  bool? get internal => (_$data['internal'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get discussionId => (_$data['discussionId'] as String?);
  String? get mergeRequestDiffHeadSha =>
      (_$data['mergeRequestDiffHeadSha'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$noteableId = noteableId;
    result$data['noteableId'] = l$noteableId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('internal')) {
      final l$internal = internal;
      result$data['internal'] = l$internal;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('discussionId')) {
      final l$discussionId = discussionId;
      result$data['discussionId'] = l$discussionId;
    }
    if (_$data.containsKey('mergeRequestDiffHeadSha')) {
      final l$mergeRequestDiffHeadSha = mergeRequestDiffHeadSha;
      result$data['mergeRequestDiffHeadSha'] = l$mergeRequestDiffHeadSha;
    }
    return result$data;
  }

  CopyWith$Input$CreateNoteInput<Input$CreateNoteInput> get copyWith =>
      CopyWith$Input$CreateNoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateNoteInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$noteableId = noteableId;
    final lOther$noteableId = other.noteableId;
    if (l$noteableId != lOther$noteableId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$internal = internal;
    final lOther$internal = other.internal;
    if (_$data.containsKey('internal') !=
        other._$data.containsKey('internal')) {
      return false;
    }
    if (l$internal != lOther$internal) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (_$data.containsKey('discussionId') !=
        other._$data.containsKey('discussionId')) {
      return false;
    }
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$mergeRequestDiffHeadSha = mergeRequestDiffHeadSha;
    final lOther$mergeRequestDiffHeadSha = other.mergeRequestDiffHeadSha;
    if (_$data.containsKey('mergeRequestDiffHeadSha') !=
        other._$data.containsKey('mergeRequestDiffHeadSha')) {
      return false;
    }
    if (l$mergeRequestDiffHeadSha != lOther$mergeRequestDiffHeadSha) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$noteableId = noteableId;
    final l$body = body;
    final l$internal = internal;
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$mergeRequestDiffHeadSha = mergeRequestDiffHeadSha;
    return Object.hashAll([
      l$noteableId,
      l$body,
      _$data.containsKey('internal') ? l$internal : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('discussionId') ? l$discussionId : const {},
      _$data.containsKey('mergeRequestDiffHeadSha')
          ? l$mergeRequestDiffHeadSha
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateNoteInput<TRes> {
  factory CopyWith$Input$CreateNoteInput(
    Input$CreateNoteInput instance,
    TRes Function(Input$CreateNoteInput) then,
  ) = _CopyWithImpl$Input$CreateNoteInput;

  factory CopyWith$Input$CreateNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateNoteInput;

  TRes call({
    String? noteableId,
    String? body,
    bool? internal,
    String? clientMutationId,
    String? discussionId,
    String? mergeRequestDiffHeadSha,
  });
}

class _CopyWithImpl$Input$CreateNoteInput<TRes>
    implements CopyWith$Input$CreateNoteInput<TRes> {
  _CopyWithImpl$Input$CreateNoteInput(
    this._instance,
    this._then,
  );

  final Input$CreateNoteInput _instance;

  final TRes Function(Input$CreateNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? noteableId = _undefined,
    Object? body = _undefined,
    Object? internal = _undefined,
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? mergeRequestDiffHeadSha = _undefined,
  }) =>
      _then(Input$CreateNoteInput._({
        ..._instance._$data,
        if (noteableId != _undefined && noteableId != null)
          'noteableId': (noteableId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (internal != _undefined) 'internal': (internal as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined)
          'discussionId': (discussionId as String?),
        if (mergeRequestDiffHeadSha != _undefined)
          'mergeRequestDiffHeadSha': (mergeRequestDiffHeadSha as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateNoteInput<TRes>
    implements CopyWith$Input$CreateNoteInput<TRes> {
  _CopyWithStubImpl$Input$CreateNoteInput(this._res);

  TRes _res;

  call({
    String? noteableId,
    String? body,
    bool? internal,
    String? clientMutationId,
    String? discussionId,
    String? mergeRequestDiffHeadSha,
  }) =>
      _res;
}

class Input$CreateRequirementInput {
  factory Input$CreateRequirementInput({
    String? title,
    String? description,
    required String projectPath,
    String? clientMutationId,
  }) =>
      Input$CreateRequirementInput._({
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateRequirementInput._(this._$data);

  factory Input$CreateRequirementInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateRequirementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateRequirementInput<Input$CreateRequirementInput>
      get copyWith => CopyWith$Input$CreateRequirementInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateRequirementInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$description = description;
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateRequirementInput<TRes> {
  factory CopyWith$Input$CreateRequirementInput(
    Input$CreateRequirementInput instance,
    TRes Function(Input$CreateRequirementInput) then,
  ) = _CopyWithImpl$Input$CreateRequirementInput;

  factory CopyWith$Input$CreateRequirementInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRequirementInput;

  TRes call({
    String? title,
    String? description,
    String? projectPath,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateRequirementInput<TRes>
    implements CopyWith$Input$CreateRequirementInput<TRes> {
  _CopyWithImpl$Input$CreateRequirementInput(
    this._instance,
    this._then,
  );

  final Input$CreateRequirementInput _instance;

  final TRes Function(Input$CreateRequirementInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? description = _undefined,
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateRequirementInput._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateRequirementInput<TRes>
    implements CopyWith$Input$CreateRequirementInput<TRes> {
  _CopyWithStubImpl$Input$CreateRequirementInput(this._res);

  TRes _res;

  call({
    String? title,
    String? description,
    String? projectPath,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateSnippetInput {
  factory Input$CreateSnippetInput({
    String? clientMutationId,
    required String title,
    String? description,
    required Enum$VisibilityLevelsEnum visibilityLevel,
    String? projectPath,
    List<String>? uploadedFiles,
    List<Input$SnippetBlobActionInputType>? blobActions,
  }) =>
      Input$CreateSnippetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'title': title,
        if (description != null) r'description': description,
        r'visibilityLevel': visibilityLevel,
        if (projectPath != null) r'projectPath': projectPath,
        if (uploadedFiles != null) r'uploadedFiles': uploadedFiles,
        if (blobActions != null) r'blobActions': blobActions,
      });

  Input$CreateSnippetInput._(this._$data);

  factory Input$CreateSnippetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$visibilityLevel = data['visibilityLevel'];
    result$data['visibilityLevel'] =
        fromJson$Enum$VisibilityLevelsEnum((l$visibilityLevel as String));
    if (data.containsKey('projectPath')) {
      final l$projectPath = data['projectPath'];
      result$data['projectPath'] = (l$projectPath as String?);
    }
    if (data.containsKey('uploadedFiles')) {
      final l$uploadedFiles = data['uploadedFiles'];
      result$data['uploadedFiles'] = (l$uploadedFiles as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('blobActions')) {
      final l$blobActions = data['blobActions'];
      result$data['blobActions'] = (l$blobActions as List<dynamic>?)
          ?.map((e) => Input$SnippetBlobActionInputType.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CreateSnippetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get title => (_$data['title'] as String);
  String? get description => (_$data['description'] as String?);
  Enum$VisibilityLevelsEnum get visibilityLevel =>
      (_$data['visibilityLevel'] as Enum$VisibilityLevelsEnum);
  String? get projectPath => (_$data['projectPath'] as String?);
  List<String>? get uploadedFiles => (_$data['uploadedFiles'] as List<String>?);
  List<Input$SnippetBlobActionInputType>? get blobActions =>
      (_$data['blobActions'] as List<Input$SnippetBlobActionInputType>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$visibilityLevel = visibilityLevel;
    result$data['visibilityLevel'] =
        toJson$Enum$VisibilityLevelsEnum(l$visibilityLevel);
    if (_$data.containsKey('projectPath')) {
      final l$projectPath = projectPath;
      result$data['projectPath'] = l$projectPath;
    }
    if (_$data.containsKey('uploadedFiles')) {
      final l$uploadedFiles = uploadedFiles;
      result$data['uploadedFiles'] = l$uploadedFiles?.map((e) => e).toList();
    }
    if (_$data.containsKey('blobActions')) {
      final l$blobActions = blobActions;
      result$data['blobActions'] =
          l$blobActions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateSnippetInput<Input$CreateSnippetInput> get copyWith =>
      CopyWith$Input$CreateSnippetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSnippetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$visibilityLevel = visibilityLevel;
    final lOther$visibilityLevel = other.visibilityLevel;
    if (l$visibilityLevel != lOther$visibilityLevel) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (_$data.containsKey('projectPath') !=
        other._$data.containsKey('projectPath')) {
      return false;
    }
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$uploadedFiles = uploadedFiles;
    final lOther$uploadedFiles = other.uploadedFiles;
    if (_$data.containsKey('uploadedFiles') !=
        other._$data.containsKey('uploadedFiles')) {
      return false;
    }
    if (l$uploadedFiles != null && lOther$uploadedFiles != null) {
      if (l$uploadedFiles.length != lOther$uploadedFiles.length) {
        return false;
      }
      for (int i = 0; i < l$uploadedFiles.length; i++) {
        final l$uploadedFiles$entry = l$uploadedFiles[i];
        final lOther$uploadedFiles$entry = lOther$uploadedFiles[i];
        if (l$uploadedFiles$entry != lOther$uploadedFiles$entry) {
          return false;
        }
      }
    } else if (l$uploadedFiles != lOther$uploadedFiles) {
      return false;
    }
    final l$blobActions = blobActions;
    final lOther$blobActions = other.blobActions;
    if (_$data.containsKey('blobActions') !=
        other._$data.containsKey('blobActions')) {
      return false;
    }
    if (l$blobActions != null && lOther$blobActions != null) {
      if (l$blobActions.length != lOther$blobActions.length) {
        return false;
      }
      for (int i = 0; i < l$blobActions.length; i++) {
        final l$blobActions$entry = l$blobActions[i];
        final lOther$blobActions$entry = lOther$blobActions[i];
        if (l$blobActions$entry != lOther$blobActions$entry) {
          return false;
        }
      }
    } else if (l$blobActions != lOther$blobActions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$title = title;
    final l$description = description;
    final l$visibilityLevel = visibilityLevel;
    final l$projectPath = projectPath;
    final l$uploadedFiles = uploadedFiles;
    final l$blobActions = blobActions;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$title,
      _$data.containsKey('description') ? l$description : const {},
      l$visibilityLevel,
      _$data.containsKey('projectPath') ? l$projectPath : const {},
      _$data.containsKey('uploadedFiles')
          ? l$uploadedFiles == null
              ? null
              : Object.hashAll(l$uploadedFiles.map((v) => v))
          : const {},
      _$data.containsKey('blobActions')
          ? l$blobActions == null
              ? null
              : Object.hashAll(l$blobActions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSnippetInput<TRes> {
  factory CopyWith$Input$CreateSnippetInput(
    Input$CreateSnippetInput instance,
    TRes Function(Input$CreateSnippetInput) then,
  ) = _CopyWithImpl$Input$CreateSnippetInput;

  factory CopyWith$Input$CreateSnippetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSnippetInput;

  TRes call({
    String? clientMutationId,
    String? title,
    String? description,
    Enum$VisibilityLevelsEnum? visibilityLevel,
    String? projectPath,
    List<String>? uploadedFiles,
    List<Input$SnippetBlobActionInputType>? blobActions,
  });
  TRes blobActions(
      Iterable<Input$SnippetBlobActionInputType>? Function(
              Iterable<
                  CopyWith$Input$SnippetBlobActionInputType<
                      Input$SnippetBlobActionInputType>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateSnippetInput<TRes>
    implements CopyWith$Input$CreateSnippetInput<TRes> {
  _CopyWithImpl$Input$CreateSnippetInput(
    this._instance,
    this._then,
  );

  final Input$CreateSnippetInput _instance;

  final TRes Function(Input$CreateSnippetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? visibilityLevel = _undefined,
    Object? projectPath = _undefined,
    Object? uploadedFiles = _undefined,
    Object? blobActions = _undefined,
  }) =>
      _then(Input$CreateSnippetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (description != _undefined) 'description': (description as String?),
        if (visibilityLevel != _undefined && visibilityLevel != null)
          'visibilityLevel': (visibilityLevel as Enum$VisibilityLevelsEnum),
        if (projectPath != _undefined) 'projectPath': (projectPath as String?),
        if (uploadedFiles != _undefined)
          'uploadedFiles': (uploadedFiles as List<String>?),
        if (blobActions != _undefined)
          'blobActions':
              (blobActions as List<Input$SnippetBlobActionInputType>?),
      }));
  TRes blobActions(
          Iterable<Input$SnippetBlobActionInputType>? Function(
                  Iterable<
                      CopyWith$Input$SnippetBlobActionInputType<
                          Input$SnippetBlobActionInputType>>?)
              _fn) =>
      call(
          blobActions: _fn(_instance.blobActions
              ?.map((e) => CopyWith$Input$SnippetBlobActionInputType(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateSnippetInput<TRes>
    implements CopyWith$Input$CreateSnippetInput<TRes> {
  _CopyWithStubImpl$Input$CreateSnippetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? title,
    String? description,
    Enum$VisibilityLevelsEnum? visibilityLevel,
    String? projectPath,
    List<String>? uploadedFiles,
    List<Input$SnippetBlobActionInputType>? blobActions,
  }) =>
      _res;
  blobActions(_fn) => _res;
}

class Input$CreateTestCaseInput {
  factory Input$CreateTestCaseInput({
    String? clientMutationId,
    required String title,
    String? description,
    List<String>? labelIds,
    required String projectPath,
  }) =>
      Input$CreateTestCaseInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'title': title,
        if (description != null) r'description': description,
        if (labelIds != null) r'labelIds': labelIds,
        r'projectPath': projectPath,
      });

  Input$CreateTestCaseInput._(this._$data);

  factory Input$CreateTestCaseInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    return Input$CreateTestCaseInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get title => (_$data['title'] as String);
  String? get description => (_$data['description'] as String?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  String get projectPath => (_$data['projectPath'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    return result$data;
  }

  CopyWith$Input$CreateTestCaseInput<Input$CreateTestCaseInput> get copyWith =>
      CopyWith$Input$CreateTestCaseInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTestCaseInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$title = title;
    final l$description = description;
    final l$labelIds = labelIds;
    final l$projectPath = projectPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$title,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      l$projectPath,
    ]);
  }
}

abstract class CopyWith$Input$CreateTestCaseInput<TRes> {
  factory CopyWith$Input$CreateTestCaseInput(
    Input$CreateTestCaseInput instance,
    TRes Function(Input$CreateTestCaseInput) then,
  ) = _CopyWithImpl$Input$CreateTestCaseInput;

  factory CopyWith$Input$CreateTestCaseInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTestCaseInput;

  TRes call({
    String? clientMutationId,
    String? title,
    String? description,
    List<String>? labelIds,
    String? projectPath,
  });
}

class _CopyWithImpl$Input$CreateTestCaseInput<TRes>
    implements CopyWith$Input$CreateTestCaseInput<TRes> {
  _CopyWithImpl$Input$CreateTestCaseInput(
    this._instance,
    this._then,
  );

  final Input$CreateTestCaseInput _instance;

  final TRes Function(Input$CreateTestCaseInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? labelIds = _undefined,
    Object? projectPath = _undefined,
  }) =>
      _then(Input$CreateTestCaseInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (description != _undefined) 'description': (description as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
      }));
}

class _CopyWithStubImpl$Input$CreateTestCaseInput<TRes>
    implements CopyWith$Input$CreateTestCaseInput<TRes> {
  _CopyWithStubImpl$Input$CreateTestCaseInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? title,
    String? description,
    List<String>? labelIds,
    String? projectPath,
  }) =>
      _res;
}

class Input$CustomerRelationsContactCreateInput {
  factory Input$CustomerRelationsContactCreateInput({
    String? clientMutationId,
    required String groupId,
    String? organizationId,
    required String firstName,
    required String lastName,
    String? phone,
    String? email,
    String? description,
  }) =>
      Input$CustomerRelationsContactCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupId': groupId,
        if (organizationId != null) r'organizationId': organizationId,
        r'firstName': firstName,
        r'lastName': lastName,
        if (phone != null) r'phone': phone,
        if (email != null) r'email': email,
        if (description != null) r'description': description,
      });

  Input$CustomerRelationsContactCreateInput._(this._$data);

  factory Input$CustomerRelationsContactCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupId = data['groupId'];
    result$data['groupId'] = (l$groupId as String);
    if (data.containsKey('organizationId')) {
      final l$organizationId = data['organizationId'];
      result$data['organizationId'] = (l$organizationId as String?);
    }
    final l$firstName = data['firstName'];
    result$data['firstName'] = (l$firstName as String);
    final l$lastName = data['lastName'];
    result$data['lastName'] = (l$lastName as String);
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = (l$phone as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$CustomerRelationsContactCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupId => (_$data['groupId'] as String);
  String? get organizationId => (_$data['organizationId'] as String?);
  String get firstName => (_$data['firstName'] as String);
  String get lastName => (_$data['lastName'] as String);
  String? get phone => (_$data['phone'] as String?);
  String? get email => (_$data['email'] as String?);
  String? get description => (_$data['description'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupId = groupId;
    result$data['groupId'] = l$groupId;
    if (_$data.containsKey('organizationId')) {
      final l$organizationId = organizationId;
      result$data['organizationId'] = l$organizationId;
    }
    final l$firstName = firstName;
    result$data['firstName'] = l$firstName;
    final l$lastName = lastName;
    result$data['lastName'] = l$lastName;
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] = l$phone;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$CustomerRelationsContactCreateInput<
          Input$CustomerRelationsContactCreateInput>
      get copyWith => CopyWith$Input$CustomerRelationsContactCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CustomerRelationsContactCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupId = groupId;
    final lOther$groupId = other.groupId;
    if (l$groupId != lOther$groupId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (_$data.containsKey('organizationId') !=
        other._$data.containsKey('organizationId')) {
      return false;
    }
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupId = groupId;
    final l$organizationId = organizationId;
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$phone = phone;
    final l$email = email;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupId,
      _$data.containsKey('organizationId') ? l$organizationId : const {},
      l$firstName,
      l$lastName,
      _$data.containsKey('phone') ? l$phone : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomerRelationsContactCreateInput<TRes> {
  factory CopyWith$Input$CustomerRelationsContactCreateInput(
    Input$CustomerRelationsContactCreateInput instance,
    TRes Function(Input$CustomerRelationsContactCreateInput) then,
  ) = _CopyWithImpl$Input$CustomerRelationsContactCreateInput;

  factory CopyWith$Input$CustomerRelationsContactCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomerRelationsContactCreateInput;

  TRes call({
    String? clientMutationId,
    String? groupId,
    String? organizationId,
    String? firstName,
    String? lastName,
    String? phone,
    String? email,
    String? description,
  });
}

class _CopyWithImpl$Input$CustomerRelationsContactCreateInput<TRes>
    implements CopyWith$Input$CustomerRelationsContactCreateInput<TRes> {
  _CopyWithImpl$Input$CustomerRelationsContactCreateInput(
    this._instance,
    this._then,
  );

  final Input$CustomerRelationsContactCreateInput _instance;

  final TRes Function(Input$CustomerRelationsContactCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupId = _undefined,
    Object? organizationId = _undefined,
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? phone = _undefined,
    Object? email = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$CustomerRelationsContactCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupId != _undefined && groupId != null)
          'groupId': (groupId as String),
        if (organizationId != _undefined)
          'organizationId': (organizationId as String?),
        if (firstName != _undefined && firstName != null)
          'firstName': (firstName as String),
        if (lastName != _undefined && lastName != null)
          'lastName': (lastName as String),
        if (phone != _undefined) 'phone': (phone as String?),
        if (email != _undefined) 'email': (email as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$CustomerRelationsContactCreateInput<TRes>
    implements CopyWith$Input$CustomerRelationsContactCreateInput<TRes> {
  _CopyWithStubImpl$Input$CustomerRelationsContactCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupId,
    String? organizationId,
    String? firstName,
    String? lastName,
    String? phone,
    String? email,
    String? description,
  }) =>
      _res;
}

class Input$CustomerRelationsContactUpdateInput {
  factory Input$CustomerRelationsContactUpdateInput({
    String? clientMutationId,
    required String id,
    String? organizationId,
    String? firstName,
    String? lastName,
    String? phone,
    String? email,
    String? description,
    bool? active,
  }) =>
      Input$CustomerRelationsContactUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (organizationId != null) r'organizationId': organizationId,
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (phone != null) r'phone': phone,
        if (email != null) r'email': email,
        if (description != null) r'description': description,
        if (active != null) r'active': active,
      });

  Input$CustomerRelationsContactUpdateInput._(this._$data);

  factory Input$CustomerRelationsContactUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('organizationId')) {
      final l$organizationId = data['organizationId'];
      result$data['organizationId'] = (l$organizationId as String?);
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = (l$phone as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    return Input$CustomerRelationsContactUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get organizationId => (_$data['organizationId'] as String?);
  String? get firstName => (_$data['firstName'] as String?);
  String? get lastName => (_$data['lastName'] as String?);
  String? get phone => (_$data['phone'] as String?);
  String? get email => (_$data['email'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get active => (_$data['active'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('organizationId')) {
      final l$organizationId = organizationId;
      result$data['organizationId'] = l$organizationId;
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] = l$phone;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    return result$data;
  }

  CopyWith$Input$CustomerRelationsContactUpdateInput<
          Input$CustomerRelationsContactUpdateInput>
      get copyWith => CopyWith$Input$CustomerRelationsContactUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CustomerRelationsContactUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (_$data.containsKey('organizationId') !=
        other._$data.containsKey('organizationId')) {
      return false;
    }
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$organizationId = organizationId;
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$phone = phone;
    final l$email = email;
    final l$description = description;
    final l$active = active;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('organizationId') ? l$organizationId : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('phone') ? l$phone : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('active') ? l$active : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomerRelationsContactUpdateInput<TRes> {
  factory CopyWith$Input$CustomerRelationsContactUpdateInput(
    Input$CustomerRelationsContactUpdateInput instance,
    TRes Function(Input$CustomerRelationsContactUpdateInput) then,
  ) = _CopyWithImpl$Input$CustomerRelationsContactUpdateInput;

  factory CopyWith$Input$CustomerRelationsContactUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomerRelationsContactUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? organizationId,
    String? firstName,
    String? lastName,
    String? phone,
    String? email,
    String? description,
    bool? active,
  });
}

class _CopyWithImpl$Input$CustomerRelationsContactUpdateInput<TRes>
    implements CopyWith$Input$CustomerRelationsContactUpdateInput<TRes> {
  _CopyWithImpl$Input$CustomerRelationsContactUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CustomerRelationsContactUpdateInput _instance;

  final TRes Function(Input$CustomerRelationsContactUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? organizationId = _undefined,
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? phone = _undefined,
    Object? email = _undefined,
    Object? description = _undefined,
    Object? active = _undefined,
  }) =>
      _then(Input$CustomerRelationsContactUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (organizationId != _undefined)
          'organizationId': (organizationId as String?),
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (phone != _undefined) 'phone': (phone as String?),
        if (email != _undefined) 'email': (email as String?),
        if (description != _undefined) 'description': (description as String?),
        if (active != _undefined) 'active': (active as bool?),
      }));
}

class _CopyWithStubImpl$Input$CustomerRelationsContactUpdateInput<TRes>
    implements CopyWith$Input$CustomerRelationsContactUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CustomerRelationsContactUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? organizationId,
    String? firstName,
    String? lastName,
    String? phone,
    String? email,
    String? description,
    bool? active,
  }) =>
      _res;
}

class Input$CustomerRelationsOrganizationCreateInput {
  factory Input$CustomerRelationsOrganizationCreateInput({
    String? clientMutationId,
    required String groupId,
    required String name,
    double? defaultRate,
    String? description,
  }) =>
      Input$CustomerRelationsOrganizationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupId': groupId,
        r'name': name,
        if (defaultRate != null) r'defaultRate': defaultRate,
        if (description != null) r'description': description,
      });

  Input$CustomerRelationsOrganizationCreateInput._(this._$data);

  factory Input$CustomerRelationsOrganizationCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupId = data['groupId'];
    result$data['groupId'] = (l$groupId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('defaultRate')) {
      final l$defaultRate = data['defaultRate'];
      result$data['defaultRate'] = (l$defaultRate as num?)?.toDouble();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$CustomerRelationsOrganizationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupId => (_$data['groupId'] as String);
  String get name => (_$data['name'] as String);
  double? get defaultRate => (_$data['defaultRate'] as double?);
  String? get description => (_$data['description'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupId = groupId;
    result$data['groupId'] = l$groupId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('defaultRate')) {
      final l$defaultRate = defaultRate;
      result$data['defaultRate'] = l$defaultRate;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$CustomerRelationsOrganizationCreateInput<
          Input$CustomerRelationsOrganizationCreateInput>
      get copyWith => CopyWith$Input$CustomerRelationsOrganizationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CustomerRelationsOrganizationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupId = groupId;
    final lOther$groupId = other.groupId;
    if (l$groupId != lOther$groupId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$defaultRate = defaultRate;
    final lOther$defaultRate = other.defaultRate;
    if (_$data.containsKey('defaultRate') !=
        other._$data.containsKey('defaultRate')) {
      return false;
    }
    if (l$defaultRate != lOther$defaultRate) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupId = groupId;
    final l$name = name;
    final l$defaultRate = defaultRate;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupId,
      l$name,
      _$data.containsKey('defaultRate') ? l$defaultRate : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomerRelationsOrganizationCreateInput<TRes> {
  factory CopyWith$Input$CustomerRelationsOrganizationCreateInput(
    Input$CustomerRelationsOrganizationCreateInput instance,
    TRes Function(Input$CustomerRelationsOrganizationCreateInput) then,
  ) = _CopyWithImpl$Input$CustomerRelationsOrganizationCreateInput;

  factory CopyWith$Input$CustomerRelationsOrganizationCreateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CustomerRelationsOrganizationCreateInput;

  TRes call({
    String? clientMutationId,
    String? groupId,
    String? name,
    double? defaultRate,
    String? description,
  });
}

class _CopyWithImpl$Input$CustomerRelationsOrganizationCreateInput<TRes>
    implements CopyWith$Input$CustomerRelationsOrganizationCreateInput<TRes> {
  _CopyWithImpl$Input$CustomerRelationsOrganizationCreateInput(
    this._instance,
    this._then,
  );

  final Input$CustomerRelationsOrganizationCreateInput _instance;

  final TRes Function(Input$CustomerRelationsOrganizationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupId = _undefined,
    Object? name = _undefined,
    Object? defaultRate = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$CustomerRelationsOrganizationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupId != _undefined && groupId != null)
          'groupId': (groupId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (defaultRate != _undefined) 'defaultRate': (defaultRate as double?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$CustomerRelationsOrganizationCreateInput<TRes>
    implements CopyWith$Input$CustomerRelationsOrganizationCreateInput<TRes> {
  _CopyWithStubImpl$Input$CustomerRelationsOrganizationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupId,
    String? name,
    double? defaultRate,
    String? description,
  }) =>
      _res;
}

class Input$CustomerRelationsOrganizationUpdateInput {
  factory Input$CustomerRelationsOrganizationUpdateInput({
    String? clientMutationId,
    required String id,
    String? name,
    double? defaultRate,
    String? description,
    bool? active,
  }) =>
      Input$CustomerRelationsOrganizationUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (name != null) r'name': name,
        if (defaultRate != null) r'defaultRate': defaultRate,
        if (description != null) r'description': description,
        if (active != null) r'active': active,
      });

  Input$CustomerRelationsOrganizationUpdateInput._(this._$data);

  factory Input$CustomerRelationsOrganizationUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('defaultRate')) {
      final l$defaultRate = data['defaultRate'];
      result$data['defaultRate'] = (l$defaultRate as num?)?.toDouble();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    return Input$CustomerRelationsOrganizationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get name => (_$data['name'] as String?);
  double? get defaultRate => (_$data['defaultRate'] as double?);
  String? get description => (_$data['description'] as String?);
  bool? get active => (_$data['active'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('defaultRate')) {
      final l$defaultRate = defaultRate;
      result$data['defaultRate'] = l$defaultRate;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    return result$data;
  }

  CopyWith$Input$CustomerRelationsOrganizationUpdateInput<
          Input$CustomerRelationsOrganizationUpdateInput>
      get copyWith => CopyWith$Input$CustomerRelationsOrganizationUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CustomerRelationsOrganizationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$defaultRate = defaultRate;
    final lOther$defaultRate = other.defaultRate;
    if (_$data.containsKey('defaultRate') !=
        other._$data.containsKey('defaultRate')) {
      return false;
    }
    if (l$defaultRate != lOther$defaultRate) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$name = name;
    final l$defaultRate = defaultRate;
    final l$description = description;
    final l$active = active;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('defaultRate') ? l$defaultRate : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('active') ? l$active : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomerRelationsOrganizationUpdateInput<TRes> {
  factory CopyWith$Input$CustomerRelationsOrganizationUpdateInput(
    Input$CustomerRelationsOrganizationUpdateInput instance,
    TRes Function(Input$CustomerRelationsOrganizationUpdateInput) then,
  ) = _CopyWithImpl$Input$CustomerRelationsOrganizationUpdateInput;

  factory CopyWith$Input$CustomerRelationsOrganizationUpdateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CustomerRelationsOrganizationUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? name,
    double? defaultRate,
    String? description,
    bool? active,
  });
}

class _CopyWithImpl$Input$CustomerRelationsOrganizationUpdateInput<TRes>
    implements CopyWith$Input$CustomerRelationsOrganizationUpdateInput<TRes> {
  _CopyWithImpl$Input$CustomerRelationsOrganizationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CustomerRelationsOrganizationUpdateInput _instance;

  final TRes Function(Input$CustomerRelationsOrganizationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? defaultRate = _undefined,
    Object? description = _undefined,
    Object? active = _undefined,
  }) =>
      _then(Input$CustomerRelationsOrganizationUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined) 'name': (name as String?),
        if (defaultRate != _undefined) 'defaultRate': (defaultRate as double?),
        if (description != _undefined) 'description': (description as String?),
        if (active != _undefined) 'active': (active as bool?),
      }));
}

class _CopyWithStubImpl$Input$CustomerRelationsOrganizationUpdateInput<TRes>
    implements CopyWith$Input$CustomerRelationsOrganizationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CustomerRelationsOrganizationUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? name,
    double? defaultRate,
    String? description,
    bool? active,
  }) =>
      _res;
}

class Input$DastOnDemandScanCreateInput {
  factory Input$DastOnDemandScanCreateInput({
    String? clientMutationId,
    required String fullPath,
    required String dastSiteProfileId,
    String? dastScannerProfileId,
  }) =>
      Input$DastOnDemandScanCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        r'dastSiteProfileId': dastSiteProfileId,
        if (dastScannerProfileId != null)
          r'dastScannerProfileId': dastScannerProfileId,
      });

  Input$DastOnDemandScanCreateInput._(this._$data);

  factory Input$DastOnDemandScanCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    final l$dastSiteProfileId = data['dastSiteProfileId'];
    result$data['dastSiteProfileId'] = (l$dastSiteProfileId as String);
    if (data.containsKey('dastScannerProfileId')) {
      final l$dastScannerProfileId = data['dastScannerProfileId'];
      result$data['dastScannerProfileId'] = (l$dastScannerProfileId as String?);
    }
    return Input$DastOnDemandScanCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  String get dastSiteProfileId => (_$data['dastSiteProfileId'] as String);
  String? get dastScannerProfileId =>
      (_$data['dastScannerProfileId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    final l$dastSiteProfileId = dastSiteProfileId;
    result$data['dastSiteProfileId'] = l$dastSiteProfileId;
    if (_$data.containsKey('dastScannerProfileId')) {
      final l$dastScannerProfileId = dastScannerProfileId;
      result$data['dastScannerProfileId'] = l$dastScannerProfileId;
    }
    return result$data;
  }

  CopyWith$Input$DastOnDemandScanCreateInput<Input$DastOnDemandScanCreateInput>
      get copyWith => CopyWith$Input$DastOnDemandScanCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastOnDemandScanCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$dastSiteProfileId = dastSiteProfileId;
    final lOther$dastSiteProfileId = other.dastSiteProfileId;
    if (l$dastSiteProfileId != lOther$dastSiteProfileId) {
      return false;
    }
    final l$dastScannerProfileId = dastScannerProfileId;
    final lOther$dastScannerProfileId = other.dastScannerProfileId;
    if (_$data.containsKey('dastScannerProfileId') !=
        other._$data.containsKey('dastScannerProfileId')) {
      return false;
    }
    if (l$dastScannerProfileId != lOther$dastScannerProfileId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$dastSiteProfileId = dastSiteProfileId;
    final l$dastScannerProfileId = dastScannerProfileId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      l$dastSiteProfileId,
      _$data.containsKey('dastScannerProfileId')
          ? l$dastScannerProfileId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastOnDemandScanCreateInput<TRes> {
  factory CopyWith$Input$DastOnDemandScanCreateInput(
    Input$DastOnDemandScanCreateInput instance,
    TRes Function(Input$DastOnDemandScanCreateInput) then,
  ) = _CopyWithImpl$Input$DastOnDemandScanCreateInput;

  factory CopyWith$Input$DastOnDemandScanCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastOnDemandScanCreateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
  });
}

class _CopyWithImpl$Input$DastOnDemandScanCreateInput<TRes>
    implements CopyWith$Input$DastOnDemandScanCreateInput<TRes> {
  _CopyWithImpl$Input$DastOnDemandScanCreateInput(
    this._instance,
    this._then,
  );

  final Input$DastOnDemandScanCreateInput _instance;

  final TRes Function(Input$DastOnDemandScanCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? dastSiteProfileId = _undefined,
    Object? dastScannerProfileId = _undefined,
  }) =>
      _then(Input$DastOnDemandScanCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (dastSiteProfileId != _undefined && dastSiteProfileId != null)
          'dastSiteProfileId': (dastSiteProfileId as String),
        if (dastScannerProfileId != _undefined)
          'dastScannerProfileId': (dastScannerProfileId as String?),
      }));
}

class _CopyWithStubImpl$Input$DastOnDemandScanCreateInput<TRes>
    implements CopyWith$Input$DastOnDemandScanCreateInput<TRes> {
  _CopyWithStubImpl$Input$DastOnDemandScanCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
  }) =>
      _res;
}

class Input$DastProfileCadenceInput {
  factory Input$DastProfileCadenceInput({
    Enum$DastProfileCadenceUnit? unit,
    int? duration,
  }) =>
      Input$DastProfileCadenceInput._({
        if (unit != null) r'unit': unit,
        if (duration != null) r'duration': duration,
      });

  Input$DastProfileCadenceInput._(this._$data);

  factory Input$DastProfileCadenceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('unit')) {
      final l$unit = data['unit'];
      result$data['unit'] = l$unit == null
          ? null
          : fromJson$Enum$DastProfileCadenceUnit((l$unit as String));
    }
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = (l$duration as int?);
    }
    return Input$DastProfileCadenceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DastProfileCadenceUnit? get unit =>
      (_$data['unit'] as Enum$DastProfileCadenceUnit?);
  int? get duration => (_$data['duration'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('unit')) {
      final l$unit = unit;
      result$data['unit'] =
          l$unit == null ? null : toJson$Enum$DastProfileCadenceUnit(l$unit);
    }
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration;
    }
    return result$data;
  }

  CopyWith$Input$DastProfileCadenceInput<Input$DastProfileCadenceInput>
      get copyWith => CopyWith$Input$DastProfileCadenceInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastProfileCadenceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$unit = unit;
    final lOther$unit = other.unit;
    if (_$data.containsKey('unit') != other._$data.containsKey('unit')) {
      return false;
    }
    if (l$unit != lOther$unit) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$unit = unit;
    final l$duration = duration;
    return Object.hashAll([
      _$data.containsKey('unit') ? l$unit : const {},
      _$data.containsKey('duration') ? l$duration : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastProfileCadenceInput<TRes> {
  factory CopyWith$Input$DastProfileCadenceInput(
    Input$DastProfileCadenceInput instance,
    TRes Function(Input$DastProfileCadenceInput) then,
  ) = _CopyWithImpl$Input$DastProfileCadenceInput;

  factory CopyWith$Input$DastProfileCadenceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastProfileCadenceInput;

  TRes call({
    Enum$DastProfileCadenceUnit? unit,
    int? duration,
  });
}

class _CopyWithImpl$Input$DastProfileCadenceInput<TRes>
    implements CopyWith$Input$DastProfileCadenceInput<TRes> {
  _CopyWithImpl$Input$DastProfileCadenceInput(
    this._instance,
    this._then,
  );

  final Input$DastProfileCadenceInput _instance;

  final TRes Function(Input$DastProfileCadenceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? unit = _undefined,
    Object? duration = _undefined,
  }) =>
      _then(Input$DastProfileCadenceInput._({
        ..._instance._$data,
        if (unit != _undefined) 'unit': (unit as Enum$DastProfileCadenceUnit?),
        if (duration != _undefined) 'duration': (duration as int?),
      }));
}

class _CopyWithStubImpl$Input$DastProfileCadenceInput<TRes>
    implements CopyWith$Input$DastProfileCadenceInput<TRes> {
  _CopyWithStubImpl$Input$DastProfileCadenceInput(this._res);

  TRes _res;

  call({
    Enum$DastProfileCadenceUnit? unit,
    int? duration,
  }) =>
      _res;
}

class Input$DastProfileCreateInput {
  factory Input$DastProfileCreateInput({
    String? clientMutationId,
    required String fullPath,
    Input$DastProfileScheduleInput? dastProfileSchedule,
    required String name,
    String? description,
    String? branchName,
    required String dastSiteProfileId,
    required String dastScannerProfileId,
    bool? runAfterCreate,
  }) =>
      Input$DastProfileCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        if (dastProfileSchedule != null)
          r'dastProfileSchedule': dastProfileSchedule,
        r'name': name,
        if (description != null) r'description': description,
        if (branchName != null) r'branchName': branchName,
        r'dastSiteProfileId': dastSiteProfileId,
        r'dastScannerProfileId': dastScannerProfileId,
        if (runAfterCreate != null) r'runAfterCreate': runAfterCreate,
      });

  Input$DastProfileCreateInput._(this._$data);

  factory Input$DastProfileCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    if (data.containsKey('dastProfileSchedule')) {
      final l$dastProfileSchedule = data['dastProfileSchedule'];
      result$data['dastProfileSchedule'] = l$dastProfileSchedule == null
          ? null
          : Input$DastProfileScheduleInput.fromJson(
              (l$dastProfileSchedule as Map<String, dynamic>));
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('branchName')) {
      final l$branchName = data['branchName'];
      result$data['branchName'] = (l$branchName as String?);
    }
    final l$dastSiteProfileId = data['dastSiteProfileId'];
    result$data['dastSiteProfileId'] = (l$dastSiteProfileId as String);
    final l$dastScannerProfileId = data['dastScannerProfileId'];
    result$data['dastScannerProfileId'] = (l$dastScannerProfileId as String);
    if (data.containsKey('runAfterCreate')) {
      final l$runAfterCreate = data['runAfterCreate'];
      result$data['runAfterCreate'] = (l$runAfterCreate as bool?);
    }
    return Input$DastProfileCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  Input$DastProfileScheduleInput? get dastProfileSchedule =>
      (_$data['dastProfileSchedule'] as Input$DastProfileScheduleInput?);
  String get name => (_$data['name'] as String);
  String? get description => (_$data['description'] as String?);
  String? get branchName => (_$data['branchName'] as String?);
  String get dastSiteProfileId => (_$data['dastSiteProfileId'] as String);
  String get dastScannerProfileId => (_$data['dastScannerProfileId'] as String);
  bool? get runAfterCreate => (_$data['runAfterCreate'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    if (_$data.containsKey('dastProfileSchedule')) {
      final l$dastProfileSchedule = dastProfileSchedule;
      result$data['dastProfileSchedule'] = l$dastProfileSchedule?.toJson();
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('branchName')) {
      final l$branchName = branchName;
      result$data['branchName'] = l$branchName;
    }
    final l$dastSiteProfileId = dastSiteProfileId;
    result$data['dastSiteProfileId'] = l$dastSiteProfileId;
    final l$dastScannerProfileId = dastScannerProfileId;
    result$data['dastScannerProfileId'] = l$dastScannerProfileId;
    if (_$data.containsKey('runAfterCreate')) {
      final l$runAfterCreate = runAfterCreate;
      result$data['runAfterCreate'] = l$runAfterCreate;
    }
    return result$data;
  }

  CopyWith$Input$DastProfileCreateInput<Input$DastProfileCreateInput>
      get copyWith => CopyWith$Input$DastProfileCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastProfileCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$dastProfileSchedule = dastProfileSchedule;
    final lOther$dastProfileSchedule = other.dastProfileSchedule;
    if (_$data.containsKey('dastProfileSchedule') !=
        other._$data.containsKey('dastProfileSchedule')) {
      return false;
    }
    if (l$dastProfileSchedule != lOther$dastProfileSchedule) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$branchName = branchName;
    final lOther$branchName = other.branchName;
    if (_$data.containsKey('branchName') !=
        other._$data.containsKey('branchName')) {
      return false;
    }
    if (l$branchName != lOther$branchName) {
      return false;
    }
    final l$dastSiteProfileId = dastSiteProfileId;
    final lOther$dastSiteProfileId = other.dastSiteProfileId;
    if (l$dastSiteProfileId != lOther$dastSiteProfileId) {
      return false;
    }
    final l$dastScannerProfileId = dastScannerProfileId;
    final lOther$dastScannerProfileId = other.dastScannerProfileId;
    if (l$dastScannerProfileId != lOther$dastScannerProfileId) {
      return false;
    }
    final l$runAfterCreate = runAfterCreate;
    final lOther$runAfterCreate = other.runAfterCreate;
    if (_$data.containsKey('runAfterCreate') !=
        other._$data.containsKey('runAfterCreate')) {
      return false;
    }
    if (l$runAfterCreate != lOther$runAfterCreate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$dastProfileSchedule = dastProfileSchedule;
    final l$name = name;
    final l$description = description;
    final l$branchName = branchName;
    final l$dastSiteProfileId = dastSiteProfileId;
    final l$dastScannerProfileId = dastScannerProfileId;
    final l$runAfterCreate = runAfterCreate;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      _$data.containsKey('dastProfileSchedule')
          ? l$dastProfileSchedule
          : const {},
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('branchName') ? l$branchName : const {},
      l$dastSiteProfileId,
      l$dastScannerProfileId,
      _$data.containsKey('runAfterCreate') ? l$runAfterCreate : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastProfileCreateInput<TRes> {
  factory CopyWith$Input$DastProfileCreateInput(
    Input$DastProfileCreateInput instance,
    TRes Function(Input$DastProfileCreateInput) then,
  ) = _CopyWithImpl$Input$DastProfileCreateInput;

  factory CopyWith$Input$DastProfileCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastProfileCreateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    Input$DastProfileScheduleInput? dastProfileSchedule,
    String? name,
    String? description,
    String? branchName,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
    bool? runAfterCreate,
  });
  CopyWith$Input$DastProfileScheduleInput<TRes> get dastProfileSchedule;
}

class _CopyWithImpl$Input$DastProfileCreateInput<TRes>
    implements CopyWith$Input$DastProfileCreateInput<TRes> {
  _CopyWithImpl$Input$DastProfileCreateInput(
    this._instance,
    this._then,
  );

  final Input$DastProfileCreateInput _instance;

  final TRes Function(Input$DastProfileCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? dastProfileSchedule = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? branchName = _undefined,
    Object? dastSiteProfileId = _undefined,
    Object? dastScannerProfileId = _undefined,
    Object? runAfterCreate = _undefined,
  }) =>
      _then(Input$DastProfileCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (dastProfileSchedule != _undefined)
          'dastProfileSchedule':
              (dastProfileSchedule as Input$DastProfileScheduleInput?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined) 'description': (description as String?),
        if (branchName != _undefined) 'branchName': (branchName as String?),
        if (dastSiteProfileId != _undefined && dastSiteProfileId != null)
          'dastSiteProfileId': (dastSiteProfileId as String),
        if (dastScannerProfileId != _undefined && dastScannerProfileId != null)
          'dastScannerProfileId': (dastScannerProfileId as String),
        if (runAfterCreate != _undefined)
          'runAfterCreate': (runAfterCreate as bool?),
      }));
  CopyWith$Input$DastProfileScheduleInput<TRes> get dastProfileSchedule {
    final local$dastProfileSchedule = _instance.dastProfileSchedule;
    return local$dastProfileSchedule == null
        ? CopyWith$Input$DastProfileScheduleInput.stub(_then(_instance))
        : CopyWith$Input$DastProfileScheduleInput(
            local$dastProfileSchedule, (e) => call(dastProfileSchedule: e));
  }
}

class _CopyWithStubImpl$Input$DastProfileCreateInput<TRes>
    implements CopyWith$Input$DastProfileCreateInput<TRes> {
  _CopyWithStubImpl$Input$DastProfileCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    Input$DastProfileScheduleInput? dastProfileSchedule,
    String? name,
    String? description,
    String? branchName,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
    bool? runAfterCreate,
  }) =>
      _res;
  CopyWith$Input$DastProfileScheduleInput<TRes> get dastProfileSchedule =>
      CopyWith$Input$DastProfileScheduleInput.stub(_res);
}

class Input$DastProfileDeleteInput {
  factory Input$DastProfileDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DastProfileDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DastProfileDeleteInput._(this._$data);

  factory Input$DastProfileDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DastProfileDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DastProfileDeleteInput<Input$DastProfileDeleteInput>
      get copyWith => CopyWith$Input$DastProfileDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastProfileDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DastProfileDeleteInput<TRes> {
  factory CopyWith$Input$DastProfileDeleteInput(
    Input$DastProfileDeleteInput instance,
    TRes Function(Input$DastProfileDeleteInput) then,
  ) = _CopyWithImpl$Input$DastProfileDeleteInput;

  factory CopyWith$Input$DastProfileDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastProfileDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DastProfileDeleteInput<TRes>
    implements CopyWith$Input$DastProfileDeleteInput<TRes> {
  _CopyWithImpl$Input$DastProfileDeleteInput(
    this._instance,
    this._then,
  );

  final Input$DastProfileDeleteInput _instance;

  final TRes Function(Input$DastProfileDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DastProfileDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DastProfileDeleteInput<TRes>
    implements CopyWith$Input$DastProfileDeleteInput<TRes> {
  _CopyWithStubImpl$Input$DastProfileDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DastProfileRunInput {
  factory Input$DastProfileRunInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DastProfileRunInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DastProfileRunInput._(this._$data);

  factory Input$DastProfileRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DastProfileRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DastProfileRunInput<Input$DastProfileRunInput> get copyWith =>
      CopyWith$Input$DastProfileRunInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastProfileRunInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DastProfileRunInput<TRes> {
  factory CopyWith$Input$DastProfileRunInput(
    Input$DastProfileRunInput instance,
    TRes Function(Input$DastProfileRunInput) then,
  ) = _CopyWithImpl$Input$DastProfileRunInput;

  factory CopyWith$Input$DastProfileRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastProfileRunInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DastProfileRunInput<TRes>
    implements CopyWith$Input$DastProfileRunInput<TRes> {
  _CopyWithImpl$Input$DastProfileRunInput(
    this._instance,
    this._then,
  );

  final Input$DastProfileRunInput _instance;

  final TRes Function(Input$DastProfileRunInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DastProfileRunInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DastProfileRunInput<TRes>
    implements CopyWith$Input$DastProfileRunInput<TRes> {
  _CopyWithStubImpl$Input$DastProfileRunInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DastProfileScheduleInput {
  factory Input$DastProfileScheduleInput({
    bool? active,
    String? startsAt,
    String? timezone,
    Input$DastProfileCadenceInput? cadence,
  }) =>
      Input$DastProfileScheduleInput._({
        if (active != null) r'active': active,
        if (startsAt != null) r'startsAt': startsAt,
        if (timezone != null) r'timezone': timezone,
        if (cadence != null) r'cadence': cadence,
      });

  Input$DastProfileScheduleInput._(this._$data);

  factory Input$DastProfileScheduleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    if (data.containsKey('startsAt')) {
      final l$startsAt = data['startsAt'];
      result$data['startsAt'] = (l$startsAt as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    if (data.containsKey('cadence')) {
      final l$cadence = data['cadence'];
      result$data['cadence'] = l$cadence == null
          ? null
          : Input$DastProfileCadenceInput.fromJson(
              (l$cadence as Map<String, dynamic>));
    }
    return Input$DastProfileScheduleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get active => (_$data['active'] as bool?);
  String? get startsAt => (_$data['startsAt'] as String?);
  String? get timezone => (_$data['timezone'] as String?);
  Input$DastProfileCadenceInput? get cadence =>
      (_$data['cadence'] as Input$DastProfileCadenceInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    if (_$data.containsKey('startsAt')) {
      final l$startsAt = startsAt;
      result$data['startsAt'] = l$startsAt;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    if (_$data.containsKey('cadence')) {
      final l$cadence = cadence;
      result$data['cadence'] = l$cadence?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DastProfileScheduleInput<Input$DastProfileScheduleInput>
      get copyWith => CopyWith$Input$DastProfileScheduleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastProfileScheduleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$startsAt = startsAt;
    final lOther$startsAt = other.startsAt;
    if (_$data.containsKey('startsAt') !=
        other._$data.containsKey('startsAt')) {
      return false;
    }
    if (l$startsAt != lOther$startsAt) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    final l$cadence = cadence;
    final lOther$cadence = other.cadence;
    if (_$data.containsKey('cadence') != other._$data.containsKey('cadence')) {
      return false;
    }
    if (l$cadence != lOther$cadence) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$active = active;
    final l$startsAt = startsAt;
    final l$timezone = timezone;
    final l$cadence = cadence;
    return Object.hashAll([
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('startsAt') ? l$startsAt : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
      _$data.containsKey('cadence') ? l$cadence : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastProfileScheduleInput<TRes> {
  factory CopyWith$Input$DastProfileScheduleInput(
    Input$DastProfileScheduleInput instance,
    TRes Function(Input$DastProfileScheduleInput) then,
  ) = _CopyWithImpl$Input$DastProfileScheduleInput;

  factory CopyWith$Input$DastProfileScheduleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastProfileScheduleInput;

  TRes call({
    bool? active,
    String? startsAt,
    String? timezone,
    Input$DastProfileCadenceInput? cadence,
  });
  CopyWith$Input$DastProfileCadenceInput<TRes> get cadence;
}

class _CopyWithImpl$Input$DastProfileScheduleInput<TRes>
    implements CopyWith$Input$DastProfileScheduleInput<TRes> {
  _CopyWithImpl$Input$DastProfileScheduleInput(
    this._instance,
    this._then,
  );

  final Input$DastProfileScheduleInput _instance;

  final TRes Function(Input$DastProfileScheduleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? active = _undefined,
    Object? startsAt = _undefined,
    Object? timezone = _undefined,
    Object? cadence = _undefined,
  }) =>
      _then(Input$DastProfileScheduleInput._({
        ..._instance._$data,
        if (active != _undefined) 'active': (active as bool?),
        if (startsAt != _undefined) 'startsAt': (startsAt as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
        if (cadence != _undefined)
          'cadence': (cadence as Input$DastProfileCadenceInput?),
      }));
  CopyWith$Input$DastProfileCadenceInput<TRes> get cadence {
    final local$cadence = _instance.cadence;
    return local$cadence == null
        ? CopyWith$Input$DastProfileCadenceInput.stub(_then(_instance))
        : CopyWith$Input$DastProfileCadenceInput(
            local$cadence, (e) => call(cadence: e));
  }
}

class _CopyWithStubImpl$Input$DastProfileScheduleInput<TRes>
    implements CopyWith$Input$DastProfileScheduleInput<TRes> {
  _CopyWithStubImpl$Input$DastProfileScheduleInput(this._res);

  TRes _res;

  call({
    bool? active,
    String? startsAt,
    String? timezone,
    Input$DastProfileCadenceInput? cadence,
  }) =>
      _res;
  CopyWith$Input$DastProfileCadenceInput<TRes> get cadence =>
      CopyWith$Input$DastProfileCadenceInput.stub(_res);
}

class Input$DastProfileUpdateInput {
  factory Input$DastProfileUpdateInput({
    String? clientMutationId,
    required String id,
    Input$DastProfileScheduleInput? dastProfileSchedule,
    String? name,
    String? description,
    String? branchName,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
    bool? runAfterUpdate,
  }) =>
      Input$DastProfileUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (dastProfileSchedule != null)
          r'dastProfileSchedule': dastProfileSchedule,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (branchName != null) r'branchName': branchName,
        if (dastSiteProfileId != null) r'dastSiteProfileId': dastSiteProfileId,
        if (dastScannerProfileId != null)
          r'dastScannerProfileId': dastScannerProfileId,
        if (runAfterUpdate != null) r'runAfterUpdate': runAfterUpdate,
      });

  Input$DastProfileUpdateInput._(this._$data);

  factory Input$DastProfileUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('dastProfileSchedule')) {
      final l$dastProfileSchedule = data['dastProfileSchedule'];
      result$data['dastProfileSchedule'] = l$dastProfileSchedule == null
          ? null
          : Input$DastProfileScheduleInput.fromJson(
              (l$dastProfileSchedule as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('branchName')) {
      final l$branchName = data['branchName'];
      result$data['branchName'] = (l$branchName as String?);
    }
    if (data.containsKey('dastSiteProfileId')) {
      final l$dastSiteProfileId = data['dastSiteProfileId'];
      result$data['dastSiteProfileId'] = (l$dastSiteProfileId as String?);
    }
    if (data.containsKey('dastScannerProfileId')) {
      final l$dastScannerProfileId = data['dastScannerProfileId'];
      result$data['dastScannerProfileId'] = (l$dastScannerProfileId as String?);
    }
    if (data.containsKey('runAfterUpdate')) {
      final l$runAfterUpdate = data['runAfterUpdate'];
      result$data['runAfterUpdate'] = (l$runAfterUpdate as bool?);
    }
    return Input$DastProfileUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Input$DastProfileScheduleInput? get dastProfileSchedule =>
      (_$data['dastProfileSchedule'] as Input$DastProfileScheduleInput?);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get branchName => (_$data['branchName'] as String?);
  String? get dastSiteProfileId => (_$data['dastSiteProfileId'] as String?);
  String? get dastScannerProfileId =>
      (_$data['dastScannerProfileId'] as String?);
  bool? get runAfterUpdate => (_$data['runAfterUpdate'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('dastProfileSchedule')) {
      final l$dastProfileSchedule = dastProfileSchedule;
      result$data['dastProfileSchedule'] = l$dastProfileSchedule?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('branchName')) {
      final l$branchName = branchName;
      result$data['branchName'] = l$branchName;
    }
    if (_$data.containsKey('dastSiteProfileId')) {
      final l$dastSiteProfileId = dastSiteProfileId;
      result$data['dastSiteProfileId'] = l$dastSiteProfileId;
    }
    if (_$data.containsKey('dastScannerProfileId')) {
      final l$dastScannerProfileId = dastScannerProfileId;
      result$data['dastScannerProfileId'] = l$dastScannerProfileId;
    }
    if (_$data.containsKey('runAfterUpdate')) {
      final l$runAfterUpdate = runAfterUpdate;
      result$data['runAfterUpdate'] = l$runAfterUpdate;
    }
    return result$data;
  }

  CopyWith$Input$DastProfileUpdateInput<Input$DastProfileUpdateInput>
      get copyWith => CopyWith$Input$DastProfileUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastProfileUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$dastProfileSchedule = dastProfileSchedule;
    final lOther$dastProfileSchedule = other.dastProfileSchedule;
    if (_$data.containsKey('dastProfileSchedule') !=
        other._$data.containsKey('dastProfileSchedule')) {
      return false;
    }
    if (l$dastProfileSchedule != lOther$dastProfileSchedule) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$branchName = branchName;
    final lOther$branchName = other.branchName;
    if (_$data.containsKey('branchName') !=
        other._$data.containsKey('branchName')) {
      return false;
    }
    if (l$branchName != lOther$branchName) {
      return false;
    }
    final l$dastSiteProfileId = dastSiteProfileId;
    final lOther$dastSiteProfileId = other.dastSiteProfileId;
    if (_$data.containsKey('dastSiteProfileId') !=
        other._$data.containsKey('dastSiteProfileId')) {
      return false;
    }
    if (l$dastSiteProfileId != lOther$dastSiteProfileId) {
      return false;
    }
    final l$dastScannerProfileId = dastScannerProfileId;
    final lOther$dastScannerProfileId = other.dastScannerProfileId;
    if (_$data.containsKey('dastScannerProfileId') !=
        other._$data.containsKey('dastScannerProfileId')) {
      return false;
    }
    if (l$dastScannerProfileId != lOther$dastScannerProfileId) {
      return false;
    }
    final l$runAfterUpdate = runAfterUpdate;
    final lOther$runAfterUpdate = other.runAfterUpdate;
    if (_$data.containsKey('runAfterUpdate') !=
        other._$data.containsKey('runAfterUpdate')) {
      return false;
    }
    if (l$runAfterUpdate != lOther$runAfterUpdate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$dastProfileSchedule = dastProfileSchedule;
    final l$name = name;
    final l$description = description;
    final l$branchName = branchName;
    final l$dastSiteProfileId = dastSiteProfileId;
    final l$dastScannerProfileId = dastScannerProfileId;
    final l$runAfterUpdate = runAfterUpdate;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('dastProfileSchedule')
          ? l$dastProfileSchedule
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('branchName') ? l$branchName : const {},
      _$data.containsKey('dastSiteProfileId') ? l$dastSiteProfileId : const {},
      _$data.containsKey('dastScannerProfileId')
          ? l$dastScannerProfileId
          : const {},
      _$data.containsKey('runAfterUpdate') ? l$runAfterUpdate : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastProfileUpdateInput<TRes> {
  factory CopyWith$Input$DastProfileUpdateInput(
    Input$DastProfileUpdateInput instance,
    TRes Function(Input$DastProfileUpdateInput) then,
  ) = _CopyWithImpl$Input$DastProfileUpdateInput;

  factory CopyWith$Input$DastProfileUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastProfileUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Input$DastProfileScheduleInput? dastProfileSchedule,
    String? name,
    String? description,
    String? branchName,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
    bool? runAfterUpdate,
  });
  CopyWith$Input$DastProfileScheduleInput<TRes> get dastProfileSchedule;
}

class _CopyWithImpl$Input$DastProfileUpdateInput<TRes>
    implements CopyWith$Input$DastProfileUpdateInput<TRes> {
  _CopyWithImpl$Input$DastProfileUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DastProfileUpdateInput _instance;

  final TRes Function(Input$DastProfileUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? dastProfileSchedule = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? branchName = _undefined,
    Object? dastSiteProfileId = _undefined,
    Object? dastScannerProfileId = _undefined,
    Object? runAfterUpdate = _undefined,
  }) =>
      _then(Input$DastProfileUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (dastProfileSchedule != _undefined)
          'dastProfileSchedule':
              (dastProfileSchedule as Input$DastProfileScheduleInput?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (branchName != _undefined) 'branchName': (branchName as String?),
        if (dastSiteProfileId != _undefined)
          'dastSiteProfileId': (dastSiteProfileId as String?),
        if (dastScannerProfileId != _undefined)
          'dastScannerProfileId': (dastScannerProfileId as String?),
        if (runAfterUpdate != _undefined)
          'runAfterUpdate': (runAfterUpdate as bool?),
      }));
  CopyWith$Input$DastProfileScheduleInput<TRes> get dastProfileSchedule {
    final local$dastProfileSchedule = _instance.dastProfileSchedule;
    return local$dastProfileSchedule == null
        ? CopyWith$Input$DastProfileScheduleInput.stub(_then(_instance))
        : CopyWith$Input$DastProfileScheduleInput(
            local$dastProfileSchedule, (e) => call(dastProfileSchedule: e));
  }
}

class _CopyWithStubImpl$Input$DastProfileUpdateInput<TRes>
    implements CopyWith$Input$DastProfileUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DastProfileUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Input$DastProfileScheduleInput? dastProfileSchedule,
    String? name,
    String? description,
    String? branchName,
    String? dastSiteProfileId,
    String? dastScannerProfileId,
    bool? runAfterUpdate,
  }) =>
      _res;
  CopyWith$Input$DastProfileScheduleInput<TRes> get dastProfileSchedule =>
      CopyWith$Input$DastProfileScheduleInput.stub(_res);
}

class Input$DastScannerProfileCreateInput {
  factory Input$DastScannerProfileCreateInput({
    String? clientMutationId,
    required String fullPath,
    required String profileName,
    int? spiderTimeout,
    int? targetTimeout,
    Enum$DastScanTypeEnum? scanType,
    bool? useAjaxSpider,
    bool? showDebugMessages,
  }) =>
      Input$DastScannerProfileCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        r'profileName': profileName,
        if (spiderTimeout != null) r'spiderTimeout': spiderTimeout,
        if (targetTimeout != null) r'targetTimeout': targetTimeout,
        if (scanType != null) r'scanType': scanType,
        if (useAjaxSpider != null) r'useAjaxSpider': useAjaxSpider,
        if (showDebugMessages != null) r'showDebugMessages': showDebugMessages,
      });

  Input$DastScannerProfileCreateInput._(this._$data);

  factory Input$DastScannerProfileCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    if (data.containsKey('spiderTimeout')) {
      final l$spiderTimeout = data['spiderTimeout'];
      result$data['spiderTimeout'] = (l$spiderTimeout as int?);
    }
    if (data.containsKey('targetTimeout')) {
      final l$targetTimeout = data['targetTimeout'];
      result$data['targetTimeout'] = (l$targetTimeout as int?);
    }
    if (data.containsKey('scanType')) {
      final l$scanType = data['scanType'];
      result$data['scanType'] = l$scanType == null
          ? null
          : fromJson$Enum$DastScanTypeEnum((l$scanType as String));
    }
    if (data.containsKey('useAjaxSpider')) {
      final l$useAjaxSpider = data['useAjaxSpider'];
      result$data['useAjaxSpider'] = (l$useAjaxSpider as bool?);
    }
    if (data.containsKey('showDebugMessages')) {
      final l$showDebugMessages = data['showDebugMessages'];
      result$data['showDebugMessages'] = (l$showDebugMessages as bool?);
    }
    return Input$DastScannerProfileCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  String get profileName => (_$data['profileName'] as String);
  int? get spiderTimeout => (_$data['spiderTimeout'] as int?);
  int? get targetTimeout => (_$data['targetTimeout'] as int?);
  Enum$DastScanTypeEnum? get scanType =>
      (_$data['scanType'] as Enum$DastScanTypeEnum?);
  bool? get useAjaxSpider => (_$data['useAjaxSpider'] as bool?);
  bool? get showDebugMessages => (_$data['showDebugMessages'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    if (_$data.containsKey('spiderTimeout')) {
      final l$spiderTimeout = spiderTimeout;
      result$data['spiderTimeout'] = l$spiderTimeout;
    }
    if (_$data.containsKey('targetTimeout')) {
      final l$targetTimeout = targetTimeout;
      result$data['targetTimeout'] = l$targetTimeout;
    }
    if (_$data.containsKey('scanType')) {
      final l$scanType = scanType;
      result$data['scanType'] =
          l$scanType == null ? null : toJson$Enum$DastScanTypeEnum(l$scanType);
    }
    if (_$data.containsKey('useAjaxSpider')) {
      final l$useAjaxSpider = useAjaxSpider;
      result$data['useAjaxSpider'] = l$useAjaxSpider;
    }
    if (_$data.containsKey('showDebugMessages')) {
      final l$showDebugMessages = showDebugMessages;
      result$data['showDebugMessages'] = l$showDebugMessages;
    }
    return result$data;
  }

  CopyWith$Input$DastScannerProfileCreateInput<
          Input$DastScannerProfileCreateInput>
      get copyWith => CopyWith$Input$DastScannerProfileCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastScannerProfileCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    final l$spiderTimeout = spiderTimeout;
    final lOther$spiderTimeout = other.spiderTimeout;
    if (_$data.containsKey('spiderTimeout') !=
        other._$data.containsKey('spiderTimeout')) {
      return false;
    }
    if (l$spiderTimeout != lOther$spiderTimeout) {
      return false;
    }
    final l$targetTimeout = targetTimeout;
    final lOther$targetTimeout = other.targetTimeout;
    if (_$data.containsKey('targetTimeout') !=
        other._$data.containsKey('targetTimeout')) {
      return false;
    }
    if (l$targetTimeout != lOther$targetTimeout) {
      return false;
    }
    final l$scanType = scanType;
    final lOther$scanType = other.scanType;
    if (_$data.containsKey('scanType') !=
        other._$data.containsKey('scanType')) {
      return false;
    }
    if (l$scanType != lOther$scanType) {
      return false;
    }
    final l$useAjaxSpider = useAjaxSpider;
    final lOther$useAjaxSpider = other.useAjaxSpider;
    if (_$data.containsKey('useAjaxSpider') !=
        other._$data.containsKey('useAjaxSpider')) {
      return false;
    }
    if (l$useAjaxSpider != lOther$useAjaxSpider) {
      return false;
    }
    final l$showDebugMessages = showDebugMessages;
    final lOther$showDebugMessages = other.showDebugMessages;
    if (_$data.containsKey('showDebugMessages') !=
        other._$data.containsKey('showDebugMessages')) {
      return false;
    }
    if (l$showDebugMessages != lOther$showDebugMessages) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$profileName = profileName;
    final l$spiderTimeout = spiderTimeout;
    final l$targetTimeout = targetTimeout;
    final l$scanType = scanType;
    final l$useAjaxSpider = useAjaxSpider;
    final l$showDebugMessages = showDebugMessages;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      l$profileName,
      _$data.containsKey('spiderTimeout') ? l$spiderTimeout : const {},
      _$data.containsKey('targetTimeout') ? l$targetTimeout : const {},
      _$data.containsKey('scanType') ? l$scanType : const {},
      _$data.containsKey('useAjaxSpider') ? l$useAjaxSpider : const {},
      _$data.containsKey('showDebugMessages') ? l$showDebugMessages : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastScannerProfileCreateInput<TRes> {
  factory CopyWith$Input$DastScannerProfileCreateInput(
    Input$DastScannerProfileCreateInput instance,
    TRes Function(Input$DastScannerProfileCreateInput) then,
  ) = _CopyWithImpl$Input$DastScannerProfileCreateInput;

  factory CopyWith$Input$DastScannerProfileCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastScannerProfileCreateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? profileName,
    int? spiderTimeout,
    int? targetTimeout,
    Enum$DastScanTypeEnum? scanType,
    bool? useAjaxSpider,
    bool? showDebugMessages,
  });
}

class _CopyWithImpl$Input$DastScannerProfileCreateInput<TRes>
    implements CopyWith$Input$DastScannerProfileCreateInput<TRes> {
  _CopyWithImpl$Input$DastScannerProfileCreateInput(
    this._instance,
    this._then,
  );

  final Input$DastScannerProfileCreateInput _instance;

  final TRes Function(Input$DastScannerProfileCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? profileName = _undefined,
    Object? spiderTimeout = _undefined,
    Object? targetTimeout = _undefined,
    Object? scanType = _undefined,
    Object? useAjaxSpider = _undefined,
    Object? showDebugMessages = _undefined,
  }) =>
      _then(Input$DastScannerProfileCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
        if (spiderTimeout != _undefined)
          'spiderTimeout': (spiderTimeout as int?),
        if (targetTimeout != _undefined)
          'targetTimeout': (targetTimeout as int?),
        if (scanType != _undefined)
          'scanType': (scanType as Enum$DastScanTypeEnum?),
        if (useAjaxSpider != _undefined)
          'useAjaxSpider': (useAjaxSpider as bool?),
        if (showDebugMessages != _undefined)
          'showDebugMessages': (showDebugMessages as bool?),
      }));
}

class _CopyWithStubImpl$Input$DastScannerProfileCreateInput<TRes>
    implements CopyWith$Input$DastScannerProfileCreateInput<TRes> {
  _CopyWithStubImpl$Input$DastScannerProfileCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? profileName,
    int? spiderTimeout,
    int? targetTimeout,
    Enum$DastScanTypeEnum? scanType,
    bool? useAjaxSpider,
    bool? showDebugMessages,
  }) =>
      _res;
}

class Input$DastScannerProfileDeleteInput {
  factory Input$DastScannerProfileDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DastScannerProfileDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DastScannerProfileDeleteInput._(this._$data);

  factory Input$DastScannerProfileDeleteInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DastScannerProfileDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DastScannerProfileDeleteInput<
          Input$DastScannerProfileDeleteInput>
      get copyWith => CopyWith$Input$DastScannerProfileDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastScannerProfileDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DastScannerProfileDeleteInput<TRes> {
  factory CopyWith$Input$DastScannerProfileDeleteInput(
    Input$DastScannerProfileDeleteInput instance,
    TRes Function(Input$DastScannerProfileDeleteInput) then,
  ) = _CopyWithImpl$Input$DastScannerProfileDeleteInput;

  factory CopyWith$Input$DastScannerProfileDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastScannerProfileDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DastScannerProfileDeleteInput<TRes>
    implements CopyWith$Input$DastScannerProfileDeleteInput<TRes> {
  _CopyWithImpl$Input$DastScannerProfileDeleteInput(
    this._instance,
    this._then,
  );

  final Input$DastScannerProfileDeleteInput _instance;

  final TRes Function(Input$DastScannerProfileDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DastScannerProfileDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DastScannerProfileDeleteInput<TRes>
    implements CopyWith$Input$DastScannerProfileDeleteInput<TRes> {
  _CopyWithStubImpl$Input$DastScannerProfileDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DastScannerProfileUpdateInput {
  factory Input$DastScannerProfileUpdateInput({
    String? clientMutationId,
    required String id,
    required String profileName,
    required int spiderTimeout,
    required int targetTimeout,
    Enum$DastScanTypeEnum? scanType,
    bool? useAjaxSpider,
    bool? showDebugMessages,
  }) =>
      Input$DastScannerProfileUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'profileName': profileName,
        r'spiderTimeout': spiderTimeout,
        r'targetTimeout': targetTimeout,
        if (scanType != null) r'scanType': scanType,
        if (useAjaxSpider != null) r'useAjaxSpider': useAjaxSpider,
        if (showDebugMessages != null) r'showDebugMessages': showDebugMessages,
      });

  Input$DastScannerProfileUpdateInput._(this._$data);

  factory Input$DastScannerProfileUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    final l$spiderTimeout = data['spiderTimeout'];
    result$data['spiderTimeout'] = (l$spiderTimeout as int);
    final l$targetTimeout = data['targetTimeout'];
    result$data['targetTimeout'] = (l$targetTimeout as int);
    if (data.containsKey('scanType')) {
      final l$scanType = data['scanType'];
      result$data['scanType'] = l$scanType == null
          ? null
          : fromJson$Enum$DastScanTypeEnum((l$scanType as String));
    }
    if (data.containsKey('useAjaxSpider')) {
      final l$useAjaxSpider = data['useAjaxSpider'];
      result$data['useAjaxSpider'] = (l$useAjaxSpider as bool?);
    }
    if (data.containsKey('showDebugMessages')) {
      final l$showDebugMessages = data['showDebugMessages'];
      result$data['showDebugMessages'] = (l$showDebugMessages as bool?);
    }
    return Input$DastScannerProfileUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String get profileName => (_$data['profileName'] as String);
  int get spiderTimeout => (_$data['spiderTimeout'] as int);
  int get targetTimeout => (_$data['targetTimeout'] as int);
  Enum$DastScanTypeEnum? get scanType =>
      (_$data['scanType'] as Enum$DastScanTypeEnum?);
  bool? get useAjaxSpider => (_$data['useAjaxSpider'] as bool?);
  bool? get showDebugMessages => (_$data['showDebugMessages'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    final l$spiderTimeout = spiderTimeout;
    result$data['spiderTimeout'] = l$spiderTimeout;
    final l$targetTimeout = targetTimeout;
    result$data['targetTimeout'] = l$targetTimeout;
    if (_$data.containsKey('scanType')) {
      final l$scanType = scanType;
      result$data['scanType'] =
          l$scanType == null ? null : toJson$Enum$DastScanTypeEnum(l$scanType);
    }
    if (_$data.containsKey('useAjaxSpider')) {
      final l$useAjaxSpider = useAjaxSpider;
      result$data['useAjaxSpider'] = l$useAjaxSpider;
    }
    if (_$data.containsKey('showDebugMessages')) {
      final l$showDebugMessages = showDebugMessages;
      result$data['showDebugMessages'] = l$showDebugMessages;
    }
    return result$data;
  }

  CopyWith$Input$DastScannerProfileUpdateInput<
          Input$DastScannerProfileUpdateInput>
      get copyWith => CopyWith$Input$DastScannerProfileUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastScannerProfileUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    final l$spiderTimeout = spiderTimeout;
    final lOther$spiderTimeout = other.spiderTimeout;
    if (l$spiderTimeout != lOther$spiderTimeout) {
      return false;
    }
    final l$targetTimeout = targetTimeout;
    final lOther$targetTimeout = other.targetTimeout;
    if (l$targetTimeout != lOther$targetTimeout) {
      return false;
    }
    final l$scanType = scanType;
    final lOther$scanType = other.scanType;
    if (_$data.containsKey('scanType') !=
        other._$data.containsKey('scanType')) {
      return false;
    }
    if (l$scanType != lOther$scanType) {
      return false;
    }
    final l$useAjaxSpider = useAjaxSpider;
    final lOther$useAjaxSpider = other.useAjaxSpider;
    if (_$data.containsKey('useAjaxSpider') !=
        other._$data.containsKey('useAjaxSpider')) {
      return false;
    }
    if (l$useAjaxSpider != lOther$useAjaxSpider) {
      return false;
    }
    final l$showDebugMessages = showDebugMessages;
    final lOther$showDebugMessages = other.showDebugMessages;
    if (_$data.containsKey('showDebugMessages') !=
        other._$data.containsKey('showDebugMessages')) {
      return false;
    }
    if (l$showDebugMessages != lOther$showDebugMessages) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$profileName = profileName;
    final l$spiderTimeout = spiderTimeout;
    final l$targetTimeout = targetTimeout;
    final l$scanType = scanType;
    final l$useAjaxSpider = useAjaxSpider;
    final l$showDebugMessages = showDebugMessages;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$profileName,
      l$spiderTimeout,
      l$targetTimeout,
      _$data.containsKey('scanType') ? l$scanType : const {},
      _$data.containsKey('useAjaxSpider') ? l$useAjaxSpider : const {},
      _$data.containsKey('showDebugMessages') ? l$showDebugMessages : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastScannerProfileUpdateInput<TRes> {
  factory CopyWith$Input$DastScannerProfileUpdateInput(
    Input$DastScannerProfileUpdateInput instance,
    TRes Function(Input$DastScannerProfileUpdateInput) then,
  ) = _CopyWithImpl$Input$DastScannerProfileUpdateInput;

  factory CopyWith$Input$DastScannerProfileUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastScannerProfileUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? profileName,
    int? spiderTimeout,
    int? targetTimeout,
    Enum$DastScanTypeEnum? scanType,
    bool? useAjaxSpider,
    bool? showDebugMessages,
  });
}

class _CopyWithImpl$Input$DastScannerProfileUpdateInput<TRes>
    implements CopyWith$Input$DastScannerProfileUpdateInput<TRes> {
  _CopyWithImpl$Input$DastScannerProfileUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DastScannerProfileUpdateInput _instance;

  final TRes Function(Input$DastScannerProfileUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? profileName = _undefined,
    Object? spiderTimeout = _undefined,
    Object? targetTimeout = _undefined,
    Object? scanType = _undefined,
    Object? useAjaxSpider = _undefined,
    Object? showDebugMessages = _undefined,
  }) =>
      _then(Input$DastScannerProfileUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
        if (spiderTimeout != _undefined && spiderTimeout != null)
          'spiderTimeout': (spiderTimeout as int),
        if (targetTimeout != _undefined && targetTimeout != null)
          'targetTimeout': (targetTimeout as int),
        if (scanType != _undefined)
          'scanType': (scanType as Enum$DastScanTypeEnum?),
        if (useAjaxSpider != _undefined)
          'useAjaxSpider': (useAjaxSpider as bool?),
        if (showDebugMessages != _undefined)
          'showDebugMessages': (showDebugMessages as bool?),
      }));
}

class _CopyWithStubImpl$Input$DastScannerProfileUpdateInput<TRes>
    implements CopyWith$Input$DastScannerProfileUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DastScannerProfileUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? profileName,
    int? spiderTimeout,
    int? targetTimeout,
    Enum$DastScanTypeEnum? scanType,
    bool? useAjaxSpider,
    bool? showDebugMessages,
  }) =>
      _res;
}

class Input$DastSiteProfileAuthInput {
  factory Input$DastSiteProfileAuthInput({
    bool? enabled,
    String? url,
    String? usernameField,
    String? passwordField,
    String? username,
    String? password,
    String? submitField,
  }) =>
      Input$DastSiteProfileAuthInput._({
        if (enabled != null) r'enabled': enabled,
        if (url != null) r'url': url,
        if (usernameField != null) r'usernameField': usernameField,
        if (passwordField != null) r'passwordField': passwordField,
        if (username != null) r'username': username,
        if (password != null) r'password': password,
        if (submitField != null) r'submitField': submitField,
      });

  Input$DastSiteProfileAuthInput._(this._$data);

  factory Input$DastSiteProfileAuthInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('enabled')) {
      final l$enabled = data['enabled'];
      result$data['enabled'] = (l$enabled as bool?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('usernameField')) {
      final l$usernameField = data['usernameField'];
      result$data['usernameField'] = (l$usernameField as String?);
    }
    if (data.containsKey('passwordField')) {
      final l$passwordField = data['passwordField'];
      result$data['passwordField'] = (l$passwordField as String?);
    }
    if (data.containsKey('username')) {
      final l$username = data['username'];
      result$data['username'] = (l$username as String?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as String?);
    }
    if (data.containsKey('submitField')) {
      final l$submitField = data['submitField'];
      result$data['submitField'] = (l$submitField as String?);
    }
    return Input$DastSiteProfileAuthInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get enabled => (_$data['enabled'] as bool?);
  String? get url => (_$data['url'] as String?);
  String? get usernameField => (_$data['usernameField'] as String?);
  String? get passwordField => (_$data['passwordField'] as String?);
  String? get username => (_$data['username'] as String?);
  String? get password => (_$data['password'] as String?);
  String? get submitField => (_$data['submitField'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('enabled')) {
      final l$enabled = enabled;
      result$data['enabled'] = l$enabled;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('usernameField')) {
      final l$usernameField = usernameField;
      result$data['usernameField'] = l$usernameField;
    }
    if (_$data.containsKey('passwordField')) {
      final l$passwordField = passwordField;
      result$data['passwordField'] = l$passwordField;
    }
    if (_$data.containsKey('username')) {
      final l$username = username;
      result$data['username'] = l$username;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('submitField')) {
      final l$submitField = submitField;
      result$data['submitField'] = l$submitField;
    }
    return result$data;
  }

  CopyWith$Input$DastSiteProfileAuthInput<Input$DastSiteProfileAuthInput>
      get copyWith => CopyWith$Input$DastSiteProfileAuthInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteProfileAuthInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (_$data.containsKey('enabled') != other._$data.containsKey('enabled')) {
      return false;
    }
    if (l$enabled != lOther$enabled) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$usernameField = usernameField;
    final lOther$usernameField = other.usernameField;
    if (_$data.containsKey('usernameField') !=
        other._$data.containsKey('usernameField')) {
      return false;
    }
    if (l$usernameField != lOther$usernameField) {
      return false;
    }
    final l$passwordField = passwordField;
    final lOther$passwordField = other.passwordField;
    if (_$data.containsKey('passwordField') !=
        other._$data.containsKey('passwordField')) {
      return false;
    }
    if (l$passwordField != lOther$passwordField) {
      return false;
    }
    final l$username = username;
    final lOther$username = other.username;
    if (_$data.containsKey('username') !=
        other._$data.containsKey('username')) {
      return false;
    }
    if (l$username != lOther$username) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$submitField = submitField;
    final lOther$submitField = other.submitField;
    if (_$data.containsKey('submitField') !=
        other._$data.containsKey('submitField')) {
      return false;
    }
    if (l$submitField != lOther$submitField) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enabled = enabled;
    final l$url = url;
    final l$usernameField = usernameField;
    final l$passwordField = passwordField;
    final l$username = username;
    final l$password = password;
    final l$submitField = submitField;
    return Object.hashAll([
      _$data.containsKey('enabled') ? l$enabled : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('usernameField') ? l$usernameField : const {},
      _$data.containsKey('passwordField') ? l$passwordField : const {},
      _$data.containsKey('username') ? l$username : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('submitField') ? l$submitField : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastSiteProfileAuthInput<TRes> {
  factory CopyWith$Input$DastSiteProfileAuthInput(
    Input$DastSiteProfileAuthInput instance,
    TRes Function(Input$DastSiteProfileAuthInput) then,
  ) = _CopyWithImpl$Input$DastSiteProfileAuthInput;

  factory CopyWith$Input$DastSiteProfileAuthInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteProfileAuthInput;

  TRes call({
    bool? enabled,
    String? url,
    String? usernameField,
    String? passwordField,
    String? username,
    String? password,
    String? submitField,
  });
}

class _CopyWithImpl$Input$DastSiteProfileAuthInput<TRes>
    implements CopyWith$Input$DastSiteProfileAuthInput<TRes> {
  _CopyWithImpl$Input$DastSiteProfileAuthInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteProfileAuthInput _instance;

  final TRes Function(Input$DastSiteProfileAuthInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? enabled = _undefined,
    Object? url = _undefined,
    Object? usernameField = _undefined,
    Object? passwordField = _undefined,
    Object? username = _undefined,
    Object? password = _undefined,
    Object? submitField = _undefined,
  }) =>
      _then(Input$DastSiteProfileAuthInput._({
        ..._instance._$data,
        if (enabled != _undefined) 'enabled': (enabled as bool?),
        if (url != _undefined) 'url': (url as String?),
        if (usernameField != _undefined)
          'usernameField': (usernameField as String?),
        if (passwordField != _undefined)
          'passwordField': (passwordField as String?),
        if (username != _undefined) 'username': (username as String?),
        if (password != _undefined) 'password': (password as String?),
        if (submitField != _undefined) 'submitField': (submitField as String?),
      }));
}

class _CopyWithStubImpl$Input$DastSiteProfileAuthInput<TRes>
    implements CopyWith$Input$DastSiteProfileAuthInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteProfileAuthInput(this._res);

  TRes _res;

  call({
    bool? enabled,
    String? url,
    String? usernameField,
    String? passwordField,
    String? username,
    String? password,
    String? submitField,
  }) =>
      _res;
}

class Input$DastSiteProfileCreateInput {
  factory Input$DastSiteProfileCreateInput({
    String? clientMutationId,
    required String profileName,
    String? targetUrl,
    Enum$DastTargetTypeEnum? targetType,
    Enum$DastScanMethodType? scanMethod,
    String? requestHeaders,
    Input$DastSiteProfileAuthInput? auth,
    required String fullPath,
    List<String>? excludedUrls,
  }) =>
      Input$DastSiteProfileCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'profileName': profileName,
        if (targetUrl != null) r'targetUrl': targetUrl,
        if (targetType != null) r'targetType': targetType,
        if (scanMethod != null) r'scanMethod': scanMethod,
        if (requestHeaders != null) r'requestHeaders': requestHeaders,
        if (auth != null) r'auth': auth,
        r'fullPath': fullPath,
        if (excludedUrls != null) r'excludedUrls': excludedUrls,
      });

  Input$DastSiteProfileCreateInput._(this._$data);

  factory Input$DastSiteProfileCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    if (data.containsKey('targetType')) {
      final l$targetType = data['targetType'];
      result$data['targetType'] = l$targetType == null
          ? null
          : fromJson$Enum$DastTargetTypeEnum((l$targetType as String));
    }
    if (data.containsKey('scanMethod')) {
      final l$scanMethod = data['scanMethod'];
      result$data['scanMethod'] = l$scanMethod == null
          ? null
          : fromJson$Enum$DastScanMethodType((l$scanMethod as String));
    }
    if (data.containsKey('requestHeaders')) {
      final l$requestHeaders = data['requestHeaders'];
      result$data['requestHeaders'] = (l$requestHeaders as String?);
    }
    if (data.containsKey('auth')) {
      final l$auth = data['auth'];
      result$data['auth'] = l$auth == null
          ? null
          : Input$DastSiteProfileAuthInput.fromJson(
              (l$auth as Map<String, dynamic>));
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    if (data.containsKey('excludedUrls')) {
      final l$excludedUrls = data['excludedUrls'];
      result$data['excludedUrls'] = (l$excludedUrls as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$DastSiteProfileCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get profileName => (_$data['profileName'] as String);
  String? get targetUrl => (_$data['targetUrl'] as String?);
  Enum$DastTargetTypeEnum? get targetType =>
      (_$data['targetType'] as Enum$DastTargetTypeEnum?);
  Enum$DastScanMethodType? get scanMethod =>
      (_$data['scanMethod'] as Enum$DastScanMethodType?);
  String? get requestHeaders => (_$data['requestHeaders'] as String?);
  Input$DastSiteProfileAuthInput? get auth =>
      (_$data['auth'] as Input$DastSiteProfileAuthInput?);
  String get fullPath => (_$data['fullPath'] as String);
  List<String>? get excludedUrls => (_$data['excludedUrls'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    if (_$data.containsKey('targetType')) {
      final l$targetType = targetType;
      result$data['targetType'] = l$targetType == null
          ? null
          : toJson$Enum$DastTargetTypeEnum(l$targetType);
    }
    if (_$data.containsKey('scanMethod')) {
      final l$scanMethod = scanMethod;
      result$data['scanMethod'] = l$scanMethod == null
          ? null
          : toJson$Enum$DastScanMethodType(l$scanMethod);
    }
    if (_$data.containsKey('requestHeaders')) {
      final l$requestHeaders = requestHeaders;
      result$data['requestHeaders'] = l$requestHeaders;
    }
    if (_$data.containsKey('auth')) {
      final l$auth = auth;
      result$data['auth'] = l$auth?.toJson();
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    if (_$data.containsKey('excludedUrls')) {
      final l$excludedUrls = excludedUrls;
      result$data['excludedUrls'] = l$excludedUrls?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$DastSiteProfileCreateInput<Input$DastSiteProfileCreateInput>
      get copyWith => CopyWith$Input$DastSiteProfileCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteProfileCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    final l$targetType = targetType;
    final lOther$targetType = other.targetType;
    if (_$data.containsKey('targetType') !=
        other._$data.containsKey('targetType')) {
      return false;
    }
    if (l$targetType != lOther$targetType) {
      return false;
    }
    final l$scanMethod = scanMethod;
    final lOther$scanMethod = other.scanMethod;
    if (_$data.containsKey('scanMethod') !=
        other._$data.containsKey('scanMethod')) {
      return false;
    }
    if (l$scanMethod != lOther$scanMethod) {
      return false;
    }
    final l$requestHeaders = requestHeaders;
    final lOther$requestHeaders = other.requestHeaders;
    if (_$data.containsKey('requestHeaders') !=
        other._$data.containsKey('requestHeaders')) {
      return false;
    }
    if (l$requestHeaders != lOther$requestHeaders) {
      return false;
    }
    final l$auth = auth;
    final lOther$auth = other.auth;
    if (_$data.containsKey('auth') != other._$data.containsKey('auth')) {
      return false;
    }
    if (l$auth != lOther$auth) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$excludedUrls = excludedUrls;
    final lOther$excludedUrls = other.excludedUrls;
    if (_$data.containsKey('excludedUrls') !=
        other._$data.containsKey('excludedUrls')) {
      return false;
    }
    if (l$excludedUrls != null && lOther$excludedUrls != null) {
      if (l$excludedUrls.length != lOther$excludedUrls.length) {
        return false;
      }
      for (int i = 0; i < l$excludedUrls.length; i++) {
        final l$excludedUrls$entry = l$excludedUrls[i];
        final lOther$excludedUrls$entry = lOther$excludedUrls[i];
        if (l$excludedUrls$entry != lOther$excludedUrls$entry) {
          return false;
        }
      }
    } else if (l$excludedUrls != lOther$excludedUrls) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$profileName = profileName;
    final l$targetUrl = targetUrl;
    final l$targetType = targetType;
    final l$scanMethod = scanMethod;
    final l$requestHeaders = requestHeaders;
    final l$auth = auth;
    final l$fullPath = fullPath;
    final l$excludedUrls = excludedUrls;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$profileName,
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
      _$data.containsKey('targetType') ? l$targetType : const {},
      _$data.containsKey('scanMethod') ? l$scanMethod : const {},
      _$data.containsKey('requestHeaders') ? l$requestHeaders : const {},
      _$data.containsKey('auth') ? l$auth : const {},
      l$fullPath,
      _$data.containsKey('excludedUrls')
          ? l$excludedUrls == null
              ? null
              : Object.hashAll(l$excludedUrls.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastSiteProfileCreateInput<TRes> {
  factory CopyWith$Input$DastSiteProfileCreateInput(
    Input$DastSiteProfileCreateInput instance,
    TRes Function(Input$DastSiteProfileCreateInput) then,
  ) = _CopyWithImpl$Input$DastSiteProfileCreateInput;

  factory CopyWith$Input$DastSiteProfileCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteProfileCreateInput;

  TRes call({
    String? clientMutationId,
    String? profileName,
    String? targetUrl,
    Enum$DastTargetTypeEnum? targetType,
    Enum$DastScanMethodType? scanMethod,
    String? requestHeaders,
    Input$DastSiteProfileAuthInput? auth,
    String? fullPath,
    List<String>? excludedUrls,
  });
  CopyWith$Input$DastSiteProfileAuthInput<TRes> get auth;
}

class _CopyWithImpl$Input$DastSiteProfileCreateInput<TRes>
    implements CopyWith$Input$DastSiteProfileCreateInput<TRes> {
  _CopyWithImpl$Input$DastSiteProfileCreateInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteProfileCreateInput _instance;

  final TRes Function(Input$DastSiteProfileCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? profileName = _undefined,
    Object? targetUrl = _undefined,
    Object? targetType = _undefined,
    Object? scanMethod = _undefined,
    Object? requestHeaders = _undefined,
    Object? auth = _undefined,
    Object? fullPath = _undefined,
    Object? excludedUrls = _undefined,
  }) =>
      _then(Input$DastSiteProfileCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
        if (targetType != _undefined)
          'targetType': (targetType as Enum$DastTargetTypeEnum?),
        if (scanMethod != _undefined)
          'scanMethod': (scanMethod as Enum$DastScanMethodType?),
        if (requestHeaders != _undefined)
          'requestHeaders': (requestHeaders as String?),
        if (auth != _undefined)
          'auth': (auth as Input$DastSiteProfileAuthInput?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (excludedUrls != _undefined)
          'excludedUrls': (excludedUrls as List<String>?),
      }));
  CopyWith$Input$DastSiteProfileAuthInput<TRes> get auth {
    final local$auth = _instance.auth;
    return local$auth == null
        ? CopyWith$Input$DastSiteProfileAuthInput.stub(_then(_instance))
        : CopyWith$Input$DastSiteProfileAuthInput(
            local$auth, (e) => call(auth: e));
  }
}

class _CopyWithStubImpl$Input$DastSiteProfileCreateInput<TRes>
    implements CopyWith$Input$DastSiteProfileCreateInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteProfileCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? profileName,
    String? targetUrl,
    Enum$DastTargetTypeEnum? targetType,
    Enum$DastScanMethodType? scanMethod,
    String? requestHeaders,
    Input$DastSiteProfileAuthInput? auth,
    String? fullPath,
    List<String>? excludedUrls,
  }) =>
      _res;
  CopyWith$Input$DastSiteProfileAuthInput<TRes> get auth =>
      CopyWith$Input$DastSiteProfileAuthInput.stub(_res);
}

class Input$DastSiteProfileDeleteInput {
  factory Input$DastSiteProfileDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DastSiteProfileDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DastSiteProfileDeleteInput._(this._$data);

  factory Input$DastSiteProfileDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DastSiteProfileDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DastSiteProfileDeleteInput<Input$DastSiteProfileDeleteInput>
      get copyWith => CopyWith$Input$DastSiteProfileDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteProfileDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DastSiteProfileDeleteInput<TRes> {
  factory CopyWith$Input$DastSiteProfileDeleteInput(
    Input$DastSiteProfileDeleteInput instance,
    TRes Function(Input$DastSiteProfileDeleteInput) then,
  ) = _CopyWithImpl$Input$DastSiteProfileDeleteInput;

  factory CopyWith$Input$DastSiteProfileDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteProfileDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DastSiteProfileDeleteInput<TRes>
    implements CopyWith$Input$DastSiteProfileDeleteInput<TRes> {
  _CopyWithImpl$Input$DastSiteProfileDeleteInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteProfileDeleteInput _instance;

  final TRes Function(Input$DastSiteProfileDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DastSiteProfileDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DastSiteProfileDeleteInput<TRes>
    implements CopyWith$Input$DastSiteProfileDeleteInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteProfileDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DastSiteProfileUpdateInput {
  factory Input$DastSiteProfileUpdateInput({
    String? clientMutationId,
    required String profileName,
    String? targetUrl,
    Enum$DastTargetTypeEnum? targetType,
    Enum$DastScanMethodType? scanMethod,
    String? requestHeaders,
    Input$DastSiteProfileAuthInput? auth,
    required String id,
    List<String>? excludedUrls,
  }) =>
      Input$DastSiteProfileUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'profileName': profileName,
        if (targetUrl != null) r'targetUrl': targetUrl,
        if (targetType != null) r'targetType': targetType,
        if (scanMethod != null) r'scanMethod': scanMethod,
        if (requestHeaders != null) r'requestHeaders': requestHeaders,
        if (auth != null) r'auth': auth,
        r'id': id,
        if (excludedUrls != null) r'excludedUrls': excludedUrls,
      });

  Input$DastSiteProfileUpdateInput._(this._$data);

  factory Input$DastSiteProfileUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    if (data.containsKey('targetType')) {
      final l$targetType = data['targetType'];
      result$data['targetType'] = l$targetType == null
          ? null
          : fromJson$Enum$DastTargetTypeEnum((l$targetType as String));
    }
    if (data.containsKey('scanMethod')) {
      final l$scanMethod = data['scanMethod'];
      result$data['scanMethod'] = l$scanMethod == null
          ? null
          : fromJson$Enum$DastScanMethodType((l$scanMethod as String));
    }
    if (data.containsKey('requestHeaders')) {
      final l$requestHeaders = data['requestHeaders'];
      result$data['requestHeaders'] = (l$requestHeaders as String?);
    }
    if (data.containsKey('auth')) {
      final l$auth = data['auth'];
      result$data['auth'] = l$auth == null
          ? null
          : Input$DastSiteProfileAuthInput.fromJson(
              (l$auth as Map<String, dynamic>));
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('excludedUrls')) {
      final l$excludedUrls = data['excludedUrls'];
      result$data['excludedUrls'] = (l$excludedUrls as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$DastSiteProfileUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get profileName => (_$data['profileName'] as String);
  String? get targetUrl => (_$data['targetUrl'] as String?);
  Enum$DastTargetTypeEnum? get targetType =>
      (_$data['targetType'] as Enum$DastTargetTypeEnum?);
  Enum$DastScanMethodType? get scanMethod =>
      (_$data['scanMethod'] as Enum$DastScanMethodType?);
  String? get requestHeaders => (_$data['requestHeaders'] as String?);
  Input$DastSiteProfileAuthInput? get auth =>
      (_$data['auth'] as Input$DastSiteProfileAuthInput?);
  String get id => (_$data['id'] as String);
  List<String>? get excludedUrls => (_$data['excludedUrls'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    if (_$data.containsKey('targetType')) {
      final l$targetType = targetType;
      result$data['targetType'] = l$targetType == null
          ? null
          : toJson$Enum$DastTargetTypeEnum(l$targetType);
    }
    if (_$data.containsKey('scanMethod')) {
      final l$scanMethod = scanMethod;
      result$data['scanMethod'] = l$scanMethod == null
          ? null
          : toJson$Enum$DastScanMethodType(l$scanMethod);
    }
    if (_$data.containsKey('requestHeaders')) {
      final l$requestHeaders = requestHeaders;
      result$data['requestHeaders'] = l$requestHeaders;
    }
    if (_$data.containsKey('auth')) {
      final l$auth = auth;
      result$data['auth'] = l$auth?.toJson();
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('excludedUrls')) {
      final l$excludedUrls = excludedUrls;
      result$data['excludedUrls'] = l$excludedUrls?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$DastSiteProfileUpdateInput<Input$DastSiteProfileUpdateInput>
      get copyWith => CopyWith$Input$DastSiteProfileUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteProfileUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    final l$targetType = targetType;
    final lOther$targetType = other.targetType;
    if (_$data.containsKey('targetType') !=
        other._$data.containsKey('targetType')) {
      return false;
    }
    if (l$targetType != lOther$targetType) {
      return false;
    }
    final l$scanMethod = scanMethod;
    final lOther$scanMethod = other.scanMethod;
    if (_$data.containsKey('scanMethod') !=
        other._$data.containsKey('scanMethod')) {
      return false;
    }
    if (l$scanMethod != lOther$scanMethod) {
      return false;
    }
    final l$requestHeaders = requestHeaders;
    final lOther$requestHeaders = other.requestHeaders;
    if (_$data.containsKey('requestHeaders') !=
        other._$data.containsKey('requestHeaders')) {
      return false;
    }
    if (l$requestHeaders != lOther$requestHeaders) {
      return false;
    }
    final l$auth = auth;
    final lOther$auth = other.auth;
    if (_$data.containsKey('auth') != other._$data.containsKey('auth')) {
      return false;
    }
    if (l$auth != lOther$auth) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$excludedUrls = excludedUrls;
    final lOther$excludedUrls = other.excludedUrls;
    if (_$data.containsKey('excludedUrls') !=
        other._$data.containsKey('excludedUrls')) {
      return false;
    }
    if (l$excludedUrls != null && lOther$excludedUrls != null) {
      if (l$excludedUrls.length != lOther$excludedUrls.length) {
        return false;
      }
      for (int i = 0; i < l$excludedUrls.length; i++) {
        final l$excludedUrls$entry = l$excludedUrls[i];
        final lOther$excludedUrls$entry = lOther$excludedUrls[i];
        if (l$excludedUrls$entry != lOther$excludedUrls$entry) {
          return false;
        }
      }
    } else if (l$excludedUrls != lOther$excludedUrls) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$profileName = profileName;
    final l$targetUrl = targetUrl;
    final l$targetType = targetType;
    final l$scanMethod = scanMethod;
    final l$requestHeaders = requestHeaders;
    final l$auth = auth;
    final l$id = id;
    final l$excludedUrls = excludedUrls;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$profileName,
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
      _$data.containsKey('targetType') ? l$targetType : const {},
      _$data.containsKey('scanMethod') ? l$scanMethod : const {},
      _$data.containsKey('requestHeaders') ? l$requestHeaders : const {},
      _$data.containsKey('auth') ? l$auth : const {},
      l$id,
      _$data.containsKey('excludedUrls')
          ? l$excludedUrls == null
              ? null
              : Object.hashAll(l$excludedUrls.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastSiteProfileUpdateInput<TRes> {
  factory CopyWith$Input$DastSiteProfileUpdateInput(
    Input$DastSiteProfileUpdateInput instance,
    TRes Function(Input$DastSiteProfileUpdateInput) then,
  ) = _CopyWithImpl$Input$DastSiteProfileUpdateInput;

  factory CopyWith$Input$DastSiteProfileUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteProfileUpdateInput;

  TRes call({
    String? clientMutationId,
    String? profileName,
    String? targetUrl,
    Enum$DastTargetTypeEnum? targetType,
    Enum$DastScanMethodType? scanMethod,
    String? requestHeaders,
    Input$DastSiteProfileAuthInput? auth,
    String? id,
    List<String>? excludedUrls,
  });
  CopyWith$Input$DastSiteProfileAuthInput<TRes> get auth;
}

class _CopyWithImpl$Input$DastSiteProfileUpdateInput<TRes>
    implements CopyWith$Input$DastSiteProfileUpdateInput<TRes> {
  _CopyWithImpl$Input$DastSiteProfileUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteProfileUpdateInput _instance;

  final TRes Function(Input$DastSiteProfileUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? profileName = _undefined,
    Object? targetUrl = _undefined,
    Object? targetType = _undefined,
    Object? scanMethod = _undefined,
    Object? requestHeaders = _undefined,
    Object? auth = _undefined,
    Object? id = _undefined,
    Object? excludedUrls = _undefined,
  }) =>
      _then(Input$DastSiteProfileUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
        if (targetType != _undefined)
          'targetType': (targetType as Enum$DastTargetTypeEnum?),
        if (scanMethod != _undefined)
          'scanMethod': (scanMethod as Enum$DastScanMethodType?),
        if (requestHeaders != _undefined)
          'requestHeaders': (requestHeaders as String?),
        if (auth != _undefined)
          'auth': (auth as Input$DastSiteProfileAuthInput?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (excludedUrls != _undefined)
          'excludedUrls': (excludedUrls as List<String>?),
      }));
  CopyWith$Input$DastSiteProfileAuthInput<TRes> get auth {
    final local$auth = _instance.auth;
    return local$auth == null
        ? CopyWith$Input$DastSiteProfileAuthInput.stub(_then(_instance))
        : CopyWith$Input$DastSiteProfileAuthInput(
            local$auth, (e) => call(auth: e));
  }
}

class _CopyWithStubImpl$Input$DastSiteProfileUpdateInput<TRes>
    implements CopyWith$Input$DastSiteProfileUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteProfileUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? profileName,
    String? targetUrl,
    Enum$DastTargetTypeEnum? targetType,
    Enum$DastScanMethodType? scanMethod,
    String? requestHeaders,
    Input$DastSiteProfileAuthInput? auth,
    String? id,
    List<String>? excludedUrls,
  }) =>
      _res;
  CopyWith$Input$DastSiteProfileAuthInput<TRes> get auth =>
      CopyWith$Input$DastSiteProfileAuthInput.stub(_res);
}

class Input$DastSiteTokenCreateInput {
  factory Input$DastSiteTokenCreateInput({
    String? clientMutationId,
    required String fullPath,
    String? targetUrl,
  }) =>
      Input$DastSiteTokenCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        if (targetUrl != null) r'targetUrl': targetUrl,
      });

  Input$DastSiteTokenCreateInput._(this._$data);

  factory Input$DastSiteTokenCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    return Input$DastSiteTokenCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  String? get targetUrl => (_$data['targetUrl'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    return result$data;
  }

  CopyWith$Input$DastSiteTokenCreateInput<Input$DastSiteTokenCreateInput>
      get copyWith => CopyWith$Input$DastSiteTokenCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteTokenCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$targetUrl = targetUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastSiteTokenCreateInput<TRes> {
  factory CopyWith$Input$DastSiteTokenCreateInput(
    Input$DastSiteTokenCreateInput instance,
    TRes Function(Input$DastSiteTokenCreateInput) then,
  ) = _CopyWithImpl$Input$DastSiteTokenCreateInput;

  factory CopyWith$Input$DastSiteTokenCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteTokenCreateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? targetUrl,
  });
}

class _CopyWithImpl$Input$DastSiteTokenCreateInput<TRes>
    implements CopyWith$Input$DastSiteTokenCreateInput<TRes> {
  _CopyWithImpl$Input$DastSiteTokenCreateInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteTokenCreateInput _instance;

  final TRes Function(Input$DastSiteTokenCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? targetUrl = _undefined,
  }) =>
      _then(Input$DastSiteTokenCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$DastSiteTokenCreateInput<TRes>
    implements CopyWith$Input$DastSiteTokenCreateInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteTokenCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? targetUrl,
  }) =>
      _res;
}

class Input$DastSiteValidationCreateInput {
  factory Input$DastSiteValidationCreateInput({
    String? clientMutationId,
    required String fullPath,
    required String dastSiteTokenId,
    required String validationPath,
    Enum$DastSiteValidationStrategyEnum? strategy,
  }) =>
      Input$DastSiteValidationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        r'dastSiteTokenId': dastSiteTokenId,
        r'validationPath': validationPath,
        if (strategy != null) r'strategy': strategy,
      });

  Input$DastSiteValidationCreateInput._(this._$data);

  factory Input$DastSiteValidationCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    final l$dastSiteTokenId = data['dastSiteTokenId'];
    result$data['dastSiteTokenId'] = (l$dastSiteTokenId as String);
    final l$validationPath = data['validationPath'];
    result$data['validationPath'] = (l$validationPath as String);
    if (data.containsKey('strategy')) {
      final l$strategy = data['strategy'];
      result$data['strategy'] = l$strategy == null
          ? null
          : fromJson$Enum$DastSiteValidationStrategyEnum(
              (l$strategy as String));
    }
    return Input$DastSiteValidationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  String get dastSiteTokenId => (_$data['dastSiteTokenId'] as String);
  String get validationPath => (_$data['validationPath'] as String);
  Enum$DastSiteValidationStrategyEnum? get strategy =>
      (_$data['strategy'] as Enum$DastSiteValidationStrategyEnum?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    final l$dastSiteTokenId = dastSiteTokenId;
    result$data['dastSiteTokenId'] = l$dastSiteTokenId;
    final l$validationPath = validationPath;
    result$data['validationPath'] = l$validationPath;
    if (_$data.containsKey('strategy')) {
      final l$strategy = strategy;
      result$data['strategy'] = l$strategy == null
          ? null
          : toJson$Enum$DastSiteValidationStrategyEnum(l$strategy);
    }
    return result$data;
  }

  CopyWith$Input$DastSiteValidationCreateInput<
          Input$DastSiteValidationCreateInput>
      get copyWith => CopyWith$Input$DastSiteValidationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteValidationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$dastSiteTokenId = dastSiteTokenId;
    final lOther$dastSiteTokenId = other.dastSiteTokenId;
    if (l$dastSiteTokenId != lOther$dastSiteTokenId) {
      return false;
    }
    final l$validationPath = validationPath;
    final lOther$validationPath = other.validationPath;
    if (l$validationPath != lOther$validationPath) {
      return false;
    }
    final l$strategy = strategy;
    final lOther$strategy = other.strategy;
    if (_$data.containsKey('strategy') !=
        other._$data.containsKey('strategy')) {
      return false;
    }
    if (l$strategy != lOther$strategy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$dastSiteTokenId = dastSiteTokenId;
    final l$validationPath = validationPath;
    final l$strategy = strategy;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      l$dastSiteTokenId,
      l$validationPath,
      _$data.containsKey('strategy') ? l$strategy : const {},
    ]);
  }
}

abstract class CopyWith$Input$DastSiteValidationCreateInput<TRes> {
  factory CopyWith$Input$DastSiteValidationCreateInput(
    Input$DastSiteValidationCreateInput instance,
    TRes Function(Input$DastSiteValidationCreateInput) then,
  ) = _CopyWithImpl$Input$DastSiteValidationCreateInput;

  factory CopyWith$Input$DastSiteValidationCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteValidationCreateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? dastSiteTokenId,
    String? validationPath,
    Enum$DastSiteValidationStrategyEnum? strategy,
  });
}

class _CopyWithImpl$Input$DastSiteValidationCreateInput<TRes>
    implements CopyWith$Input$DastSiteValidationCreateInput<TRes> {
  _CopyWithImpl$Input$DastSiteValidationCreateInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteValidationCreateInput _instance;

  final TRes Function(Input$DastSiteValidationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? dastSiteTokenId = _undefined,
    Object? validationPath = _undefined,
    Object? strategy = _undefined,
  }) =>
      _then(Input$DastSiteValidationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (dastSiteTokenId != _undefined && dastSiteTokenId != null)
          'dastSiteTokenId': (dastSiteTokenId as String),
        if (validationPath != _undefined && validationPath != null)
          'validationPath': (validationPath as String),
        if (strategy != _undefined)
          'strategy': (strategy as Enum$DastSiteValidationStrategyEnum?),
      }));
}

class _CopyWithStubImpl$Input$DastSiteValidationCreateInput<TRes>
    implements CopyWith$Input$DastSiteValidationCreateInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteValidationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? dastSiteTokenId,
    String? validationPath,
    Enum$DastSiteValidationStrategyEnum? strategy,
  }) =>
      _res;
}

class Input$DastSiteValidationRevokeInput {
  factory Input$DastSiteValidationRevokeInput({
    String? clientMutationId,
    required String fullPath,
    required String normalizedTargetUrl,
  }) =>
      Input$DastSiteValidationRevokeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        r'normalizedTargetUrl': normalizedTargetUrl,
      });

  Input$DastSiteValidationRevokeInput._(this._$data);

  factory Input$DastSiteValidationRevokeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    final l$normalizedTargetUrl = data['normalizedTargetUrl'];
    result$data['normalizedTargetUrl'] = (l$normalizedTargetUrl as String);
    return Input$DastSiteValidationRevokeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  String get normalizedTargetUrl => (_$data['normalizedTargetUrl'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    final l$normalizedTargetUrl = normalizedTargetUrl;
    result$data['normalizedTargetUrl'] = l$normalizedTargetUrl;
    return result$data;
  }

  CopyWith$Input$DastSiteValidationRevokeInput<
          Input$DastSiteValidationRevokeInput>
      get copyWith => CopyWith$Input$DastSiteValidationRevokeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DastSiteValidationRevokeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$normalizedTargetUrl = normalizedTargetUrl;
    final lOther$normalizedTargetUrl = other.normalizedTargetUrl;
    if (l$normalizedTargetUrl != lOther$normalizedTargetUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$normalizedTargetUrl = normalizedTargetUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      l$normalizedTargetUrl,
    ]);
  }
}

abstract class CopyWith$Input$DastSiteValidationRevokeInput<TRes> {
  factory CopyWith$Input$DastSiteValidationRevokeInput(
    Input$DastSiteValidationRevokeInput instance,
    TRes Function(Input$DastSiteValidationRevokeInput) then,
  ) = _CopyWithImpl$Input$DastSiteValidationRevokeInput;

  factory CopyWith$Input$DastSiteValidationRevokeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DastSiteValidationRevokeInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? normalizedTargetUrl,
  });
}

class _CopyWithImpl$Input$DastSiteValidationRevokeInput<TRes>
    implements CopyWith$Input$DastSiteValidationRevokeInput<TRes> {
  _CopyWithImpl$Input$DastSiteValidationRevokeInput(
    this._instance,
    this._then,
  );

  final Input$DastSiteValidationRevokeInput _instance;

  final TRes Function(Input$DastSiteValidationRevokeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? normalizedTargetUrl = _undefined,
  }) =>
      _then(Input$DastSiteValidationRevokeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (normalizedTargetUrl != _undefined && normalizedTargetUrl != null)
          'normalizedTargetUrl': (normalizedTargetUrl as String),
      }));
}

class _CopyWithStubImpl$Input$DastSiteValidationRevokeInput<TRes>
    implements CopyWith$Input$DastSiteValidationRevokeInput<TRes> {
  _CopyWithStubImpl$Input$DastSiteValidationRevokeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? normalizedTargetUrl,
  }) =>
      _res;
}

class Input$DeleteAnnotationInput {
  factory Input$DeleteAnnotationInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteAnnotationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteAnnotationInput._(this._$data);

  factory Input$DeleteAnnotationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteAnnotationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteAnnotationInput<Input$DeleteAnnotationInput>
      get copyWith => CopyWith$Input$DeleteAnnotationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteAnnotationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteAnnotationInput<TRes> {
  factory CopyWith$Input$DeleteAnnotationInput(
    Input$DeleteAnnotationInput instance,
    TRes Function(Input$DeleteAnnotationInput) then,
  ) = _CopyWithImpl$Input$DeleteAnnotationInput;

  factory CopyWith$Input$DeleteAnnotationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteAnnotationInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteAnnotationInput<TRes>
    implements CopyWith$Input$DeleteAnnotationInput<TRes> {
  _CopyWithImpl$Input$DeleteAnnotationInput(
    this._instance,
    this._then,
  );

  final Input$DeleteAnnotationInput _instance;

  final TRes Function(Input$DeleteAnnotationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteAnnotationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteAnnotationInput<TRes>
    implements CopyWith$Input$DeleteAnnotationInput<TRes> {
  _CopyWithStubImpl$Input$DeleteAnnotationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeploymentsOrderByInput {
  factory Input$DeploymentsOrderByInput({
    Enum$SortDirectionEnum? createdAt,
    Enum$SortDirectionEnum? finishedAt,
  }) =>
      Input$DeploymentsOrderByInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (finishedAt != null) r'finishedAt': finishedAt,
      });

  Input$DeploymentsOrderByInput._(this._$data);

  factory Input$DeploymentsOrderByInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortDirectionEnum((l$createdAt as String));
    }
    if (data.containsKey('finishedAt')) {
      final l$finishedAt = data['finishedAt'];
      result$data['finishedAt'] = l$finishedAt == null
          ? null
          : fromJson$Enum$SortDirectionEnum((l$finishedAt as String));
    }
    return Input$DeploymentsOrderByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortDirectionEnum? get createdAt =>
      (_$data['createdAt'] as Enum$SortDirectionEnum?);
  Enum$SortDirectionEnum? get finishedAt =>
      (_$data['finishedAt'] as Enum$SortDirectionEnum?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortDirectionEnum(l$createdAt);
    }
    if (_$data.containsKey('finishedAt')) {
      final l$finishedAt = finishedAt;
      result$data['finishedAt'] = l$finishedAt == null
          ? null
          : toJson$Enum$SortDirectionEnum(l$finishedAt);
    }
    return result$data;
  }

  CopyWith$Input$DeploymentsOrderByInput<Input$DeploymentsOrderByInput>
      get copyWith => CopyWith$Input$DeploymentsOrderByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeploymentsOrderByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$finishedAt = finishedAt;
    final lOther$finishedAt = other.finishedAt;
    if (_$data.containsKey('finishedAt') !=
        other._$data.containsKey('finishedAt')) {
      return false;
    }
    if (l$finishedAt != lOther$finishedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$finishedAt = finishedAt;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('finishedAt') ? l$finishedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeploymentsOrderByInput<TRes> {
  factory CopyWith$Input$DeploymentsOrderByInput(
    Input$DeploymentsOrderByInput instance,
    TRes Function(Input$DeploymentsOrderByInput) then,
  ) = _CopyWithImpl$Input$DeploymentsOrderByInput;

  factory CopyWith$Input$DeploymentsOrderByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeploymentsOrderByInput;

  TRes call({
    Enum$SortDirectionEnum? createdAt,
    Enum$SortDirectionEnum? finishedAt,
  });
}

class _CopyWithImpl$Input$DeploymentsOrderByInput<TRes>
    implements CopyWith$Input$DeploymentsOrderByInput<TRes> {
  _CopyWithImpl$Input$DeploymentsOrderByInput(
    this._instance,
    this._then,
  );

  final Input$DeploymentsOrderByInput _instance;

  final TRes Function(Input$DeploymentsOrderByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? finishedAt = _undefined,
  }) =>
      _then(Input$DeploymentsOrderByInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortDirectionEnum?),
        if (finishedAt != _undefined)
          'finishedAt': (finishedAt as Enum$SortDirectionEnum?),
      }));
}

class _CopyWithStubImpl$Input$DeploymentsOrderByInput<TRes>
    implements CopyWith$Input$DeploymentsOrderByInput<TRes> {
  _CopyWithStubImpl$Input$DeploymentsOrderByInput(this._res);

  TRes _res;

  call({
    Enum$SortDirectionEnum? createdAt,
    Enum$SortDirectionEnum? finishedAt,
  }) =>
      _res;
}

class Input$DesignManagementDeleteInput {
  factory Input$DesignManagementDeleteInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> filenames,
  }) =>
      Input$DesignManagementDeleteInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'filenames': filenames,
      });

  Input$DesignManagementDeleteInput._(this._$data);

  factory Input$DesignManagementDeleteInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$filenames = data['filenames'];
    result$data['filenames'] =
        (l$filenames as List<dynamic>).map((e) => (e as String)).toList();
    return Input$DesignManagementDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get filenames => (_$data['filenames'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$filenames = filenames;
    result$data['filenames'] = l$filenames.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$DesignManagementDeleteInput<Input$DesignManagementDeleteInput>
      get copyWith => CopyWith$Input$DesignManagementDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DesignManagementDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$filenames = filenames;
    final lOther$filenames = other.filenames;
    if (l$filenames.length != lOther$filenames.length) {
      return false;
    }
    for (int i = 0; i < l$filenames.length; i++) {
      final l$filenames$entry = l$filenames[i];
      final lOther$filenames$entry = lOther$filenames[i];
      if (l$filenames$entry != lOther$filenames$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$filenames = filenames;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$filenames.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$DesignManagementDeleteInput<TRes> {
  factory CopyWith$Input$DesignManagementDeleteInput(
    Input$DesignManagementDeleteInput instance,
    TRes Function(Input$DesignManagementDeleteInput) then,
  ) = _CopyWithImpl$Input$DesignManagementDeleteInput;

  factory CopyWith$Input$DesignManagementDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DesignManagementDeleteInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? filenames,
  });
}

class _CopyWithImpl$Input$DesignManagementDeleteInput<TRes>
    implements CopyWith$Input$DesignManagementDeleteInput<TRes> {
  _CopyWithImpl$Input$DesignManagementDeleteInput(
    this._instance,
    this._then,
  );

  final Input$DesignManagementDeleteInput _instance;

  final TRes Function(Input$DesignManagementDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? filenames = _undefined,
  }) =>
      _then(Input$DesignManagementDeleteInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (filenames != _undefined && filenames != null)
          'filenames': (filenames as List<String>),
      }));
}

class _CopyWithStubImpl$Input$DesignManagementDeleteInput<TRes>
    implements CopyWith$Input$DesignManagementDeleteInput<TRes> {
  _CopyWithStubImpl$Input$DesignManagementDeleteInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? filenames,
  }) =>
      _res;
}

class Input$DesignManagementMoveInput {
  factory Input$DesignManagementMoveInput({
    String? clientMutationId,
    required String id,
    String? previous,
    String? next,
  }) =>
      Input$DesignManagementMoveInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (previous != null) r'previous': previous,
        if (next != null) r'next': next,
      });

  Input$DesignManagementMoveInput._(this._$data);

  factory Input$DesignManagementMoveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('previous')) {
      final l$previous = data['previous'];
      result$data['previous'] = (l$previous as String?);
    }
    if (data.containsKey('next')) {
      final l$next = data['next'];
      result$data['next'] = (l$next as String?);
    }
    return Input$DesignManagementMoveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get previous => (_$data['previous'] as String?);
  String? get next => (_$data['next'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('previous')) {
      final l$previous = previous;
      result$data['previous'] = l$previous;
    }
    if (_$data.containsKey('next')) {
      final l$next = next;
      result$data['next'] = l$next;
    }
    return result$data;
  }

  CopyWith$Input$DesignManagementMoveInput<Input$DesignManagementMoveInput>
      get copyWith => CopyWith$Input$DesignManagementMoveInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DesignManagementMoveInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$previous = previous;
    final lOther$previous = other.previous;
    if (_$data.containsKey('previous') !=
        other._$data.containsKey('previous')) {
      return false;
    }
    if (l$previous != lOther$previous) {
      return false;
    }
    final l$next = next;
    final lOther$next = other.next;
    if (_$data.containsKey('next') != other._$data.containsKey('next')) {
      return false;
    }
    if (l$next != lOther$next) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$previous = previous;
    final l$next = next;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('previous') ? l$previous : const {},
      _$data.containsKey('next') ? l$next : const {},
    ]);
  }
}

abstract class CopyWith$Input$DesignManagementMoveInput<TRes> {
  factory CopyWith$Input$DesignManagementMoveInput(
    Input$DesignManagementMoveInput instance,
    TRes Function(Input$DesignManagementMoveInput) then,
  ) = _CopyWithImpl$Input$DesignManagementMoveInput;

  factory CopyWith$Input$DesignManagementMoveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DesignManagementMoveInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? previous,
    String? next,
  });
}

class _CopyWithImpl$Input$DesignManagementMoveInput<TRes>
    implements CopyWith$Input$DesignManagementMoveInput<TRes> {
  _CopyWithImpl$Input$DesignManagementMoveInput(
    this._instance,
    this._then,
  );

  final Input$DesignManagementMoveInput _instance;

  final TRes Function(Input$DesignManagementMoveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? previous = _undefined,
    Object? next = _undefined,
  }) =>
      _then(Input$DesignManagementMoveInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (previous != _undefined) 'previous': (previous as String?),
        if (next != _undefined) 'next': (next as String?),
      }));
}

class _CopyWithStubImpl$Input$DesignManagementMoveInput<TRes>
    implements CopyWith$Input$DesignManagementMoveInput<TRes> {
  _CopyWithStubImpl$Input$DesignManagementMoveInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? previous,
    String? next,
  }) =>
      _res;
}

class Input$DesignManagementUploadInput {
  factory Input$DesignManagementUploadInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> files,
  }) =>
      Input$DesignManagementUploadInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'files': files,
      });

  Input$DesignManagementUploadInput._(this._$data);

  factory Input$DesignManagementUploadInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$files = data['files'];
    result$data['files'] =
        (l$files as List<dynamic>).map((e) => (e as String)).toList();
    return Input$DesignManagementUploadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get files => (_$data['files'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$files = files;
    result$data['files'] = l$files.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$DesignManagementUploadInput<Input$DesignManagementUploadInput>
      get copyWith => CopyWith$Input$DesignManagementUploadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DesignManagementUploadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$files = files;
    final lOther$files = other.files;
    if (l$files.length != lOther$files.length) {
      return false;
    }
    for (int i = 0; i < l$files.length; i++) {
      final l$files$entry = l$files[i];
      final lOther$files$entry = lOther$files[i];
      if (l$files$entry != lOther$files$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$files = files;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$files.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$DesignManagementUploadInput<TRes> {
  factory CopyWith$Input$DesignManagementUploadInput(
    Input$DesignManagementUploadInput instance,
    TRes Function(Input$DesignManagementUploadInput) then,
  ) = _CopyWithImpl$Input$DesignManagementUploadInput;

  factory CopyWith$Input$DesignManagementUploadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DesignManagementUploadInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? files,
  });
}

class _CopyWithImpl$Input$DesignManagementUploadInput<TRes>
    implements CopyWith$Input$DesignManagementUploadInput<TRes> {
  _CopyWithImpl$Input$DesignManagementUploadInput(
    this._instance,
    this._then,
  );

  final Input$DesignManagementUploadInput _instance;

  final TRes Function(Input$DesignManagementUploadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? files = _undefined,
  }) =>
      _then(Input$DesignManagementUploadInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (files != _undefined && files != null)
          'files': (files as List<String>),
      }));
}

class _CopyWithStubImpl$Input$DesignManagementUploadInput<TRes>
    implements CopyWith$Input$DesignManagementUploadInput<TRes> {
  _CopyWithStubImpl$Input$DesignManagementUploadInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? files,
  }) =>
      _res;
}

class Input$DestroyBoardInput {
  factory Input$DestroyBoardInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyBoardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyBoardInput._(this._$data);

  factory Input$DestroyBoardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyBoardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyBoardInput<Input$DestroyBoardInput> get copyWith =>
      CopyWith$Input$DestroyBoardInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyBoardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyBoardInput<TRes> {
  factory CopyWith$Input$DestroyBoardInput(
    Input$DestroyBoardInput instance,
    TRes Function(Input$DestroyBoardInput) then,
  ) = _CopyWithImpl$Input$DestroyBoardInput;

  factory CopyWith$Input$DestroyBoardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyBoardInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyBoardInput<TRes>
    implements CopyWith$Input$DestroyBoardInput<TRes> {
  _CopyWithImpl$Input$DestroyBoardInput(
    this._instance,
    this._then,
  );

  final Input$DestroyBoardInput _instance;

  final TRes Function(Input$DestroyBoardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyBoardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyBoardInput<TRes>
    implements CopyWith$Input$DestroyBoardInput<TRes> {
  _CopyWithStubImpl$Input$DestroyBoardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyBoardListInput {
  factory Input$DestroyBoardListInput({
    String? clientMutationId,
    required String listId,
  }) =>
      Input$DestroyBoardListInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
      });

  Input$DestroyBoardListInput._(this._$data);

  factory Input$DestroyBoardListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    return Input$DestroyBoardListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get listId => (_$data['listId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    return result$data;
  }

  CopyWith$Input$DestroyBoardListInput<Input$DestroyBoardListInput>
      get copyWith => CopyWith$Input$DestroyBoardListInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyBoardListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
    ]);
  }
}

abstract class CopyWith$Input$DestroyBoardListInput<TRes> {
  factory CopyWith$Input$DestroyBoardListInput(
    Input$DestroyBoardListInput instance,
    TRes Function(Input$DestroyBoardListInput) then,
  ) = _CopyWithImpl$Input$DestroyBoardListInput;

  factory CopyWith$Input$DestroyBoardListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyBoardListInput;

  TRes call({
    String? clientMutationId,
    String? listId,
  });
}

class _CopyWithImpl$Input$DestroyBoardListInput<TRes>
    implements CopyWith$Input$DestroyBoardListInput<TRes> {
  _CopyWithImpl$Input$DestroyBoardListInput(
    this._instance,
    this._then,
  );

  final Input$DestroyBoardListInput _instance;

  final TRes Function(Input$DestroyBoardListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
  }) =>
      _then(Input$DestroyBoardListInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyBoardListInput<TRes>
    implements CopyWith$Input$DestroyBoardListInput<TRes> {
  _CopyWithStubImpl$Input$DestroyBoardListInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? listId,
  }) =>
      _res;
}

class Input$DestroyComplianceFrameworkInput {
  factory Input$DestroyComplianceFrameworkInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyComplianceFrameworkInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyComplianceFrameworkInput._(this._$data);

  factory Input$DestroyComplianceFrameworkInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyComplianceFrameworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyComplianceFrameworkInput<
          Input$DestroyComplianceFrameworkInput>
      get copyWith => CopyWith$Input$DestroyComplianceFrameworkInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyComplianceFrameworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyComplianceFrameworkInput<TRes> {
  factory CopyWith$Input$DestroyComplianceFrameworkInput(
    Input$DestroyComplianceFrameworkInput instance,
    TRes Function(Input$DestroyComplianceFrameworkInput) then,
  ) = _CopyWithImpl$Input$DestroyComplianceFrameworkInput;

  factory CopyWith$Input$DestroyComplianceFrameworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyComplianceFrameworkInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyComplianceFrameworkInput<TRes>
    implements CopyWith$Input$DestroyComplianceFrameworkInput<TRes> {
  _CopyWithImpl$Input$DestroyComplianceFrameworkInput(
    this._instance,
    this._then,
  );

  final Input$DestroyComplianceFrameworkInput _instance;

  final TRes Function(Input$DestroyComplianceFrameworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyComplianceFrameworkInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyComplianceFrameworkInput<TRes>
    implements CopyWith$Input$DestroyComplianceFrameworkInput<TRes> {
  _CopyWithStubImpl$Input$DestroyComplianceFrameworkInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyContainerRepositoryInput {
  factory Input$DestroyContainerRepositoryInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyContainerRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyContainerRepositoryInput._(this._$data);

  factory Input$DestroyContainerRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyContainerRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyContainerRepositoryInput<
          Input$DestroyContainerRepositoryInput>
      get copyWith => CopyWith$Input$DestroyContainerRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyContainerRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyContainerRepositoryInput<TRes> {
  factory CopyWith$Input$DestroyContainerRepositoryInput(
    Input$DestroyContainerRepositoryInput instance,
    TRes Function(Input$DestroyContainerRepositoryInput) then,
  ) = _CopyWithImpl$Input$DestroyContainerRepositoryInput;

  factory CopyWith$Input$DestroyContainerRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyContainerRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyContainerRepositoryInput<TRes>
    implements CopyWith$Input$DestroyContainerRepositoryInput<TRes> {
  _CopyWithImpl$Input$DestroyContainerRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$DestroyContainerRepositoryInput _instance;

  final TRes Function(Input$DestroyContainerRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyContainerRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyContainerRepositoryInput<TRes>
    implements CopyWith$Input$DestroyContainerRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$DestroyContainerRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyContainerRepositoryTagsInput {
  factory Input$DestroyContainerRepositoryTagsInput({
    String? clientMutationId,
    required String id,
    required List<String> tagNames,
  }) =>
      Input$DestroyContainerRepositoryTagsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'tagNames': tagNames,
      });

  Input$DestroyContainerRepositoryTagsInput._(this._$data);

  factory Input$DestroyContainerRepositoryTagsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$tagNames = data['tagNames'];
    result$data['tagNames'] =
        (l$tagNames as List<dynamic>).map((e) => (e as String)).toList();
    return Input$DestroyContainerRepositoryTagsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  List<String> get tagNames => (_$data['tagNames'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$tagNames = tagNames;
    result$data['tagNames'] = l$tagNames.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$DestroyContainerRepositoryTagsInput<
          Input$DestroyContainerRepositoryTagsInput>
      get copyWith => CopyWith$Input$DestroyContainerRepositoryTagsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyContainerRepositoryTagsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$tagNames = tagNames;
    final lOther$tagNames = other.tagNames;
    if (l$tagNames.length != lOther$tagNames.length) {
      return false;
    }
    for (int i = 0; i < l$tagNames.length; i++) {
      final l$tagNames$entry = l$tagNames[i];
      final lOther$tagNames$entry = lOther$tagNames[i];
      if (l$tagNames$entry != lOther$tagNames$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$tagNames = tagNames;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      Object.hashAll(l$tagNames.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$DestroyContainerRepositoryTagsInput<TRes> {
  factory CopyWith$Input$DestroyContainerRepositoryTagsInput(
    Input$DestroyContainerRepositoryTagsInput instance,
    TRes Function(Input$DestroyContainerRepositoryTagsInput) then,
  ) = _CopyWithImpl$Input$DestroyContainerRepositoryTagsInput;

  factory CopyWith$Input$DestroyContainerRepositoryTagsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyContainerRepositoryTagsInput;

  TRes call({
    String? clientMutationId,
    String? id,
    List<String>? tagNames,
  });
}

class _CopyWithImpl$Input$DestroyContainerRepositoryTagsInput<TRes>
    implements CopyWith$Input$DestroyContainerRepositoryTagsInput<TRes> {
  _CopyWithImpl$Input$DestroyContainerRepositoryTagsInput(
    this._instance,
    this._then,
  );

  final Input$DestroyContainerRepositoryTagsInput _instance;

  final TRes Function(Input$DestroyContainerRepositoryTagsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? tagNames = _undefined,
  }) =>
      _then(Input$DestroyContainerRepositoryTagsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (tagNames != _undefined && tagNames != null)
          'tagNames': (tagNames as List<String>),
      }));
}

class _CopyWithStubImpl$Input$DestroyContainerRepositoryTagsInput<TRes>
    implements CopyWith$Input$DestroyContainerRepositoryTagsInput<TRes> {
  _CopyWithStubImpl$Input$DestroyContainerRepositoryTagsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    List<String>? tagNames,
  }) =>
      _res;
}

class Input$DestroyCustomEmojiInput {
  factory Input$DestroyCustomEmojiInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyCustomEmojiInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyCustomEmojiInput._(this._$data);

  factory Input$DestroyCustomEmojiInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyCustomEmojiInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyCustomEmojiInput<Input$DestroyCustomEmojiInput>
      get copyWith => CopyWith$Input$DestroyCustomEmojiInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyCustomEmojiInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyCustomEmojiInput<TRes> {
  factory CopyWith$Input$DestroyCustomEmojiInput(
    Input$DestroyCustomEmojiInput instance,
    TRes Function(Input$DestroyCustomEmojiInput) then,
  ) = _CopyWithImpl$Input$DestroyCustomEmojiInput;

  factory CopyWith$Input$DestroyCustomEmojiInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyCustomEmojiInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyCustomEmojiInput<TRes>
    implements CopyWith$Input$DestroyCustomEmojiInput<TRes> {
  _CopyWithImpl$Input$DestroyCustomEmojiInput(
    this._instance,
    this._then,
  );

  final Input$DestroyCustomEmojiInput _instance;

  final TRes Function(Input$DestroyCustomEmojiInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyCustomEmojiInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyCustomEmojiInput<TRes>
    implements CopyWith$Input$DestroyCustomEmojiInput<TRes> {
  _CopyWithStubImpl$Input$DestroyCustomEmojiInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyEpicBoardInput {
  factory Input$DestroyEpicBoardInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyEpicBoardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyEpicBoardInput._(this._$data);

  factory Input$DestroyEpicBoardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyEpicBoardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyEpicBoardInput<Input$DestroyEpicBoardInput>
      get copyWith => CopyWith$Input$DestroyEpicBoardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyEpicBoardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyEpicBoardInput<TRes> {
  factory CopyWith$Input$DestroyEpicBoardInput(
    Input$DestroyEpicBoardInput instance,
    TRes Function(Input$DestroyEpicBoardInput) then,
  ) = _CopyWithImpl$Input$DestroyEpicBoardInput;

  factory CopyWith$Input$DestroyEpicBoardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyEpicBoardInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyEpicBoardInput<TRes>
    implements CopyWith$Input$DestroyEpicBoardInput<TRes> {
  _CopyWithImpl$Input$DestroyEpicBoardInput(
    this._instance,
    this._then,
  );

  final Input$DestroyEpicBoardInput _instance;

  final TRes Function(Input$DestroyEpicBoardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyEpicBoardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyEpicBoardInput<TRes>
    implements CopyWith$Input$DestroyEpicBoardInput<TRes> {
  _CopyWithStubImpl$Input$DestroyEpicBoardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyNoteInput {
  factory Input$DestroyNoteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyNoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyNoteInput._(this._$data);

  factory Input$DestroyNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyNoteInput<Input$DestroyNoteInput> get copyWith =>
      CopyWith$Input$DestroyNoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyNoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyNoteInput<TRes> {
  factory CopyWith$Input$DestroyNoteInput(
    Input$DestroyNoteInput instance,
    TRes Function(Input$DestroyNoteInput) then,
  ) = _CopyWithImpl$Input$DestroyNoteInput;

  factory CopyWith$Input$DestroyNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyNoteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyNoteInput<TRes>
    implements CopyWith$Input$DestroyNoteInput<TRes> {
  _CopyWithImpl$Input$DestroyNoteInput(
    this._instance,
    this._then,
  );

  final Input$DestroyNoteInput _instance;

  final TRes Function(Input$DestroyNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyNoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyNoteInput<TRes>
    implements CopyWith$Input$DestroyNoteInput<TRes> {
  _CopyWithStubImpl$Input$DestroyNoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyPackageFileInput {
  factory Input$DestroyPackageFileInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyPackageFileInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyPackageFileInput._(this._$data);

  factory Input$DestroyPackageFileInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyPackageFileInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyPackageFileInput<Input$DestroyPackageFileInput>
      get copyWith => CopyWith$Input$DestroyPackageFileInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyPackageFileInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyPackageFileInput<TRes> {
  factory CopyWith$Input$DestroyPackageFileInput(
    Input$DestroyPackageFileInput instance,
    TRes Function(Input$DestroyPackageFileInput) then,
  ) = _CopyWithImpl$Input$DestroyPackageFileInput;

  factory CopyWith$Input$DestroyPackageFileInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyPackageFileInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyPackageFileInput<TRes>
    implements CopyWith$Input$DestroyPackageFileInput<TRes> {
  _CopyWithImpl$Input$DestroyPackageFileInput(
    this._instance,
    this._then,
  );

  final Input$DestroyPackageFileInput _instance;

  final TRes Function(Input$DestroyPackageFileInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyPackageFileInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyPackageFileInput<TRes>
    implements CopyWith$Input$DestroyPackageFileInput<TRes> {
  _CopyWithStubImpl$Input$DestroyPackageFileInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroyPackageFilesInput {
  factory Input$DestroyPackageFilesInput({
    String? clientMutationId,
    required String projectPath,
    required List<String> ids,
  }) =>
      Input$DestroyPackageFilesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'ids': ids,
      });

  Input$DestroyPackageFilesInput._(this._$data);

  factory Input$DestroyPackageFilesInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$ids = data['ids'];
    result$data['ids'] =
        (l$ids as List<dynamic>).map((e) => (e as String)).toList();
    return Input$DestroyPackageFilesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  List<String> get ids => (_$data['ids'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$ids = ids;
    result$data['ids'] = l$ids.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$DestroyPackageFilesInput<Input$DestroyPackageFilesInput>
      get copyWith => CopyWith$Input$DestroyPackageFilesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyPackageFilesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (l$ids.length != lOther$ids.length) {
      return false;
    }
    for (int i = 0; i < l$ids.length; i++) {
      final l$ids$entry = l$ids[i];
      final lOther$ids$entry = lOther$ids[i];
      if (l$ids$entry != lOther$ids$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      Object.hashAll(l$ids.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$DestroyPackageFilesInput<TRes> {
  factory CopyWith$Input$DestroyPackageFilesInput(
    Input$DestroyPackageFilesInput instance,
    TRes Function(Input$DestroyPackageFilesInput) then,
  ) = _CopyWithImpl$Input$DestroyPackageFilesInput;

  factory CopyWith$Input$DestroyPackageFilesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyPackageFilesInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    List<String>? ids,
  });
}

class _CopyWithImpl$Input$DestroyPackageFilesInput<TRes>
    implements CopyWith$Input$DestroyPackageFilesInput<TRes> {
  _CopyWithImpl$Input$DestroyPackageFilesInput(
    this._instance,
    this._then,
  );

  final Input$DestroyPackageFilesInput _instance;

  final TRes Function(Input$DestroyPackageFilesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$DestroyPackageFilesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (ids != _undefined && ids != null) 'ids': (ids as List<String>),
      }));
}

class _CopyWithStubImpl$Input$DestroyPackageFilesInput<TRes>
    implements CopyWith$Input$DestroyPackageFilesInput<TRes> {
  _CopyWithStubImpl$Input$DestroyPackageFilesInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    List<String>? ids,
  }) =>
      _res;
}

class Input$DestroyPackageInput {
  factory Input$DestroyPackageInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroyPackageInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroyPackageInput._(this._$data);

  factory Input$DestroyPackageInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroyPackageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroyPackageInput<Input$DestroyPackageInput> get copyWith =>
      CopyWith$Input$DestroyPackageInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroyPackageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroyPackageInput<TRes> {
  factory CopyWith$Input$DestroyPackageInput(
    Input$DestroyPackageInput instance,
    TRes Function(Input$DestroyPackageInput) then,
  ) = _CopyWithImpl$Input$DestroyPackageInput;

  factory CopyWith$Input$DestroyPackageInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroyPackageInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroyPackageInput<TRes>
    implements CopyWith$Input$DestroyPackageInput<TRes> {
  _CopyWithImpl$Input$DestroyPackageInput(
    this._instance,
    this._then,
  );

  final Input$DestroyPackageInput _instance;

  final TRes Function(Input$DestroyPackageInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroyPackageInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroyPackageInput<TRes>
    implements CopyWith$Input$DestroyPackageInput<TRes> {
  _CopyWithStubImpl$Input$DestroyPackageInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DestroySnippetInput {
  factory Input$DestroySnippetInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DestroySnippetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DestroySnippetInput._(this._$data);

  factory Input$DestroySnippetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DestroySnippetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DestroySnippetInput<Input$DestroySnippetInput> get copyWith =>
      CopyWith$Input$DestroySnippetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DestroySnippetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DestroySnippetInput<TRes> {
  factory CopyWith$Input$DestroySnippetInput(
    Input$DestroySnippetInput instance,
    TRes Function(Input$DestroySnippetInput) then,
  ) = _CopyWithImpl$Input$DestroySnippetInput;

  factory CopyWith$Input$DestroySnippetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DestroySnippetInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DestroySnippetInput<TRes>
    implements CopyWith$Input$DestroySnippetInput<TRes> {
  _CopyWithImpl$Input$DestroySnippetInput(
    this._instance,
    this._then,
  );

  final Input$DestroySnippetInput _instance;

  final TRes Function(Input$DestroySnippetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DestroySnippetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DestroySnippetInput<TRes>
    implements CopyWith$Input$DestroySnippetInput<TRes> {
  _CopyWithStubImpl$Input$DestroySnippetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DiffImagePositionInput {
  factory Input$DiffImagePositionInput({
    String? baseSha,
    required String headSha,
    required String startSha,
    required Input$DiffPathsInput paths,
    required int height,
    required int width,
    required int x,
    required int y,
  }) =>
      Input$DiffImagePositionInput._({
        if (baseSha != null) r'baseSha': baseSha,
        r'headSha': headSha,
        r'startSha': startSha,
        r'paths': paths,
        r'height': height,
        r'width': width,
        r'x': x,
        r'y': y,
      });

  Input$DiffImagePositionInput._(this._$data);

  factory Input$DiffImagePositionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('baseSha')) {
      final l$baseSha = data['baseSha'];
      result$data['baseSha'] = (l$baseSha as String?);
    }
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    final l$startSha = data['startSha'];
    result$data['startSha'] = (l$startSha as String);
    final l$paths = data['paths'];
    result$data['paths'] =
        Input$DiffPathsInput.fromJson((l$paths as Map<String, dynamic>));
    final l$height = data['height'];
    result$data['height'] = (l$height as int);
    final l$width = data['width'];
    result$data['width'] = (l$width as int);
    final l$x = data['x'];
    result$data['x'] = (l$x as int);
    final l$y = data['y'];
    result$data['y'] = (l$y as int);
    return Input$DiffImagePositionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get baseSha => (_$data['baseSha'] as String?);
  String get headSha => (_$data['headSha'] as String);
  String get startSha => (_$data['startSha'] as String);
  Input$DiffPathsInput get paths => (_$data['paths'] as Input$DiffPathsInput);
  int get height => (_$data['height'] as int);
  int get width => (_$data['width'] as int);
  int get x => (_$data['x'] as int);
  int get y => (_$data['y'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('baseSha')) {
      final l$baseSha = baseSha;
      result$data['baseSha'] = l$baseSha;
    }
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    final l$startSha = startSha;
    result$data['startSha'] = l$startSha;
    final l$paths = paths;
    result$data['paths'] = l$paths.toJson();
    final l$height = height;
    result$data['height'] = l$height;
    final l$width = width;
    result$data['width'] = l$width;
    final l$x = x;
    result$data['x'] = l$x;
    final l$y = y;
    result$data['y'] = l$y;
    return result$data;
  }

  CopyWith$Input$DiffImagePositionInput<Input$DiffImagePositionInput>
      get copyWith => CopyWith$Input$DiffImagePositionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiffImagePositionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$baseSha = baseSha;
    final lOther$baseSha = other.baseSha;
    if (_$data.containsKey('baseSha') != other._$data.containsKey('baseSha')) {
      return false;
    }
    if (l$baseSha != lOther$baseSha) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$startSha = startSha;
    final lOther$startSha = other.startSha;
    if (l$startSha != lOther$startSha) {
      return false;
    }
    final l$paths = paths;
    final lOther$paths = other.paths;
    if (l$paths != lOther$paths) {
      return false;
    }
    final l$height = height;
    final lOther$height = other.height;
    if (l$height != lOther$height) {
      return false;
    }
    final l$width = width;
    final lOther$width = other.width;
    if (l$width != lOther$width) {
      return false;
    }
    final l$x = x;
    final lOther$x = other.x;
    if (l$x != lOther$x) {
      return false;
    }
    final l$y = y;
    final lOther$y = other.y;
    if (l$y != lOther$y) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$baseSha = baseSha;
    final l$headSha = headSha;
    final l$startSha = startSha;
    final l$paths = paths;
    final l$height = height;
    final l$width = width;
    final l$x = x;
    final l$y = y;
    return Object.hashAll([
      _$data.containsKey('baseSha') ? l$baseSha : const {},
      l$headSha,
      l$startSha,
      l$paths,
      l$height,
      l$width,
      l$x,
      l$y,
    ]);
  }
}

abstract class CopyWith$Input$DiffImagePositionInput<TRes> {
  factory CopyWith$Input$DiffImagePositionInput(
    Input$DiffImagePositionInput instance,
    TRes Function(Input$DiffImagePositionInput) then,
  ) = _CopyWithImpl$Input$DiffImagePositionInput;

  factory CopyWith$Input$DiffImagePositionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DiffImagePositionInput;

  TRes call({
    String? baseSha,
    String? headSha,
    String? startSha,
    Input$DiffPathsInput? paths,
    int? height,
    int? width,
    int? x,
    int? y,
  });
  CopyWith$Input$DiffPathsInput<TRes> get paths;
}

class _CopyWithImpl$Input$DiffImagePositionInput<TRes>
    implements CopyWith$Input$DiffImagePositionInput<TRes> {
  _CopyWithImpl$Input$DiffImagePositionInput(
    this._instance,
    this._then,
  );

  final Input$DiffImagePositionInput _instance;

  final TRes Function(Input$DiffImagePositionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? baseSha = _undefined,
    Object? headSha = _undefined,
    Object? startSha = _undefined,
    Object? paths = _undefined,
    Object? height = _undefined,
    Object? width = _undefined,
    Object? x = _undefined,
    Object? y = _undefined,
  }) =>
      _then(Input$DiffImagePositionInput._({
        ..._instance._$data,
        if (baseSha != _undefined) 'baseSha': (baseSha as String?),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (startSha != _undefined && startSha != null)
          'startSha': (startSha as String),
        if (paths != _undefined && paths != null)
          'paths': (paths as Input$DiffPathsInput),
        if (height != _undefined && height != null) 'height': (height as int),
        if (width != _undefined && width != null) 'width': (width as int),
        if (x != _undefined && x != null) 'x': (x as int),
        if (y != _undefined && y != null) 'y': (y as int),
      }));
  CopyWith$Input$DiffPathsInput<TRes> get paths {
    final local$paths = _instance.paths;
    return CopyWith$Input$DiffPathsInput(local$paths, (e) => call(paths: e));
  }
}

class _CopyWithStubImpl$Input$DiffImagePositionInput<TRes>
    implements CopyWith$Input$DiffImagePositionInput<TRes> {
  _CopyWithStubImpl$Input$DiffImagePositionInput(this._res);

  TRes _res;

  call({
    String? baseSha,
    String? headSha,
    String? startSha,
    Input$DiffPathsInput? paths,
    int? height,
    int? width,
    int? x,
    int? y,
  }) =>
      _res;
  CopyWith$Input$DiffPathsInput<TRes> get paths =>
      CopyWith$Input$DiffPathsInput.stub(_res);
}

class Input$DiffPathsInput {
  factory Input$DiffPathsInput({
    String? newPath,
    String? oldPath,
  }) =>
      Input$DiffPathsInput._({
        if (newPath != null) r'newPath': newPath,
        if (oldPath != null) r'oldPath': oldPath,
      });

  Input$DiffPathsInput._(this._$data);

  factory Input$DiffPathsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('newPath')) {
      final l$newPath = data['newPath'];
      result$data['newPath'] = (l$newPath as String?);
    }
    if (data.containsKey('oldPath')) {
      final l$oldPath = data['oldPath'];
      result$data['oldPath'] = (l$oldPath as String?);
    }
    return Input$DiffPathsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get newPath => (_$data['newPath'] as String?);
  String? get oldPath => (_$data['oldPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('newPath')) {
      final l$newPath = newPath;
      result$data['newPath'] = l$newPath;
    }
    if (_$data.containsKey('oldPath')) {
      final l$oldPath = oldPath;
      result$data['oldPath'] = l$oldPath;
    }
    return result$data;
  }

  CopyWith$Input$DiffPathsInput<Input$DiffPathsInput> get copyWith =>
      CopyWith$Input$DiffPathsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiffPathsInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$newPath = newPath;
    final lOther$newPath = other.newPath;
    if (_$data.containsKey('newPath') != other._$data.containsKey('newPath')) {
      return false;
    }
    if (l$newPath != lOther$newPath) {
      return false;
    }
    final l$oldPath = oldPath;
    final lOther$oldPath = other.oldPath;
    if (_$data.containsKey('oldPath') != other._$data.containsKey('oldPath')) {
      return false;
    }
    if (l$oldPath != lOther$oldPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$newPath = newPath;
    final l$oldPath = oldPath;
    return Object.hashAll([
      _$data.containsKey('newPath') ? l$newPath : const {},
      _$data.containsKey('oldPath') ? l$oldPath : const {},
    ]);
  }
}

abstract class CopyWith$Input$DiffPathsInput<TRes> {
  factory CopyWith$Input$DiffPathsInput(
    Input$DiffPathsInput instance,
    TRes Function(Input$DiffPathsInput) then,
  ) = _CopyWithImpl$Input$DiffPathsInput;

  factory CopyWith$Input$DiffPathsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DiffPathsInput;

  TRes call({
    String? newPath,
    String? oldPath,
  });
}

class _CopyWithImpl$Input$DiffPathsInput<TRes>
    implements CopyWith$Input$DiffPathsInput<TRes> {
  _CopyWithImpl$Input$DiffPathsInput(
    this._instance,
    this._then,
  );

  final Input$DiffPathsInput _instance;

  final TRes Function(Input$DiffPathsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? newPath = _undefined,
    Object? oldPath = _undefined,
  }) =>
      _then(Input$DiffPathsInput._({
        ..._instance._$data,
        if (newPath != _undefined) 'newPath': (newPath as String?),
        if (oldPath != _undefined) 'oldPath': (oldPath as String?),
      }));
}

class _CopyWithStubImpl$Input$DiffPathsInput<TRes>
    implements CopyWith$Input$DiffPathsInput<TRes> {
  _CopyWithStubImpl$Input$DiffPathsInput(this._res);

  TRes _res;

  call({
    String? newPath,
    String? oldPath,
  }) =>
      _res;
}

class Input$DiffPositionInput {
  factory Input$DiffPositionInput({
    String? baseSha,
    required String headSha,
    required String startSha,
    required Input$DiffPathsInput paths,
    int? newLine,
    int? oldLine,
  }) =>
      Input$DiffPositionInput._({
        if (baseSha != null) r'baseSha': baseSha,
        r'headSha': headSha,
        r'startSha': startSha,
        r'paths': paths,
        if (newLine != null) r'newLine': newLine,
        if (oldLine != null) r'oldLine': oldLine,
      });

  Input$DiffPositionInput._(this._$data);

  factory Input$DiffPositionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('baseSha')) {
      final l$baseSha = data['baseSha'];
      result$data['baseSha'] = (l$baseSha as String?);
    }
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    final l$startSha = data['startSha'];
    result$data['startSha'] = (l$startSha as String);
    final l$paths = data['paths'];
    result$data['paths'] =
        Input$DiffPathsInput.fromJson((l$paths as Map<String, dynamic>));
    if (data.containsKey('newLine')) {
      final l$newLine = data['newLine'];
      result$data['newLine'] = (l$newLine as int?);
    }
    if (data.containsKey('oldLine')) {
      final l$oldLine = data['oldLine'];
      result$data['oldLine'] = (l$oldLine as int?);
    }
    return Input$DiffPositionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get baseSha => (_$data['baseSha'] as String?);
  String get headSha => (_$data['headSha'] as String);
  String get startSha => (_$data['startSha'] as String);
  Input$DiffPathsInput get paths => (_$data['paths'] as Input$DiffPathsInput);
  int? get newLine => (_$data['newLine'] as int?);
  int? get oldLine => (_$data['oldLine'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('baseSha')) {
      final l$baseSha = baseSha;
      result$data['baseSha'] = l$baseSha;
    }
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    final l$startSha = startSha;
    result$data['startSha'] = l$startSha;
    final l$paths = paths;
    result$data['paths'] = l$paths.toJson();
    if (_$data.containsKey('newLine')) {
      final l$newLine = newLine;
      result$data['newLine'] = l$newLine;
    }
    if (_$data.containsKey('oldLine')) {
      final l$oldLine = oldLine;
      result$data['oldLine'] = l$oldLine;
    }
    return result$data;
  }

  CopyWith$Input$DiffPositionInput<Input$DiffPositionInput> get copyWith =>
      CopyWith$Input$DiffPositionInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiffPositionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$baseSha = baseSha;
    final lOther$baseSha = other.baseSha;
    if (_$data.containsKey('baseSha') != other._$data.containsKey('baseSha')) {
      return false;
    }
    if (l$baseSha != lOther$baseSha) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$startSha = startSha;
    final lOther$startSha = other.startSha;
    if (l$startSha != lOther$startSha) {
      return false;
    }
    final l$paths = paths;
    final lOther$paths = other.paths;
    if (l$paths != lOther$paths) {
      return false;
    }
    final l$newLine = newLine;
    final lOther$newLine = other.newLine;
    if (_$data.containsKey('newLine') != other._$data.containsKey('newLine')) {
      return false;
    }
    if (l$newLine != lOther$newLine) {
      return false;
    }
    final l$oldLine = oldLine;
    final lOther$oldLine = other.oldLine;
    if (_$data.containsKey('oldLine') != other._$data.containsKey('oldLine')) {
      return false;
    }
    if (l$oldLine != lOther$oldLine) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$baseSha = baseSha;
    final l$headSha = headSha;
    final l$startSha = startSha;
    final l$paths = paths;
    final l$newLine = newLine;
    final l$oldLine = oldLine;
    return Object.hashAll([
      _$data.containsKey('baseSha') ? l$baseSha : const {},
      l$headSha,
      l$startSha,
      l$paths,
      _$data.containsKey('newLine') ? l$newLine : const {},
      _$data.containsKey('oldLine') ? l$oldLine : const {},
    ]);
  }
}

abstract class CopyWith$Input$DiffPositionInput<TRes> {
  factory CopyWith$Input$DiffPositionInput(
    Input$DiffPositionInput instance,
    TRes Function(Input$DiffPositionInput) then,
  ) = _CopyWithImpl$Input$DiffPositionInput;

  factory CopyWith$Input$DiffPositionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DiffPositionInput;

  TRes call({
    String? baseSha,
    String? headSha,
    String? startSha,
    Input$DiffPathsInput? paths,
    int? newLine,
    int? oldLine,
  });
  CopyWith$Input$DiffPathsInput<TRes> get paths;
}

class _CopyWithImpl$Input$DiffPositionInput<TRes>
    implements CopyWith$Input$DiffPositionInput<TRes> {
  _CopyWithImpl$Input$DiffPositionInput(
    this._instance,
    this._then,
  );

  final Input$DiffPositionInput _instance;

  final TRes Function(Input$DiffPositionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? baseSha = _undefined,
    Object? headSha = _undefined,
    Object? startSha = _undefined,
    Object? paths = _undefined,
    Object? newLine = _undefined,
    Object? oldLine = _undefined,
  }) =>
      _then(Input$DiffPositionInput._({
        ..._instance._$data,
        if (baseSha != _undefined) 'baseSha': (baseSha as String?),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (startSha != _undefined && startSha != null)
          'startSha': (startSha as String),
        if (paths != _undefined && paths != null)
          'paths': (paths as Input$DiffPathsInput),
        if (newLine != _undefined) 'newLine': (newLine as int?),
        if (oldLine != _undefined) 'oldLine': (oldLine as int?),
      }));
  CopyWith$Input$DiffPathsInput<TRes> get paths {
    final local$paths = _instance.paths;
    return CopyWith$Input$DiffPathsInput(local$paths, (e) => call(paths: e));
  }
}

class _CopyWithStubImpl$Input$DiffPositionInput<TRes>
    implements CopyWith$Input$DiffPositionInput<TRes> {
  _CopyWithStubImpl$Input$DiffPositionInput(this._res);

  TRes _res;

  call({
    String? baseSha,
    String? headSha,
    String? startSha,
    Input$DiffPathsInput? paths,
    int? newLine,
    int? oldLine,
  }) =>
      _res;
  CopyWith$Input$DiffPathsInput<TRes> get paths =>
      CopyWith$Input$DiffPathsInput.stub(_res);
}

class Input$DisableDevopsAdoptionNamespaceInput {
  factory Input$DisableDevopsAdoptionNamespaceInput({
    String? clientMutationId,
    required List<String> id,
  }) =>
      Input$DisableDevopsAdoptionNamespaceInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DisableDevopsAdoptionNamespaceInput._(this._$data);

  factory Input$DisableDevopsAdoptionNamespaceInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] =
        (l$id as List<dynamic>).map((e) => (e as String)).toList();
    return Input$DisableDevopsAdoptionNamespaceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get id => (_$data['id'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$DisableDevopsAdoptionNamespaceInput<
          Input$DisableDevopsAdoptionNamespaceInput>
      get copyWith => CopyWith$Input$DisableDevopsAdoptionNamespaceInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DisableDevopsAdoptionNamespaceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id.length != lOther$id.length) {
      return false;
    }
    for (int i = 0; i < l$id.length; i++) {
      final l$id$entry = l$id[i];
      final lOther$id$entry = lOther$id[i];
      if (l$id$entry != lOther$id$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$id.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$DisableDevopsAdoptionNamespaceInput<TRes> {
  factory CopyWith$Input$DisableDevopsAdoptionNamespaceInput(
    Input$DisableDevopsAdoptionNamespaceInput instance,
    TRes Function(Input$DisableDevopsAdoptionNamespaceInput) then,
  ) = _CopyWithImpl$Input$DisableDevopsAdoptionNamespaceInput;

  factory CopyWith$Input$DisableDevopsAdoptionNamespaceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DisableDevopsAdoptionNamespaceInput;

  TRes call({
    String? clientMutationId,
    List<String>? id,
  });
}

class _CopyWithImpl$Input$DisableDevopsAdoptionNamespaceInput<TRes>
    implements CopyWith$Input$DisableDevopsAdoptionNamespaceInput<TRes> {
  _CopyWithImpl$Input$DisableDevopsAdoptionNamespaceInput(
    this._instance,
    this._then,
  );

  final Input$DisableDevopsAdoptionNamespaceInput _instance;

  final TRes Function(Input$DisableDevopsAdoptionNamespaceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DisableDevopsAdoptionNamespaceInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as List<String>),
      }));
}

class _CopyWithStubImpl$Input$DisableDevopsAdoptionNamespaceInput<TRes>
    implements CopyWith$Input$DisableDevopsAdoptionNamespaceInput<TRes> {
  _CopyWithStubImpl$Input$DisableDevopsAdoptionNamespaceInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? id,
  }) =>
      _res;
}

class Input$DiscussionToggleResolveInput {
  factory Input$DiscussionToggleResolveInput({
    String? clientMutationId,
    required String id,
    required bool resolve,
  }) =>
      Input$DiscussionToggleResolveInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'resolve': resolve,
      });

  Input$DiscussionToggleResolveInput._(this._$data);

  factory Input$DiscussionToggleResolveInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$resolve = data['resolve'];
    result$data['resolve'] = (l$resolve as bool);
    return Input$DiscussionToggleResolveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  bool get resolve => (_$data['resolve'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$resolve = resolve;
    result$data['resolve'] = l$resolve;
    return result$data;
  }

  CopyWith$Input$DiscussionToggleResolveInput<
          Input$DiscussionToggleResolveInput>
      get copyWith => CopyWith$Input$DiscussionToggleResolveInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiscussionToggleResolveInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$resolve = resolve;
    final lOther$resolve = other.resolve;
    if (l$resolve != lOther$resolve) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$resolve = resolve;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$resolve,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionToggleResolveInput<TRes> {
  factory CopyWith$Input$DiscussionToggleResolveInput(
    Input$DiscussionToggleResolveInput instance,
    TRes Function(Input$DiscussionToggleResolveInput) then,
  ) = _CopyWithImpl$Input$DiscussionToggleResolveInput;

  factory CopyWith$Input$DiscussionToggleResolveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionToggleResolveInput;

  TRes call({
    String? clientMutationId,
    String? id,
    bool? resolve,
  });
}

class _CopyWithImpl$Input$DiscussionToggleResolveInput<TRes>
    implements CopyWith$Input$DiscussionToggleResolveInput<TRes> {
  _CopyWithImpl$Input$DiscussionToggleResolveInput(
    this._instance,
    this._then,
  );

  final Input$DiscussionToggleResolveInput _instance;

  final TRes Function(Input$DiscussionToggleResolveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? resolve = _undefined,
  }) =>
      _then(Input$DiscussionToggleResolveInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (resolve != _undefined && resolve != null)
          'resolve': (resolve as bool),
      }));
}

class _CopyWithStubImpl$Input$DiscussionToggleResolveInput<TRes>
    implements CopyWith$Input$DiscussionToggleResolveInput<TRes> {
  _CopyWithStubImpl$Input$DiscussionToggleResolveInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    bool? resolve,
  }) =>
      _res;
}

class Input$EchoCreateInput {
  factory Input$EchoCreateInput({
    String? clientMutationId,
    List<String>? errors,
    List<String>? messages,
  }) =>
      Input$EchoCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (errors != null) r'errors': errors,
        if (messages != null) r'messages': messages,
      });

  Input$EchoCreateInput._(this._$data);

  factory Input$EchoCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('errors')) {
      final l$errors = data['errors'];
      result$data['errors'] =
          (l$errors as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('messages')) {
      final l$messages = data['messages'];
      result$data['messages'] =
          (l$messages as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$EchoCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String>? get errors => (_$data['errors'] as List<String>?);
  List<String>? get messages => (_$data['messages'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('errors')) {
      final l$errors = errors;
      result$data['errors'] = l$errors?.map((e) => e).toList();
    }
    if (_$data.containsKey('messages')) {
      final l$messages = messages;
      result$data['messages'] = l$messages?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$EchoCreateInput<Input$EchoCreateInput> get copyWith =>
      CopyWith$Input$EchoCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EchoCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$errors = errors;
    final lOther$errors = other.errors;
    if (_$data.containsKey('errors') != other._$data.containsKey('errors')) {
      return false;
    }
    if (l$errors != null && lOther$errors != null) {
      if (l$errors.length != lOther$errors.length) {
        return false;
      }
      for (int i = 0; i < l$errors.length; i++) {
        final l$errors$entry = l$errors[i];
        final lOther$errors$entry = lOther$errors[i];
        if (l$errors$entry != lOther$errors$entry) {
          return false;
        }
      }
    } else if (l$errors != lOther$errors) {
      return false;
    }
    final l$messages = messages;
    final lOther$messages = other.messages;
    if (_$data.containsKey('messages') !=
        other._$data.containsKey('messages')) {
      return false;
    }
    if (l$messages != null && lOther$messages != null) {
      if (l$messages.length != lOther$messages.length) {
        return false;
      }
      for (int i = 0; i < l$messages.length; i++) {
        final l$messages$entry = l$messages[i];
        final lOther$messages$entry = lOther$messages[i];
        if (l$messages$entry != lOther$messages$entry) {
          return false;
        }
      }
    } else if (l$messages != lOther$messages) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$errors = errors;
    final l$messages = messages;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('errors')
          ? l$errors == null
              ? null
              : Object.hashAll(l$errors.map((v) => v))
          : const {},
      _$data.containsKey('messages')
          ? l$messages == null
              ? null
              : Object.hashAll(l$messages.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EchoCreateInput<TRes> {
  factory CopyWith$Input$EchoCreateInput(
    Input$EchoCreateInput instance,
    TRes Function(Input$EchoCreateInput) then,
  ) = _CopyWithImpl$Input$EchoCreateInput;

  factory CopyWith$Input$EchoCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EchoCreateInput;

  TRes call({
    String? clientMutationId,
    List<String>? errors,
    List<String>? messages,
  });
}

class _CopyWithImpl$Input$EchoCreateInput<TRes>
    implements CopyWith$Input$EchoCreateInput<TRes> {
  _CopyWithImpl$Input$EchoCreateInput(
    this._instance,
    this._then,
  );

  final Input$EchoCreateInput _instance;

  final TRes Function(Input$EchoCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? errors = _undefined,
    Object? messages = _undefined,
  }) =>
      _then(Input$EchoCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (errors != _undefined) 'errors': (errors as List<String>?),
        if (messages != _undefined) 'messages': (messages as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$EchoCreateInput<TRes>
    implements CopyWith$Input$EchoCreateInput<TRes> {
  _CopyWithStubImpl$Input$EchoCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? errors,
    List<String>? messages,
  }) =>
      _res;
}

class Input$EnableDevopsAdoptionNamespaceInput {
  factory Input$EnableDevopsAdoptionNamespaceInput({
    String? clientMutationId,
    required String namespaceId,
    String? displayNamespaceId,
  }) =>
      Input$EnableDevopsAdoptionNamespaceInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'namespaceId': namespaceId,
        if (displayNamespaceId != null)
          r'displayNamespaceId': displayNamespaceId,
      });

  Input$EnableDevopsAdoptionNamespaceInput._(this._$data);

  factory Input$EnableDevopsAdoptionNamespaceInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$namespaceId = data['namespaceId'];
    result$data['namespaceId'] = (l$namespaceId as String);
    if (data.containsKey('displayNamespaceId')) {
      final l$displayNamespaceId = data['displayNamespaceId'];
      result$data['displayNamespaceId'] = (l$displayNamespaceId as String?);
    }
    return Input$EnableDevopsAdoptionNamespaceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get namespaceId => (_$data['namespaceId'] as String);
  String? get displayNamespaceId => (_$data['displayNamespaceId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$namespaceId = namespaceId;
    result$data['namespaceId'] = l$namespaceId;
    if (_$data.containsKey('displayNamespaceId')) {
      final l$displayNamespaceId = displayNamespaceId;
      result$data['displayNamespaceId'] = l$displayNamespaceId;
    }
    return result$data;
  }

  CopyWith$Input$EnableDevopsAdoptionNamespaceInput<
          Input$EnableDevopsAdoptionNamespaceInput>
      get copyWith => CopyWith$Input$EnableDevopsAdoptionNamespaceInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnableDevopsAdoptionNamespaceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$namespaceId = namespaceId;
    final lOther$namespaceId = other.namespaceId;
    if (l$namespaceId != lOther$namespaceId) {
      return false;
    }
    final l$displayNamespaceId = displayNamespaceId;
    final lOther$displayNamespaceId = other.displayNamespaceId;
    if (_$data.containsKey('displayNamespaceId') !=
        other._$data.containsKey('displayNamespaceId')) {
      return false;
    }
    if (l$displayNamespaceId != lOther$displayNamespaceId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$namespaceId = namespaceId;
    final l$displayNamespaceId = displayNamespaceId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$namespaceId,
      _$data.containsKey('displayNamespaceId')
          ? l$displayNamespaceId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnableDevopsAdoptionNamespaceInput<TRes> {
  factory CopyWith$Input$EnableDevopsAdoptionNamespaceInput(
    Input$EnableDevopsAdoptionNamespaceInput instance,
    TRes Function(Input$EnableDevopsAdoptionNamespaceInput) then,
  ) = _CopyWithImpl$Input$EnableDevopsAdoptionNamespaceInput;

  factory CopyWith$Input$EnableDevopsAdoptionNamespaceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnableDevopsAdoptionNamespaceInput;

  TRes call({
    String? clientMutationId,
    String? namespaceId,
    String? displayNamespaceId,
  });
}

class _CopyWithImpl$Input$EnableDevopsAdoptionNamespaceInput<TRes>
    implements CopyWith$Input$EnableDevopsAdoptionNamespaceInput<TRes> {
  _CopyWithImpl$Input$EnableDevopsAdoptionNamespaceInput(
    this._instance,
    this._then,
  );

  final Input$EnableDevopsAdoptionNamespaceInput _instance;

  final TRes Function(Input$EnableDevopsAdoptionNamespaceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? namespaceId = _undefined,
    Object? displayNamespaceId = _undefined,
  }) =>
      _then(Input$EnableDevopsAdoptionNamespaceInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (namespaceId != _undefined && namespaceId != null)
          'namespaceId': (namespaceId as String),
        if (displayNamespaceId != _undefined)
          'displayNamespaceId': (displayNamespaceId as String?),
      }));
}

class _CopyWithStubImpl$Input$EnableDevopsAdoptionNamespaceInput<TRes>
    implements CopyWith$Input$EnableDevopsAdoptionNamespaceInput<TRes> {
  _CopyWithStubImpl$Input$EnableDevopsAdoptionNamespaceInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? namespaceId,
    String? displayNamespaceId,
  }) =>
      _res;
}

class Input$EnvironmentsCanaryIngressUpdateInput {
  factory Input$EnvironmentsCanaryIngressUpdateInput({
    String? clientMutationId,
    required String id,
    required int weight,
  }) =>
      Input$EnvironmentsCanaryIngressUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'weight': weight,
      });

  Input$EnvironmentsCanaryIngressUpdateInput._(this._$data);

  factory Input$EnvironmentsCanaryIngressUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$weight = data['weight'];
    result$data['weight'] = (l$weight as int);
    return Input$EnvironmentsCanaryIngressUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  int get weight => (_$data['weight'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$weight = weight;
    result$data['weight'] = l$weight;
    return result$data;
  }

  CopyWith$Input$EnvironmentsCanaryIngressUpdateInput<
          Input$EnvironmentsCanaryIngressUpdateInput>
      get copyWith => CopyWith$Input$EnvironmentsCanaryIngressUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnvironmentsCanaryIngressUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (l$weight != lOther$weight) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$weight = weight;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$weight,
    ]);
  }
}

abstract class CopyWith$Input$EnvironmentsCanaryIngressUpdateInput<TRes> {
  factory CopyWith$Input$EnvironmentsCanaryIngressUpdateInput(
    Input$EnvironmentsCanaryIngressUpdateInput instance,
    TRes Function(Input$EnvironmentsCanaryIngressUpdateInput) then,
  ) = _CopyWithImpl$Input$EnvironmentsCanaryIngressUpdateInput;

  factory CopyWith$Input$EnvironmentsCanaryIngressUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnvironmentsCanaryIngressUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    int? weight,
  });
}

class _CopyWithImpl$Input$EnvironmentsCanaryIngressUpdateInput<TRes>
    implements CopyWith$Input$EnvironmentsCanaryIngressUpdateInput<TRes> {
  _CopyWithImpl$Input$EnvironmentsCanaryIngressUpdateInput(
    this._instance,
    this._then,
  );

  final Input$EnvironmentsCanaryIngressUpdateInput _instance;

  final TRes Function(Input$EnvironmentsCanaryIngressUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? weight = _undefined,
  }) =>
      _then(Input$EnvironmentsCanaryIngressUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (weight != _undefined && weight != null) 'weight': (weight as int),
      }));
}

class _CopyWithStubImpl$Input$EnvironmentsCanaryIngressUpdateInput<TRes>
    implements CopyWith$Input$EnvironmentsCanaryIngressUpdateInput<TRes> {
  _CopyWithStubImpl$Input$EnvironmentsCanaryIngressUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    int? weight,
  }) =>
      _res;
}

class Input$EpicAddIssueInput {
  factory Input$EpicAddIssueInput({
    required String iid,
    required String groupPath,
    String? clientMutationId,
    required String projectPath,
    required String issueIid,
  }) =>
      Input$EpicAddIssueInput._({
        r'iid': iid,
        r'groupPath': groupPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'issueIid': issueIid,
      });

  Input$EpicAddIssueInput._(this._$data);

  factory Input$EpicAddIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$issueIid = data['issueIid'];
    result$data['issueIid'] = (l$issueIid as String);
    return Input$EpicAddIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get iid => (_$data['iid'] as String);
  String get groupPath => (_$data['groupPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get issueIid => (_$data['issueIid'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$iid = iid;
    result$data['iid'] = l$iid;
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$issueIid = issueIid;
    result$data['issueIid'] = l$issueIid;
    return result$data;
  }

  CopyWith$Input$EpicAddIssueInput<Input$EpicAddIssueInput> get copyWith =>
      CopyWith$Input$EpicAddIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicAddIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$issueIid = issueIid;
    final lOther$issueIid = other.issueIid;
    if (l$issueIid != lOther$issueIid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$iid = iid;
    final l$groupPath = groupPath;
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$issueIid = issueIid;
    return Object.hashAll([
      l$iid,
      l$groupPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$issueIid,
    ]);
  }
}

abstract class CopyWith$Input$EpicAddIssueInput<TRes> {
  factory CopyWith$Input$EpicAddIssueInput(
    Input$EpicAddIssueInput instance,
    TRes Function(Input$EpicAddIssueInput) then,
  ) = _CopyWithImpl$Input$EpicAddIssueInput;

  factory CopyWith$Input$EpicAddIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicAddIssueInput;

  TRes call({
    String? iid,
    String? groupPath,
    String? clientMutationId,
    String? projectPath,
    String? issueIid,
  });
}

class _CopyWithImpl$Input$EpicAddIssueInput<TRes>
    implements CopyWith$Input$EpicAddIssueInput<TRes> {
  _CopyWithImpl$Input$EpicAddIssueInput(
    this._instance,
    this._then,
  );

  final Input$EpicAddIssueInput _instance;

  final TRes Function(Input$EpicAddIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? iid = _undefined,
    Object? groupPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? issueIid = _undefined,
  }) =>
      _then(Input$EpicAddIssueInput._({
        ..._instance._$data,
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (issueIid != _undefined && issueIid != null)
          'issueIid': (issueIid as String),
      }));
}

class _CopyWithStubImpl$Input$EpicAddIssueInput<TRes>
    implements CopyWith$Input$EpicAddIssueInput<TRes> {
  _CopyWithStubImpl$Input$EpicAddIssueInput(this._res);

  TRes _res;

  call({
    String? iid,
    String? groupPath,
    String? clientMutationId,
    String? projectPath,
    String? issueIid,
  }) =>
      _res;
}

class Input$EpicBoardCreateInput {
  factory Input$EpicBoardCreateInput({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    List<String>? labels,
    List<String>? labelIds,
    String? groupPath,
  }) =>
      Input$EpicBoardCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (name != null) r'name': name,
        if (hideBacklogList != null) r'hideBacklogList': hideBacklogList,
        if (hideClosedList != null) r'hideClosedList': hideClosedList,
        if (labels != null) r'labels': labels,
        if (labelIds != null) r'labelIds': labelIds,
        if (groupPath != null) r'groupPath': groupPath,
      });

  Input$EpicBoardCreateInput._(this._$data);

  factory Input$EpicBoardCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = data['hideBacklogList'];
      result$data['hideBacklogList'] = (l$hideBacklogList as bool?);
    }
    if (data.containsKey('hideClosedList')) {
      final l$hideClosedList = data['hideClosedList'];
      result$data['hideClosedList'] = (l$hideClosedList as bool?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    return Input$EpicBoardCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get name => (_$data['name'] as String?);
  bool? get hideBacklogList => (_$data['hideBacklogList'] as bool?);
  bool? get hideClosedList => (_$data['hideClosedList'] as bool?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  String? get groupPath => (_$data['groupPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = hideBacklogList;
      result$data['hideBacklogList'] = l$hideBacklogList;
    }
    if (_$data.containsKey('hideClosedList')) {
      final l$hideClosedList = hideClosedList;
      result$data['hideClosedList'] = l$hideClosedList;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    return result$data;
  }

  CopyWith$Input$EpicBoardCreateInput<Input$EpicBoardCreateInput>
      get copyWith => CopyWith$Input$EpicBoardCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicBoardCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$hideBacklogList = hideBacklogList;
    final lOther$hideBacklogList = other.hideBacklogList;
    if (_$data.containsKey('hideBacklogList') !=
        other._$data.containsKey('hideBacklogList')) {
      return false;
    }
    if (l$hideBacklogList != lOther$hideBacklogList) {
      return false;
    }
    final l$hideClosedList = hideClosedList;
    final lOther$hideClosedList = other.hideClosedList;
    if (_$data.containsKey('hideClosedList') !=
        other._$data.containsKey('hideClosedList')) {
      return false;
    }
    if (l$hideClosedList != lOther$hideClosedList) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$hideBacklogList = hideBacklogList;
    final l$hideClosedList = hideClosedList;
    final l$labels = labels;
    final l$labelIds = labelIds;
    final l$groupPath = groupPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('hideBacklogList') ? l$hideBacklogList : const {},
      _$data.containsKey('hideClosedList') ? l$hideClosedList : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
    ]);
  }
}

abstract class CopyWith$Input$EpicBoardCreateInput<TRes> {
  factory CopyWith$Input$EpicBoardCreateInput(
    Input$EpicBoardCreateInput instance,
    TRes Function(Input$EpicBoardCreateInput) then,
  ) = _CopyWithImpl$Input$EpicBoardCreateInput;

  factory CopyWith$Input$EpicBoardCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicBoardCreateInput;

  TRes call({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    List<String>? labels,
    List<String>? labelIds,
    String? groupPath,
  });
}

class _CopyWithImpl$Input$EpicBoardCreateInput<TRes>
    implements CopyWith$Input$EpicBoardCreateInput<TRes> {
  _CopyWithImpl$Input$EpicBoardCreateInput(
    this._instance,
    this._then,
  );

  final Input$EpicBoardCreateInput _instance;

  final TRes Function(Input$EpicBoardCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? hideBacklogList = _undefined,
    Object? hideClosedList = _undefined,
    Object? labels = _undefined,
    Object? labelIds = _undefined,
    Object? groupPath = _undefined,
  }) =>
      _then(Input$EpicBoardCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (hideBacklogList != _undefined)
          'hideBacklogList': (hideBacklogList as bool?),
        if (hideClosedList != _undefined)
          'hideClosedList': (hideClosedList as bool?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
      }));
}

class _CopyWithStubImpl$Input$EpicBoardCreateInput<TRes>
    implements CopyWith$Input$EpicBoardCreateInput<TRes> {
  _CopyWithStubImpl$Input$EpicBoardCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    List<String>? labels,
    List<String>? labelIds,
    String? groupPath,
  }) =>
      _res;
}

class Input$EpicBoardListCreateInput {
  factory Input$EpicBoardListCreateInput({
    bool? backlog,
    String? labelId,
    String? clientMutationId,
    required String boardId,
  }) =>
      Input$EpicBoardListCreateInput._({
        if (backlog != null) r'backlog': backlog,
        if (labelId != null) r'labelId': labelId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'boardId': boardId,
      });

  Input$EpicBoardListCreateInput._(this._$data);

  factory Input$EpicBoardListCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('backlog')) {
      final l$backlog = data['backlog'];
      result$data['backlog'] = (l$backlog as bool?);
    }
    if (data.containsKey('labelId')) {
      final l$labelId = data['labelId'];
      result$data['labelId'] = (l$labelId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$boardId = data['boardId'];
    result$data['boardId'] = (l$boardId as String);
    return Input$EpicBoardListCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get backlog => (_$data['backlog'] as bool?);
  String? get labelId => (_$data['labelId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get boardId => (_$data['boardId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('backlog')) {
      final l$backlog = backlog;
      result$data['backlog'] = l$backlog;
    }
    if (_$data.containsKey('labelId')) {
      final l$labelId = labelId;
      result$data['labelId'] = l$labelId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$boardId = boardId;
    result$data['boardId'] = l$boardId;
    return result$data;
  }

  CopyWith$Input$EpicBoardListCreateInput<Input$EpicBoardListCreateInput>
      get copyWith => CopyWith$Input$EpicBoardListCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicBoardListCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$backlog = backlog;
    final lOther$backlog = other.backlog;
    if (_$data.containsKey('backlog') != other._$data.containsKey('backlog')) {
      return false;
    }
    if (l$backlog != lOther$backlog) {
      return false;
    }
    final l$labelId = labelId;
    final lOther$labelId = other.labelId;
    if (_$data.containsKey('labelId') != other._$data.containsKey('labelId')) {
      return false;
    }
    if (l$labelId != lOther$labelId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$boardId = boardId;
    final lOther$boardId = other.boardId;
    if (l$boardId != lOther$boardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$backlog = backlog;
    final l$labelId = labelId;
    final l$clientMutationId = clientMutationId;
    final l$boardId = boardId;
    return Object.hashAll([
      _$data.containsKey('backlog') ? l$backlog : const {},
      _$data.containsKey('labelId') ? l$labelId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$boardId,
    ]);
  }
}

abstract class CopyWith$Input$EpicBoardListCreateInput<TRes> {
  factory CopyWith$Input$EpicBoardListCreateInput(
    Input$EpicBoardListCreateInput instance,
    TRes Function(Input$EpicBoardListCreateInput) then,
  ) = _CopyWithImpl$Input$EpicBoardListCreateInput;

  factory CopyWith$Input$EpicBoardListCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicBoardListCreateInput;

  TRes call({
    bool? backlog,
    String? labelId,
    String? clientMutationId,
    String? boardId,
  });
}

class _CopyWithImpl$Input$EpicBoardListCreateInput<TRes>
    implements CopyWith$Input$EpicBoardListCreateInput<TRes> {
  _CopyWithImpl$Input$EpicBoardListCreateInput(
    this._instance,
    this._then,
  );

  final Input$EpicBoardListCreateInput _instance;

  final TRes Function(Input$EpicBoardListCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? backlog = _undefined,
    Object? labelId = _undefined,
    Object? clientMutationId = _undefined,
    Object? boardId = _undefined,
  }) =>
      _then(Input$EpicBoardListCreateInput._({
        ..._instance._$data,
        if (backlog != _undefined) 'backlog': (backlog as bool?),
        if (labelId != _undefined) 'labelId': (labelId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (boardId != _undefined && boardId != null)
          'boardId': (boardId as String),
      }));
}

class _CopyWithStubImpl$Input$EpicBoardListCreateInput<TRes>
    implements CopyWith$Input$EpicBoardListCreateInput<TRes> {
  _CopyWithStubImpl$Input$EpicBoardListCreateInput(this._res);

  TRes _res;

  call({
    bool? backlog,
    String? labelId,
    String? clientMutationId,
    String? boardId,
  }) =>
      _res;
}

class Input$EpicBoardListDestroyInput {
  factory Input$EpicBoardListDestroyInput({
    String? clientMutationId,
    required String listId,
  }) =>
      Input$EpicBoardListDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
      });

  Input$EpicBoardListDestroyInput._(this._$data);

  factory Input$EpicBoardListDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    return Input$EpicBoardListDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get listId => (_$data['listId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    return result$data;
  }

  CopyWith$Input$EpicBoardListDestroyInput<Input$EpicBoardListDestroyInput>
      get copyWith => CopyWith$Input$EpicBoardListDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicBoardListDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
    ]);
  }
}

abstract class CopyWith$Input$EpicBoardListDestroyInput<TRes> {
  factory CopyWith$Input$EpicBoardListDestroyInput(
    Input$EpicBoardListDestroyInput instance,
    TRes Function(Input$EpicBoardListDestroyInput) then,
  ) = _CopyWithImpl$Input$EpicBoardListDestroyInput;

  factory CopyWith$Input$EpicBoardListDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicBoardListDestroyInput;

  TRes call({
    String? clientMutationId,
    String? listId,
  });
}

class _CopyWithImpl$Input$EpicBoardListDestroyInput<TRes>
    implements CopyWith$Input$EpicBoardListDestroyInput<TRes> {
  _CopyWithImpl$Input$EpicBoardListDestroyInput(
    this._instance,
    this._then,
  );

  final Input$EpicBoardListDestroyInput _instance;

  final TRes Function(Input$EpicBoardListDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
  }) =>
      _then(Input$EpicBoardListDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
      }));
}

class _CopyWithStubImpl$Input$EpicBoardListDestroyInput<TRes>
    implements CopyWith$Input$EpicBoardListDestroyInput<TRes> {
  _CopyWithStubImpl$Input$EpicBoardListDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? listId,
  }) =>
      _res;
}

class Input$EpicBoardUpdateInput {
  factory Input$EpicBoardUpdateInput({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    List<String>? labels,
    List<String>? labelIds,
    required String id,
  }) =>
      Input$EpicBoardUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (name != null) r'name': name,
        if (hideBacklogList != null) r'hideBacklogList': hideBacklogList,
        if (hideClosedList != null) r'hideClosedList': hideClosedList,
        if (labels != null) r'labels': labels,
        if (labelIds != null) r'labelIds': labelIds,
        r'id': id,
      });

  Input$EpicBoardUpdateInput._(this._$data);

  factory Input$EpicBoardUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = data['hideBacklogList'];
      result$data['hideBacklogList'] = (l$hideBacklogList as bool?);
    }
    if (data.containsKey('hideClosedList')) {
      final l$hideClosedList = data['hideClosedList'];
      result$data['hideClosedList'] = (l$hideClosedList as bool?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$EpicBoardUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get name => (_$data['name'] as String?);
  bool? get hideBacklogList => (_$data['hideBacklogList'] as bool?);
  bool? get hideClosedList => (_$data['hideClosedList'] as bool?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = hideBacklogList;
      result$data['hideBacklogList'] = l$hideBacklogList;
    }
    if (_$data.containsKey('hideClosedList')) {
      final l$hideClosedList = hideClosedList;
      result$data['hideClosedList'] = l$hideClosedList;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$EpicBoardUpdateInput<Input$EpicBoardUpdateInput>
      get copyWith => CopyWith$Input$EpicBoardUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicBoardUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$hideBacklogList = hideBacklogList;
    final lOther$hideBacklogList = other.hideBacklogList;
    if (_$data.containsKey('hideBacklogList') !=
        other._$data.containsKey('hideBacklogList')) {
      return false;
    }
    if (l$hideBacklogList != lOther$hideBacklogList) {
      return false;
    }
    final l$hideClosedList = hideClosedList;
    final lOther$hideClosedList = other.hideClosedList;
    if (_$data.containsKey('hideClosedList') !=
        other._$data.containsKey('hideClosedList')) {
      return false;
    }
    if (l$hideClosedList != lOther$hideClosedList) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$hideBacklogList = hideBacklogList;
    final l$hideClosedList = hideClosedList;
    final l$labels = labels;
    final l$labelIds = labelIds;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('hideBacklogList') ? l$hideBacklogList : const {},
      _$data.containsKey('hideClosedList') ? l$hideClosedList : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$EpicBoardUpdateInput<TRes> {
  factory CopyWith$Input$EpicBoardUpdateInput(
    Input$EpicBoardUpdateInput instance,
    TRes Function(Input$EpicBoardUpdateInput) then,
  ) = _CopyWithImpl$Input$EpicBoardUpdateInput;

  factory CopyWith$Input$EpicBoardUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicBoardUpdateInput;

  TRes call({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    List<String>? labels,
    List<String>? labelIds,
    String? id,
  });
}

class _CopyWithImpl$Input$EpicBoardUpdateInput<TRes>
    implements CopyWith$Input$EpicBoardUpdateInput<TRes> {
  _CopyWithImpl$Input$EpicBoardUpdateInput(
    this._instance,
    this._then,
  );

  final Input$EpicBoardUpdateInput _instance;

  final TRes Function(Input$EpicBoardUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? hideBacklogList = _undefined,
    Object? hideClosedList = _undefined,
    Object? labels = _undefined,
    Object? labelIds = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$EpicBoardUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (hideBacklogList != _undefined)
          'hideBacklogList': (hideBacklogList as bool?),
        if (hideClosedList != _undefined)
          'hideClosedList': (hideClosedList as bool?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$EpicBoardUpdateInput<TRes>
    implements CopyWith$Input$EpicBoardUpdateInput<TRes> {
  _CopyWithStubImpl$Input$EpicBoardUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    List<String>? labels,
    List<String>? labelIds,
    String? id,
  }) =>
      _res;
}

class Input$EpicFilters {
  factory Input$EpicFilters({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    Input$NegatedEpicBoardIssueInput? not,
    String? search,
    bool? confidential,
  }) =>
      Input$EpicFilters._({
        if (labelName != null) r'labelName': labelName,
        if (authorUsername != null) r'authorUsername': authorUsername,
        if (myReactionEmoji != null) r'myReactionEmoji': myReactionEmoji,
        if (not != null) r'not': not,
        if (search != null) r'search': search,
        if (confidential != null) r'confidential': confidential,
      });

  Input$EpicFilters._(this._$data);

  factory Input$EpicFilters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('labelName')) {
      final l$labelName = data['labelName'];
      result$data['labelName'] =
          (l$labelName as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as String?);
    }
    if (data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = data['myReactionEmoji'];
      result$data['myReactionEmoji'] = (l$myReactionEmoji as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NegatedEpicBoardIssueInput.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    return Input$EpicFilters._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get labelName => (_$data['labelName'] as List<String?>?);
  String? get authorUsername => (_$data['authorUsername'] as String?);
  String? get myReactionEmoji => (_$data['myReactionEmoji'] as String?);
  Input$NegatedEpicBoardIssueInput? get not =>
      (_$data['not'] as Input$NegatedEpicBoardIssueInput?);
  String? get search => (_$data['search'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('labelName')) {
      final l$labelName = labelName;
      result$data['labelName'] = l$labelName?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername;
    }
    if (_$data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = myReactionEmoji;
      result$data['myReactionEmoji'] = l$myReactionEmoji;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    return result$data;
  }

  CopyWith$Input$EpicFilters<Input$EpicFilters> get copyWith =>
      CopyWith$Input$EpicFilters(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicFilters) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelName = labelName;
    final lOther$labelName = other.labelName;
    if (_$data.containsKey('labelName') !=
        other._$data.containsKey('labelName')) {
      return false;
    }
    if (l$labelName != null && lOther$labelName != null) {
      if (l$labelName.length != lOther$labelName.length) {
        return false;
      }
      for (int i = 0; i < l$labelName.length; i++) {
        final l$labelName$entry = l$labelName[i];
        final lOther$labelName$entry = lOther$labelName[i];
        if (l$labelName$entry != lOther$labelName$entry) {
          return false;
        }
      }
    } else if (l$labelName != lOther$labelName) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$myReactionEmoji = myReactionEmoji;
    final lOther$myReactionEmoji = other.myReactionEmoji;
    if (_$data.containsKey('myReactionEmoji') !=
        other._$data.containsKey('myReactionEmoji')) {
      return false;
    }
    if (l$myReactionEmoji != lOther$myReactionEmoji) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelName = labelName;
    final l$authorUsername = authorUsername;
    final l$myReactionEmoji = myReactionEmoji;
    final l$not = not;
    final l$search = search;
    final l$confidential = confidential;
    return Object.hashAll([
      _$data.containsKey('labelName')
          ? l$labelName == null
              ? null
              : Object.hashAll(l$labelName.map((v) => v))
          : const {},
      _$data.containsKey('authorUsername') ? l$authorUsername : const {},
      _$data.containsKey('myReactionEmoji') ? l$myReactionEmoji : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
    ]);
  }
}

abstract class CopyWith$Input$EpicFilters<TRes> {
  factory CopyWith$Input$EpicFilters(
    Input$EpicFilters instance,
    TRes Function(Input$EpicFilters) then,
  ) = _CopyWithImpl$Input$EpicFilters;

  factory CopyWith$Input$EpicFilters.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicFilters;

  TRes call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    Input$NegatedEpicBoardIssueInput? not,
    String? search,
    bool? confidential,
  });
  CopyWith$Input$NegatedEpicBoardIssueInput<TRes> get not;
}

class _CopyWithImpl$Input$EpicFilters<TRes>
    implements CopyWith$Input$EpicFilters<TRes> {
  _CopyWithImpl$Input$EpicFilters(
    this._instance,
    this._then,
  );

  final Input$EpicFilters _instance;

  final TRes Function(Input$EpicFilters) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? labelName = _undefined,
    Object? authorUsername = _undefined,
    Object? myReactionEmoji = _undefined,
    Object? not = _undefined,
    Object? search = _undefined,
    Object? confidential = _undefined,
  }) =>
      _then(Input$EpicFilters._({
        ..._instance._$data,
        if (labelName != _undefined) 'labelName': (labelName as List<String?>?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as String?),
        if (myReactionEmoji != _undefined)
          'myReactionEmoji': (myReactionEmoji as String?),
        if (not != _undefined)
          'not': (not as Input$NegatedEpicBoardIssueInput?),
        if (search != _undefined) 'search': (search as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
      }));
  CopyWith$Input$NegatedEpicBoardIssueInput<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NegatedEpicBoardIssueInput.stub(_then(_instance))
        : CopyWith$Input$NegatedEpicBoardIssueInput(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EpicFilters<TRes>
    implements CopyWith$Input$EpicFilters<TRes> {
  _CopyWithStubImpl$Input$EpicFilters(this._res);

  TRes _res;

  call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    Input$NegatedEpicBoardIssueInput? not,
    String? search,
    bool? confidential,
  }) =>
      _res;
  CopyWith$Input$NegatedEpicBoardIssueInput<TRes> get not =>
      CopyWith$Input$NegatedEpicBoardIssueInput.stub(_res);
}

class Input$EpicMoveListInput {
  factory Input$EpicMoveListInput({
    String? clientMutationId,
    required String boardId,
    required String epicId,
    String? fromListId,
    required String toListId,
    String? moveBeforeId,
    String? moveAfterId,
  }) =>
      Input$EpicMoveListInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'boardId': boardId,
        r'epicId': epicId,
        if (fromListId != null) r'fromListId': fromListId,
        r'toListId': toListId,
        if (moveBeforeId != null) r'moveBeforeId': moveBeforeId,
        if (moveAfterId != null) r'moveAfterId': moveAfterId,
      });

  Input$EpicMoveListInput._(this._$data);

  factory Input$EpicMoveListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$boardId = data['boardId'];
    result$data['boardId'] = (l$boardId as String);
    final l$epicId = data['epicId'];
    result$data['epicId'] = (l$epicId as String);
    if (data.containsKey('fromListId')) {
      final l$fromListId = data['fromListId'];
      result$data['fromListId'] = (l$fromListId as String?);
    }
    final l$toListId = data['toListId'];
    result$data['toListId'] = (l$toListId as String);
    if (data.containsKey('moveBeforeId')) {
      final l$moveBeforeId = data['moveBeforeId'];
      result$data['moveBeforeId'] = (l$moveBeforeId as String?);
    }
    if (data.containsKey('moveAfterId')) {
      final l$moveAfterId = data['moveAfterId'];
      result$data['moveAfterId'] = (l$moveAfterId as String?);
    }
    return Input$EpicMoveListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get boardId => (_$data['boardId'] as String);
  String get epicId => (_$data['epicId'] as String);
  String? get fromListId => (_$data['fromListId'] as String?);
  String get toListId => (_$data['toListId'] as String);
  String? get moveBeforeId => (_$data['moveBeforeId'] as String?);
  String? get moveAfterId => (_$data['moveAfterId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$boardId = boardId;
    result$data['boardId'] = l$boardId;
    final l$epicId = epicId;
    result$data['epicId'] = l$epicId;
    if (_$data.containsKey('fromListId')) {
      final l$fromListId = fromListId;
      result$data['fromListId'] = l$fromListId;
    }
    final l$toListId = toListId;
    result$data['toListId'] = l$toListId;
    if (_$data.containsKey('moveBeforeId')) {
      final l$moveBeforeId = moveBeforeId;
      result$data['moveBeforeId'] = l$moveBeforeId;
    }
    if (_$data.containsKey('moveAfterId')) {
      final l$moveAfterId = moveAfterId;
      result$data['moveAfterId'] = l$moveAfterId;
    }
    return result$data;
  }

  CopyWith$Input$EpicMoveListInput<Input$EpicMoveListInput> get copyWith =>
      CopyWith$Input$EpicMoveListInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicMoveListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$boardId = boardId;
    final lOther$boardId = other.boardId;
    if (l$boardId != lOther$boardId) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (l$epicId != lOther$epicId) {
      return false;
    }
    final l$fromListId = fromListId;
    final lOther$fromListId = other.fromListId;
    if (_$data.containsKey('fromListId') !=
        other._$data.containsKey('fromListId')) {
      return false;
    }
    if (l$fromListId != lOther$fromListId) {
      return false;
    }
    final l$toListId = toListId;
    final lOther$toListId = other.toListId;
    if (l$toListId != lOther$toListId) {
      return false;
    }
    final l$moveBeforeId = moveBeforeId;
    final lOther$moveBeforeId = other.moveBeforeId;
    if (_$data.containsKey('moveBeforeId') !=
        other._$data.containsKey('moveBeforeId')) {
      return false;
    }
    if (l$moveBeforeId != lOther$moveBeforeId) {
      return false;
    }
    final l$moveAfterId = moveAfterId;
    final lOther$moveAfterId = other.moveAfterId;
    if (_$data.containsKey('moveAfterId') !=
        other._$data.containsKey('moveAfterId')) {
      return false;
    }
    if (l$moveAfterId != lOther$moveAfterId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$boardId = boardId;
    final l$epicId = epicId;
    final l$fromListId = fromListId;
    final l$toListId = toListId;
    final l$moveBeforeId = moveBeforeId;
    final l$moveAfterId = moveAfterId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$boardId,
      l$epicId,
      _$data.containsKey('fromListId') ? l$fromListId : const {},
      l$toListId,
      _$data.containsKey('moveBeforeId') ? l$moveBeforeId : const {},
      _$data.containsKey('moveAfterId') ? l$moveAfterId : const {},
    ]);
  }
}

abstract class CopyWith$Input$EpicMoveListInput<TRes> {
  factory CopyWith$Input$EpicMoveListInput(
    Input$EpicMoveListInput instance,
    TRes Function(Input$EpicMoveListInput) then,
  ) = _CopyWithImpl$Input$EpicMoveListInput;

  factory CopyWith$Input$EpicMoveListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicMoveListInput;

  TRes call({
    String? clientMutationId,
    String? boardId,
    String? epicId,
    String? fromListId,
    String? toListId,
    String? moveBeforeId,
    String? moveAfterId,
  });
}

class _CopyWithImpl$Input$EpicMoveListInput<TRes>
    implements CopyWith$Input$EpicMoveListInput<TRes> {
  _CopyWithImpl$Input$EpicMoveListInput(
    this._instance,
    this._then,
  );

  final Input$EpicMoveListInput _instance;

  final TRes Function(Input$EpicMoveListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? boardId = _undefined,
    Object? epicId = _undefined,
    Object? fromListId = _undefined,
    Object? toListId = _undefined,
    Object? moveBeforeId = _undefined,
    Object? moveAfterId = _undefined,
  }) =>
      _then(Input$EpicMoveListInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (boardId != _undefined && boardId != null)
          'boardId': (boardId as String),
        if (epicId != _undefined && epicId != null)
          'epicId': (epicId as String),
        if (fromListId != _undefined) 'fromListId': (fromListId as String?),
        if (toListId != _undefined && toListId != null)
          'toListId': (toListId as String),
        if (moveBeforeId != _undefined)
          'moveBeforeId': (moveBeforeId as String?),
        if (moveAfterId != _undefined) 'moveAfterId': (moveAfterId as String?),
      }));
}

class _CopyWithStubImpl$Input$EpicMoveListInput<TRes>
    implements CopyWith$Input$EpicMoveListInput<TRes> {
  _CopyWithStubImpl$Input$EpicMoveListInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? boardId,
    String? epicId,
    String? fromListId,
    String? toListId,
    String? moveBeforeId,
    String? moveAfterId,
  }) =>
      _res;
}

class Input$EpicSetSubscriptionInput {
  factory Input$EpicSetSubscriptionInput({
    required String iid,
    required String groupPath,
    String? clientMutationId,
    required bool subscribedState,
  }) =>
      Input$EpicSetSubscriptionInput._({
        r'iid': iid,
        r'groupPath': groupPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subscribedState': subscribedState,
      });

  Input$EpicSetSubscriptionInput._(this._$data);

  factory Input$EpicSetSubscriptionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subscribedState = data['subscribedState'];
    result$data['subscribedState'] = (l$subscribedState as bool);
    return Input$EpicSetSubscriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get iid => (_$data['iid'] as String);
  String get groupPath => (_$data['groupPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get subscribedState => (_$data['subscribedState'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$iid = iid;
    result$data['iid'] = l$iid;
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subscribedState = subscribedState;
    result$data['subscribedState'] = l$subscribedState;
    return result$data;
  }

  CopyWith$Input$EpicSetSubscriptionInput<Input$EpicSetSubscriptionInput>
      get copyWith => CopyWith$Input$EpicSetSubscriptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicSetSubscriptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subscribedState = subscribedState;
    final lOther$subscribedState = other.subscribedState;
    if (l$subscribedState != lOther$subscribedState) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$iid = iid;
    final l$groupPath = groupPath;
    final l$clientMutationId = clientMutationId;
    final l$subscribedState = subscribedState;
    return Object.hashAll([
      l$iid,
      l$groupPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subscribedState,
    ]);
  }
}

abstract class CopyWith$Input$EpicSetSubscriptionInput<TRes> {
  factory CopyWith$Input$EpicSetSubscriptionInput(
    Input$EpicSetSubscriptionInput instance,
    TRes Function(Input$EpicSetSubscriptionInput) then,
  ) = _CopyWithImpl$Input$EpicSetSubscriptionInput;

  factory CopyWith$Input$EpicSetSubscriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicSetSubscriptionInput;

  TRes call({
    String? iid,
    String? groupPath,
    String? clientMutationId,
    bool? subscribedState,
  });
}

class _CopyWithImpl$Input$EpicSetSubscriptionInput<TRes>
    implements CopyWith$Input$EpicSetSubscriptionInput<TRes> {
  _CopyWithImpl$Input$EpicSetSubscriptionInput(
    this._instance,
    this._then,
  );

  final Input$EpicSetSubscriptionInput _instance;

  final TRes Function(Input$EpicSetSubscriptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? iid = _undefined,
    Object? groupPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? subscribedState = _undefined,
  }) =>
      _then(Input$EpicSetSubscriptionInput._({
        ..._instance._$data,
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subscribedState != _undefined && subscribedState != null)
          'subscribedState': (subscribedState as bool),
      }));
}

class _CopyWithStubImpl$Input$EpicSetSubscriptionInput<TRes>
    implements CopyWith$Input$EpicSetSubscriptionInput<TRes> {
  _CopyWithStubImpl$Input$EpicSetSubscriptionInput(this._res);

  TRes _res;

  call({
    String? iid,
    String? groupPath,
    String? clientMutationId,
    bool? subscribedState,
  }) =>
      _res;
}

class Input$EpicTreeNodeFieldsInputType {
  factory Input$EpicTreeNodeFieldsInputType({
    required String id,
    String? adjacentReferenceId,
    Enum$MoveType? relativePosition,
    String? newParentId,
  }) =>
      Input$EpicTreeNodeFieldsInputType._({
        r'id': id,
        if (adjacentReferenceId != null)
          r'adjacentReferenceId': adjacentReferenceId,
        if (relativePosition != null) r'relativePosition': relativePosition,
        if (newParentId != null) r'newParentId': newParentId,
      });

  Input$EpicTreeNodeFieldsInputType._(this._$data);

  factory Input$EpicTreeNodeFieldsInputType.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('adjacentReferenceId')) {
      final l$adjacentReferenceId = data['adjacentReferenceId'];
      result$data['adjacentReferenceId'] = (l$adjacentReferenceId as String?);
    }
    if (data.containsKey('relativePosition')) {
      final l$relativePosition = data['relativePosition'];
      result$data['relativePosition'] = l$relativePosition == null
          ? null
          : fromJson$Enum$MoveType((l$relativePosition as String));
    }
    if (data.containsKey('newParentId')) {
      final l$newParentId = data['newParentId'];
      result$data['newParentId'] = (l$newParentId as String?);
    }
    return Input$EpicTreeNodeFieldsInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get adjacentReferenceId => (_$data['adjacentReferenceId'] as String?);
  Enum$MoveType? get relativePosition =>
      (_$data['relativePosition'] as Enum$MoveType?);
  String? get newParentId => (_$data['newParentId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('adjacentReferenceId')) {
      final l$adjacentReferenceId = adjacentReferenceId;
      result$data['adjacentReferenceId'] = l$adjacentReferenceId;
    }
    if (_$data.containsKey('relativePosition')) {
      final l$relativePosition = relativePosition;
      result$data['relativePosition'] = l$relativePosition == null
          ? null
          : toJson$Enum$MoveType(l$relativePosition);
    }
    if (_$data.containsKey('newParentId')) {
      final l$newParentId = newParentId;
      result$data['newParentId'] = l$newParentId;
    }
    return result$data;
  }

  CopyWith$Input$EpicTreeNodeFieldsInputType<Input$EpicTreeNodeFieldsInputType>
      get copyWith => CopyWith$Input$EpicTreeNodeFieldsInputType(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicTreeNodeFieldsInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$adjacentReferenceId = adjacentReferenceId;
    final lOther$adjacentReferenceId = other.adjacentReferenceId;
    if (_$data.containsKey('adjacentReferenceId') !=
        other._$data.containsKey('adjacentReferenceId')) {
      return false;
    }
    if (l$adjacentReferenceId != lOther$adjacentReferenceId) {
      return false;
    }
    final l$relativePosition = relativePosition;
    final lOther$relativePosition = other.relativePosition;
    if (_$data.containsKey('relativePosition') !=
        other._$data.containsKey('relativePosition')) {
      return false;
    }
    if (l$relativePosition != lOther$relativePosition) {
      return false;
    }
    final l$newParentId = newParentId;
    final lOther$newParentId = other.newParentId;
    if (_$data.containsKey('newParentId') !=
        other._$data.containsKey('newParentId')) {
      return false;
    }
    if (l$newParentId != lOther$newParentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$adjacentReferenceId = adjacentReferenceId;
    final l$relativePosition = relativePosition;
    final l$newParentId = newParentId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('adjacentReferenceId')
          ? l$adjacentReferenceId
          : const {},
      _$data.containsKey('relativePosition') ? l$relativePosition : const {},
      _$data.containsKey('newParentId') ? l$newParentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$EpicTreeNodeFieldsInputType<TRes> {
  factory CopyWith$Input$EpicTreeNodeFieldsInputType(
    Input$EpicTreeNodeFieldsInputType instance,
    TRes Function(Input$EpicTreeNodeFieldsInputType) then,
  ) = _CopyWithImpl$Input$EpicTreeNodeFieldsInputType;

  factory CopyWith$Input$EpicTreeNodeFieldsInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicTreeNodeFieldsInputType;

  TRes call({
    String? id,
    String? adjacentReferenceId,
    Enum$MoveType? relativePosition,
    String? newParentId,
  });
}

class _CopyWithImpl$Input$EpicTreeNodeFieldsInputType<TRes>
    implements CopyWith$Input$EpicTreeNodeFieldsInputType<TRes> {
  _CopyWithImpl$Input$EpicTreeNodeFieldsInputType(
    this._instance,
    this._then,
  );

  final Input$EpicTreeNodeFieldsInputType _instance;

  final TRes Function(Input$EpicTreeNodeFieldsInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? adjacentReferenceId = _undefined,
    Object? relativePosition = _undefined,
    Object? newParentId = _undefined,
  }) =>
      _then(Input$EpicTreeNodeFieldsInputType._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (adjacentReferenceId != _undefined)
          'adjacentReferenceId': (adjacentReferenceId as String?),
        if (relativePosition != _undefined)
          'relativePosition': (relativePosition as Enum$MoveType?),
        if (newParentId != _undefined) 'newParentId': (newParentId as String?),
      }));
}

class _CopyWithStubImpl$Input$EpicTreeNodeFieldsInputType<TRes>
    implements CopyWith$Input$EpicTreeNodeFieldsInputType<TRes> {
  _CopyWithStubImpl$Input$EpicTreeNodeFieldsInputType(this._res);

  TRes _res;

  call({
    String? id,
    String? adjacentReferenceId,
    Enum$MoveType? relativePosition,
    String? newParentId,
  }) =>
      _res;
}

class Input$EpicTreeReorderInput {
  factory Input$EpicTreeReorderInput({
    String? clientMutationId,
    required String baseEpicId,
    required Input$EpicTreeNodeFieldsInputType moved,
  }) =>
      Input$EpicTreeReorderInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'baseEpicId': baseEpicId,
        r'moved': moved,
      });

  Input$EpicTreeReorderInput._(this._$data);

  factory Input$EpicTreeReorderInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$baseEpicId = data['baseEpicId'];
    result$data['baseEpicId'] = (l$baseEpicId as String);
    final l$moved = data['moved'];
    result$data['moved'] = Input$EpicTreeNodeFieldsInputType.fromJson(
        (l$moved as Map<String, dynamic>));
    return Input$EpicTreeReorderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get baseEpicId => (_$data['baseEpicId'] as String);
  Input$EpicTreeNodeFieldsInputType get moved =>
      (_$data['moved'] as Input$EpicTreeNodeFieldsInputType);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$baseEpicId = baseEpicId;
    result$data['baseEpicId'] = l$baseEpicId;
    final l$moved = moved;
    result$data['moved'] = l$moved.toJson();
    return result$data;
  }

  CopyWith$Input$EpicTreeReorderInput<Input$EpicTreeReorderInput>
      get copyWith => CopyWith$Input$EpicTreeReorderInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EpicTreeReorderInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$baseEpicId = baseEpicId;
    final lOther$baseEpicId = other.baseEpicId;
    if (l$baseEpicId != lOther$baseEpicId) {
      return false;
    }
    final l$moved = moved;
    final lOther$moved = other.moved;
    if (l$moved != lOther$moved) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$baseEpicId = baseEpicId;
    final l$moved = moved;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$baseEpicId,
      l$moved,
    ]);
  }
}

abstract class CopyWith$Input$EpicTreeReorderInput<TRes> {
  factory CopyWith$Input$EpicTreeReorderInput(
    Input$EpicTreeReorderInput instance,
    TRes Function(Input$EpicTreeReorderInput) then,
  ) = _CopyWithImpl$Input$EpicTreeReorderInput;

  factory CopyWith$Input$EpicTreeReorderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EpicTreeReorderInput;

  TRes call({
    String? clientMutationId,
    String? baseEpicId,
    Input$EpicTreeNodeFieldsInputType? moved,
  });
  CopyWith$Input$EpicTreeNodeFieldsInputType<TRes> get moved;
}

class _CopyWithImpl$Input$EpicTreeReorderInput<TRes>
    implements CopyWith$Input$EpicTreeReorderInput<TRes> {
  _CopyWithImpl$Input$EpicTreeReorderInput(
    this._instance,
    this._then,
  );

  final Input$EpicTreeReorderInput _instance;

  final TRes Function(Input$EpicTreeReorderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? baseEpicId = _undefined,
    Object? moved = _undefined,
  }) =>
      _then(Input$EpicTreeReorderInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (baseEpicId != _undefined && baseEpicId != null)
          'baseEpicId': (baseEpicId as String),
        if (moved != _undefined && moved != null)
          'moved': (moved as Input$EpicTreeNodeFieldsInputType),
      }));
  CopyWith$Input$EpicTreeNodeFieldsInputType<TRes> get moved {
    final local$moved = _instance.moved;
    return CopyWith$Input$EpicTreeNodeFieldsInputType(
        local$moved, (e) => call(moved: e));
  }
}

class _CopyWithStubImpl$Input$EpicTreeReorderInput<TRes>
    implements CopyWith$Input$EpicTreeReorderInput<TRes> {
  _CopyWithStubImpl$Input$EpicTreeReorderInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? baseEpicId,
    Input$EpicTreeNodeFieldsInputType? moved,
  }) =>
      _res;
  CopyWith$Input$EpicTreeNodeFieldsInputType<TRes> get moved =>
      CopyWith$Input$EpicTreeNodeFieldsInputType.stub(_res);
}

class Input$EscalationPolicyCreateInput {
  factory Input$EscalationPolicyCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String name,
    String? description,
    required List<Input$EscalationRuleInput> rules,
  }) =>
      Input$EscalationPolicyCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'name': name,
        if (description != null) r'description': description,
        r'rules': rules,
      });

  Input$EscalationPolicyCreateInput._(this._$data);

  factory Input$EscalationPolicyCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$rules = data['rules'];
    result$data['rules'] = (l$rules as List<dynamic>)
        .map((e) =>
            Input$EscalationRuleInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$EscalationPolicyCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get name => (_$data['name'] as String);
  String? get description => (_$data['description'] as String?);
  List<Input$EscalationRuleInput> get rules =>
      (_$data['rules'] as List<Input$EscalationRuleInput>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$rules = rules;
    result$data['rules'] = l$rules.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$EscalationPolicyCreateInput<Input$EscalationPolicyCreateInput>
      get copyWith => CopyWith$Input$EscalationPolicyCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EscalationPolicyCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$rules = rules;
    final lOther$rules = other.rules;
    if (l$rules.length != lOther$rules.length) {
      return false;
    }
    for (int i = 0; i < l$rules.length; i++) {
      final l$rules$entry = l$rules[i];
      final lOther$rules$entry = lOther$rules[i];
      if (l$rules$entry != lOther$rules$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$name = name;
    final l$description = description;
    final l$rules = rules;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      Object.hashAll(l$rules.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$EscalationPolicyCreateInput<TRes> {
  factory CopyWith$Input$EscalationPolicyCreateInput(
    Input$EscalationPolicyCreateInput instance,
    TRes Function(Input$EscalationPolicyCreateInput) then,
  ) = _CopyWithImpl$Input$EscalationPolicyCreateInput;

  factory CopyWith$Input$EscalationPolicyCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EscalationPolicyCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    String? description,
    List<Input$EscalationRuleInput>? rules,
  });
  TRes rules(
      Iterable<Input$EscalationRuleInput> Function(
              Iterable<
                  CopyWith$Input$EscalationRuleInput<
                      Input$EscalationRuleInput>>)
          _fn);
}

class _CopyWithImpl$Input$EscalationPolicyCreateInput<TRes>
    implements CopyWith$Input$EscalationPolicyCreateInput<TRes> {
  _CopyWithImpl$Input$EscalationPolicyCreateInput(
    this._instance,
    this._then,
  );

  final Input$EscalationPolicyCreateInput _instance;

  final TRes Function(Input$EscalationPolicyCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? rules = _undefined,
  }) =>
      _then(Input$EscalationPolicyCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined) 'description': (description as String?),
        if (rules != _undefined && rules != null)
          'rules': (rules as List<Input$EscalationRuleInput>),
      }));
  TRes rules(
          Iterable<Input$EscalationRuleInput> Function(
                  Iterable<
                      CopyWith$Input$EscalationRuleInput<
                          Input$EscalationRuleInput>>)
              _fn) =>
      call(
          rules:
              _fn(_instance.rules.map((e) => CopyWith$Input$EscalationRuleInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$EscalationPolicyCreateInput<TRes>
    implements CopyWith$Input$EscalationPolicyCreateInput<TRes> {
  _CopyWithStubImpl$Input$EscalationPolicyCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    String? description,
    List<Input$EscalationRuleInput>? rules,
  }) =>
      _res;
  rules(_fn) => _res;
}

class Input$EscalationPolicyDestroyInput {
  factory Input$EscalationPolicyDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$EscalationPolicyDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$EscalationPolicyDestroyInput._(this._$data);

  factory Input$EscalationPolicyDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$EscalationPolicyDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$EscalationPolicyDestroyInput<
          Input$EscalationPolicyDestroyInput>
      get copyWith => CopyWith$Input$EscalationPolicyDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EscalationPolicyDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$EscalationPolicyDestroyInput<TRes> {
  factory CopyWith$Input$EscalationPolicyDestroyInput(
    Input$EscalationPolicyDestroyInput instance,
    TRes Function(Input$EscalationPolicyDestroyInput) then,
  ) = _CopyWithImpl$Input$EscalationPolicyDestroyInput;

  factory CopyWith$Input$EscalationPolicyDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EscalationPolicyDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$EscalationPolicyDestroyInput<TRes>
    implements CopyWith$Input$EscalationPolicyDestroyInput<TRes> {
  _CopyWithImpl$Input$EscalationPolicyDestroyInput(
    this._instance,
    this._then,
  );

  final Input$EscalationPolicyDestroyInput _instance;

  final TRes Function(Input$EscalationPolicyDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$EscalationPolicyDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$EscalationPolicyDestroyInput<TRes>
    implements CopyWith$Input$EscalationPolicyDestroyInput<TRes> {
  _CopyWithStubImpl$Input$EscalationPolicyDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$EscalationPolicyUpdateInput {
  factory Input$EscalationPolicyUpdateInput({
    String? clientMutationId,
    required String id,
    String? name,
    String? description,
    List<Input$EscalationRuleInput>? rules,
  }) =>
      Input$EscalationPolicyUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (rules != null) r'rules': rules,
      });

  Input$EscalationPolicyUpdateInput._(this._$data);

  factory Input$EscalationPolicyUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('rules')) {
      final l$rules = data['rules'];
      result$data['rules'] = (l$rules as List<dynamic>?)
          ?.map((e) =>
              Input$EscalationRuleInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$EscalationPolicyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  List<Input$EscalationRuleInput>? get rules =>
      (_$data['rules'] as List<Input$EscalationRuleInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('rules')) {
      final l$rules = rules;
      result$data['rules'] = l$rules?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$EscalationPolicyUpdateInput<Input$EscalationPolicyUpdateInput>
      get copyWith => CopyWith$Input$EscalationPolicyUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EscalationPolicyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$rules = rules;
    final lOther$rules = other.rules;
    if (_$data.containsKey('rules') != other._$data.containsKey('rules')) {
      return false;
    }
    if (l$rules != null && lOther$rules != null) {
      if (l$rules.length != lOther$rules.length) {
        return false;
      }
      for (int i = 0; i < l$rules.length; i++) {
        final l$rules$entry = l$rules[i];
        final lOther$rules$entry = lOther$rules[i];
        if (l$rules$entry != lOther$rules$entry) {
          return false;
        }
      }
    } else if (l$rules != lOther$rules) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$rules = rules;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('rules')
          ? l$rules == null
              ? null
              : Object.hashAll(l$rules.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EscalationPolicyUpdateInput<TRes> {
  factory CopyWith$Input$EscalationPolicyUpdateInput(
    Input$EscalationPolicyUpdateInput instance,
    TRes Function(Input$EscalationPolicyUpdateInput) then,
  ) = _CopyWithImpl$Input$EscalationPolicyUpdateInput;

  factory CopyWith$Input$EscalationPolicyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EscalationPolicyUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? name,
    String? description,
    List<Input$EscalationRuleInput>? rules,
  });
  TRes rules(
      Iterable<Input$EscalationRuleInput>? Function(
              Iterable<
                  CopyWith$Input$EscalationRuleInput<
                      Input$EscalationRuleInput>>?)
          _fn);
}

class _CopyWithImpl$Input$EscalationPolicyUpdateInput<TRes>
    implements CopyWith$Input$EscalationPolicyUpdateInput<TRes> {
  _CopyWithImpl$Input$EscalationPolicyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$EscalationPolicyUpdateInput _instance;

  final TRes Function(Input$EscalationPolicyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? rules = _undefined,
  }) =>
      _then(Input$EscalationPolicyUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (rules != _undefined)
          'rules': (rules as List<Input$EscalationRuleInput>?),
      }));
  TRes rules(
          Iterable<Input$EscalationRuleInput>? Function(
                  Iterable<
                      CopyWith$Input$EscalationRuleInput<
                          Input$EscalationRuleInput>>?)
              _fn) =>
      call(
          rules: _fn(
              _instance.rules?.map((e) => CopyWith$Input$EscalationRuleInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$EscalationPolicyUpdateInput<TRes>
    implements CopyWith$Input$EscalationPolicyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$EscalationPolicyUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? name,
    String? description,
    List<Input$EscalationRuleInput>? rules,
  }) =>
      _res;
  rules(_fn) => _res;
}

class Input$EscalationRuleInput {
  factory Input$EscalationRuleInput({
    String? oncallScheduleIid,
    String? username,
    required int elapsedTimeSeconds,
    required Enum$EscalationRuleStatus status,
  }) =>
      Input$EscalationRuleInput._({
        if (oncallScheduleIid != null) r'oncallScheduleIid': oncallScheduleIid,
        if (username != null) r'username': username,
        r'elapsedTimeSeconds': elapsedTimeSeconds,
        r'status': status,
      });

  Input$EscalationRuleInput._(this._$data);

  factory Input$EscalationRuleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('oncallScheduleIid')) {
      final l$oncallScheduleIid = data['oncallScheduleIid'];
      result$data['oncallScheduleIid'] = (l$oncallScheduleIid as String?);
    }
    if (data.containsKey('username')) {
      final l$username = data['username'];
      result$data['username'] = (l$username as String?);
    }
    final l$elapsedTimeSeconds = data['elapsedTimeSeconds'];
    result$data['elapsedTimeSeconds'] = (l$elapsedTimeSeconds as int);
    final l$status = data['status'];
    result$data['status'] =
        fromJson$Enum$EscalationRuleStatus((l$status as String));
    return Input$EscalationRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get oncallScheduleIid => (_$data['oncallScheduleIid'] as String?);
  String? get username => (_$data['username'] as String?);
  int get elapsedTimeSeconds => (_$data['elapsedTimeSeconds'] as int);
  Enum$EscalationRuleStatus get status =>
      (_$data['status'] as Enum$EscalationRuleStatus);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('oncallScheduleIid')) {
      final l$oncallScheduleIid = oncallScheduleIid;
      result$data['oncallScheduleIid'] = l$oncallScheduleIid;
    }
    if (_$data.containsKey('username')) {
      final l$username = username;
      result$data['username'] = l$username;
    }
    final l$elapsedTimeSeconds = elapsedTimeSeconds;
    result$data['elapsedTimeSeconds'] = l$elapsedTimeSeconds;
    final l$status = status;
    result$data['status'] = toJson$Enum$EscalationRuleStatus(l$status);
    return result$data;
  }

  CopyWith$Input$EscalationRuleInput<Input$EscalationRuleInput> get copyWith =>
      CopyWith$Input$EscalationRuleInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EscalationRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$oncallScheduleIid = oncallScheduleIid;
    final lOther$oncallScheduleIid = other.oncallScheduleIid;
    if (_$data.containsKey('oncallScheduleIid') !=
        other._$data.containsKey('oncallScheduleIid')) {
      return false;
    }
    if (l$oncallScheduleIid != lOther$oncallScheduleIid) {
      return false;
    }
    final l$username = username;
    final lOther$username = other.username;
    if (_$data.containsKey('username') !=
        other._$data.containsKey('username')) {
      return false;
    }
    if (l$username != lOther$username) {
      return false;
    }
    final l$elapsedTimeSeconds = elapsedTimeSeconds;
    final lOther$elapsedTimeSeconds = other.elapsedTimeSeconds;
    if (l$elapsedTimeSeconds != lOther$elapsedTimeSeconds) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$oncallScheduleIid = oncallScheduleIid;
    final l$username = username;
    final l$elapsedTimeSeconds = elapsedTimeSeconds;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('oncallScheduleIid') ? l$oncallScheduleIid : const {},
      _$data.containsKey('username') ? l$username : const {},
      l$elapsedTimeSeconds,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$EscalationRuleInput<TRes> {
  factory CopyWith$Input$EscalationRuleInput(
    Input$EscalationRuleInput instance,
    TRes Function(Input$EscalationRuleInput) then,
  ) = _CopyWithImpl$Input$EscalationRuleInput;

  factory CopyWith$Input$EscalationRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EscalationRuleInput;

  TRes call({
    String? oncallScheduleIid,
    String? username,
    int? elapsedTimeSeconds,
    Enum$EscalationRuleStatus? status,
  });
}

class _CopyWithImpl$Input$EscalationRuleInput<TRes>
    implements CopyWith$Input$EscalationRuleInput<TRes> {
  _CopyWithImpl$Input$EscalationRuleInput(
    this._instance,
    this._then,
  );

  final Input$EscalationRuleInput _instance;

  final TRes Function(Input$EscalationRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? oncallScheduleIid = _undefined,
    Object? username = _undefined,
    Object? elapsedTimeSeconds = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$EscalationRuleInput._({
        ..._instance._$data,
        if (oncallScheduleIid != _undefined)
          'oncallScheduleIid': (oncallScheduleIid as String?),
        if (username != _undefined) 'username': (username as String?),
        if (elapsedTimeSeconds != _undefined && elapsedTimeSeconds != null)
          'elapsedTimeSeconds': (elapsedTimeSeconds as int),
        if (status != _undefined && status != null)
          'status': (status as Enum$EscalationRuleStatus),
      }));
}

class _CopyWithStubImpl$Input$EscalationRuleInput<TRes>
    implements CopyWith$Input$EscalationRuleInput<TRes> {
  _CopyWithStubImpl$Input$EscalationRuleInput(this._res);

  TRes _res;

  call({
    String? oncallScheduleIid,
    String? username,
    int? elapsedTimeSeconds,
    Enum$EscalationRuleStatus? status,
  }) =>
      _res;
}

class Input$ExportRequirementsInput {
  factory Input$ExportRequirementsInput({
    String? clientMutationId,
    Enum$Sort? sort,
    Enum$RequirementState? state,
    String? search,
    List<String>? authorUsername,
    required String projectPath,
    List<String>? selectedFields,
  }) =>
      Input$ExportRequirementsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sort != null) r'sort': sort,
        if (state != null) r'state': state,
        if (search != null) r'search': search,
        if (authorUsername != null) r'authorUsername': authorUsername,
        r'projectPath': projectPath,
        if (selectedFields != null) r'selectedFields': selectedFields,
      });

  Input$ExportRequirementsInput._(this._$data);

  factory Input$ExportRequirementsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sort')) {
      final l$sort = data['sort'];
      result$data['sort'] =
          l$sort == null ? null : fromJson$Enum$Sort((l$sort as String));
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$RequirementState((l$state as String));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('selectedFields')) {
      final l$selectedFields = data['selectedFields'];
      result$data['selectedFields'] = (l$selectedFields as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$ExportRequirementsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$Sort? get sort => (_$data['sort'] as Enum$Sort?);
  Enum$RequirementState? get state =>
      (_$data['state'] as Enum$RequirementState?);
  String? get search => (_$data['search'] as String?);
  List<String>? get authorUsername =>
      (_$data['authorUsername'] as List<String>?);
  String get projectPath => (_$data['projectPath'] as String);
  List<String>? get selectedFields =>
      (_$data['selectedFields'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sort')) {
      final l$sort = sort;
      result$data['sort'] = l$sort == null ? null : toJson$Enum$Sort(l$sort);
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$RequirementState(l$state);
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername?.map((e) => e).toList();
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('selectedFields')) {
      final l$selectedFields = selectedFields;
      result$data['selectedFields'] = l$selectedFields?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ExportRequirementsInput<Input$ExportRequirementsInput>
      get copyWith => CopyWith$Input$ExportRequirementsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExportRequirementsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sort = sort;
    final lOther$sort = other.sort;
    if (_$data.containsKey('sort') != other._$data.containsKey('sort')) {
      return false;
    }
    if (l$sort != lOther$sort) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != null && lOther$authorUsername != null) {
      if (l$authorUsername.length != lOther$authorUsername.length) {
        return false;
      }
      for (int i = 0; i < l$authorUsername.length; i++) {
        final l$authorUsername$entry = l$authorUsername[i];
        final lOther$authorUsername$entry = lOther$authorUsername[i];
        if (l$authorUsername$entry != lOther$authorUsername$entry) {
          return false;
        }
      }
    } else if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$selectedFields = selectedFields;
    final lOther$selectedFields = other.selectedFields;
    if (_$data.containsKey('selectedFields') !=
        other._$data.containsKey('selectedFields')) {
      return false;
    }
    if (l$selectedFields != null && lOther$selectedFields != null) {
      if (l$selectedFields.length != lOther$selectedFields.length) {
        return false;
      }
      for (int i = 0; i < l$selectedFields.length; i++) {
        final l$selectedFields$entry = l$selectedFields[i];
        final lOther$selectedFields$entry = lOther$selectedFields[i];
        if (l$selectedFields$entry != lOther$selectedFields$entry) {
          return false;
        }
      }
    } else if (l$selectedFields != lOther$selectedFields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sort = sort;
    final l$state = state;
    final l$search = search;
    final l$authorUsername = authorUsername;
    final l$projectPath = projectPath;
    final l$selectedFields = selectedFields;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sort') ? l$sort : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('authorUsername')
          ? l$authorUsername == null
              ? null
              : Object.hashAll(l$authorUsername.map((v) => v))
          : const {},
      l$projectPath,
      _$data.containsKey('selectedFields')
          ? l$selectedFields == null
              ? null
              : Object.hashAll(l$selectedFields.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExportRequirementsInput<TRes> {
  factory CopyWith$Input$ExportRequirementsInput(
    Input$ExportRequirementsInput instance,
    TRes Function(Input$ExportRequirementsInput) then,
  ) = _CopyWithImpl$Input$ExportRequirementsInput;

  factory CopyWith$Input$ExportRequirementsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportRequirementsInput;

  TRes call({
    String? clientMutationId,
    Enum$Sort? sort,
    Enum$RequirementState? state,
    String? search,
    List<String>? authorUsername,
    String? projectPath,
    List<String>? selectedFields,
  });
}

class _CopyWithImpl$Input$ExportRequirementsInput<TRes>
    implements CopyWith$Input$ExportRequirementsInput<TRes> {
  _CopyWithImpl$Input$ExportRequirementsInput(
    this._instance,
    this._then,
  );

  final Input$ExportRequirementsInput _instance;

  final TRes Function(Input$ExportRequirementsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sort = _undefined,
    Object? state = _undefined,
    Object? search = _undefined,
    Object? authorUsername = _undefined,
    Object? projectPath = _undefined,
    Object? selectedFields = _undefined,
  }) =>
      _then(Input$ExportRequirementsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sort != _undefined) 'sort': (sort as Enum$Sort?),
        if (state != _undefined) 'state': (state as Enum$RequirementState?),
        if (search != _undefined) 'search': (search as String?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as List<String>?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (selectedFields != _undefined)
          'selectedFields': (selectedFields as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$ExportRequirementsInput<TRes>
    implements CopyWith$Input$ExportRequirementsInput<TRes> {
  _CopyWithStubImpl$Input$ExportRequirementsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$Sort? sort,
    Enum$RequirementState? state,
    String? search,
    List<String>? authorUsername,
    String? projectPath,
    List<String>? selectedFields,
  }) =>
      _res;
}

class Input$ExternalAuditEventDestinationCreateInput {
  factory Input$ExternalAuditEventDestinationCreateInput({
    String? clientMutationId,
    required String destinationUrl,
    required String groupPath,
    String? verificationToken,
  }) =>
      Input$ExternalAuditEventDestinationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'destinationUrl': destinationUrl,
        r'groupPath': groupPath,
        if (verificationToken != null) r'verificationToken': verificationToken,
      });

  Input$ExternalAuditEventDestinationCreateInput._(this._$data);

  factory Input$ExternalAuditEventDestinationCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$destinationUrl = data['destinationUrl'];
    result$data['destinationUrl'] = (l$destinationUrl as String);
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('verificationToken')) {
      final l$verificationToken = data['verificationToken'];
      result$data['verificationToken'] = (l$verificationToken as String?);
    }
    return Input$ExternalAuditEventDestinationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get destinationUrl => (_$data['destinationUrl'] as String);
  String get groupPath => (_$data['groupPath'] as String);
  String? get verificationToken => (_$data['verificationToken'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$destinationUrl = destinationUrl;
    result$data['destinationUrl'] = l$destinationUrl;
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('verificationToken')) {
      final l$verificationToken = verificationToken;
      result$data['verificationToken'] = l$verificationToken;
    }
    return result$data;
  }

  CopyWith$Input$ExternalAuditEventDestinationCreateInput<
          Input$ExternalAuditEventDestinationCreateInput>
      get copyWith => CopyWith$Input$ExternalAuditEventDestinationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExternalAuditEventDestinationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$destinationUrl = destinationUrl;
    final lOther$destinationUrl = other.destinationUrl;
    if (l$destinationUrl != lOther$destinationUrl) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$verificationToken = verificationToken;
    final lOther$verificationToken = other.verificationToken;
    if (_$data.containsKey('verificationToken') !=
        other._$data.containsKey('verificationToken')) {
      return false;
    }
    if (l$verificationToken != lOther$verificationToken) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$destinationUrl = destinationUrl;
    final l$groupPath = groupPath;
    final l$verificationToken = verificationToken;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$destinationUrl,
      l$groupPath,
      _$data.containsKey('verificationToken') ? l$verificationToken : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExternalAuditEventDestinationCreateInput<TRes> {
  factory CopyWith$Input$ExternalAuditEventDestinationCreateInput(
    Input$ExternalAuditEventDestinationCreateInput instance,
    TRes Function(Input$ExternalAuditEventDestinationCreateInput) then,
  ) = _CopyWithImpl$Input$ExternalAuditEventDestinationCreateInput;

  factory CopyWith$Input$ExternalAuditEventDestinationCreateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ExternalAuditEventDestinationCreateInput;

  TRes call({
    String? clientMutationId,
    String? destinationUrl,
    String? groupPath,
    String? verificationToken,
  });
}

class _CopyWithImpl$Input$ExternalAuditEventDestinationCreateInput<TRes>
    implements CopyWith$Input$ExternalAuditEventDestinationCreateInput<TRes> {
  _CopyWithImpl$Input$ExternalAuditEventDestinationCreateInput(
    this._instance,
    this._then,
  );

  final Input$ExternalAuditEventDestinationCreateInput _instance;

  final TRes Function(Input$ExternalAuditEventDestinationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? destinationUrl = _undefined,
    Object? groupPath = _undefined,
    Object? verificationToken = _undefined,
  }) =>
      _then(Input$ExternalAuditEventDestinationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (destinationUrl != _undefined && destinationUrl != null)
          'destinationUrl': (destinationUrl as String),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (verificationToken != _undefined)
          'verificationToken': (verificationToken as String?),
      }));
}

class _CopyWithStubImpl$Input$ExternalAuditEventDestinationCreateInput<TRes>
    implements CopyWith$Input$ExternalAuditEventDestinationCreateInput<TRes> {
  _CopyWithStubImpl$Input$ExternalAuditEventDestinationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? destinationUrl,
    String? groupPath,
    String? verificationToken,
  }) =>
      _res;
}

class Input$ExternalAuditEventDestinationDestroyInput {
  factory Input$ExternalAuditEventDestinationDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$ExternalAuditEventDestinationDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$ExternalAuditEventDestinationDestroyInput._(this._$data);

  factory Input$ExternalAuditEventDestinationDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ExternalAuditEventDestinationDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ExternalAuditEventDestinationDestroyInput<
          Input$ExternalAuditEventDestinationDestroyInput>
      get copyWith => CopyWith$Input$ExternalAuditEventDestinationDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExternalAuditEventDestinationDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ExternalAuditEventDestinationDestroyInput<TRes> {
  factory CopyWith$Input$ExternalAuditEventDestinationDestroyInput(
    Input$ExternalAuditEventDestinationDestroyInput instance,
    TRes Function(Input$ExternalAuditEventDestinationDestroyInput) then,
  ) = _CopyWithImpl$Input$ExternalAuditEventDestinationDestroyInput;

  factory CopyWith$Input$ExternalAuditEventDestinationDestroyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ExternalAuditEventDestinationDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$ExternalAuditEventDestinationDestroyInput<TRes>
    implements CopyWith$Input$ExternalAuditEventDestinationDestroyInput<TRes> {
  _CopyWithImpl$Input$ExternalAuditEventDestinationDestroyInput(
    this._instance,
    this._then,
  );

  final Input$ExternalAuditEventDestinationDestroyInput _instance;

  final TRes Function(Input$ExternalAuditEventDestinationDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ExternalAuditEventDestinationDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$ExternalAuditEventDestinationDestroyInput<TRes>
    implements CopyWith$Input$ExternalAuditEventDestinationDestroyInput<TRes> {
  _CopyWithStubImpl$Input$ExternalAuditEventDestinationDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$ExternalAuditEventDestinationUpdateInput {
  factory Input$ExternalAuditEventDestinationUpdateInput({
    String? clientMutationId,
    required String id,
    String? destinationUrl,
  }) =>
      Input$ExternalAuditEventDestinationUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (destinationUrl != null) r'destinationUrl': destinationUrl,
      });

  Input$ExternalAuditEventDestinationUpdateInput._(this._$data);

  factory Input$ExternalAuditEventDestinationUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('destinationUrl')) {
      final l$destinationUrl = data['destinationUrl'];
      result$data['destinationUrl'] = (l$destinationUrl as String?);
    }
    return Input$ExternalAuditEventDestinationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get destinationUrl => (_$data['destinationUrl'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('destinationUrl')) {
      final l$destinationUrl = destinationUrl;
      result$data['destinationUrl'] = l$destinationUrl;
    }
    return result$data;
  }

  CopyWith$Input$ExternalAuditEventDestinationUpdateInput<
          Input$ExternalAuditEventDestinationUpdateInput>
      get copyWith => CopyWith$Input$ExternalAuditEventDestinationUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExternalAuditEventDestinationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$destinationUrl = destinationUrl;
    final lOther$destinationUrl = other.destinationUrl;
    if (_$data.containsKey('destinationUrl') !=
        other._$data.containsKey('destinationUrl')) {
      return false;
    }
    if (l$destinationUrl != lOther$destinationUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$destinationUrl = destinationUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('destinationUrl') ? l$destinationUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExternalAuditEventDestinationUpdateInput<TRes> {
  factory CopyWith$Input$ExternalAuditEventDestinationUpdateInput(
    Input$ExternalAuditEventDestinationUpdateInput instance,
    TRes Function(Input$ExternalAuditEventDestinationUpdateInput) then,
  ) = _CopyWithImpl$Input$ExternalAuditEventDestinationUpdateInput;

  factory CopyWith$Input$ExternalAuditEventDestinationUpdateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ExternalAuditEventDestinationUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? destinationUrl,
  });
}

class _CopyWithImpl$Input$ExternalAuditEventDestinationUpdateInput<TRes>
    implements CopyWith$Input$ExternalAuditEventDestinationUpdateInput<TRes> {
  _CopyWithImpl$Input$ExternalAuditEventDestinationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ExternalAuditEventDestinationUpdateInput _instance;

  final TRes Function(Input$ExternalAuditEventDestinationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? destinationUrl = _undefined,
  }) =>
      _then(Input$ExternalAuditEventDestinationUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (destinationUrl != _undefined)
          'destinationUrl': (destinationUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$ExternalAuditEventDestinationUpdateInput<TRes>
    implements CopyWith$Input$ExternalAuditEventDestinationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ExternalAuditEventDestinationUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? destinationUrl,
  }) =>
      _res;
}

class Input$GitlabSubscriptionActivateInput {
  factory Input$GitlabSubscriptionActivateInput({
    String? clientMutationId,
    required String activationCode,
  }) =>
      Input$GitlabSubscriptionActivateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'activationCode': activationCode,
      });

  Input$GitlabSubscriptionActivateInput._(this._$data);

  factory Input$GitlabSubscriptionActivateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$activationCode = data['activationCode'];
    result$data['activationCode'] = (l$activationCode as String);
    return Input$GitlabSubscriptionActivateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get activationCode => (_$data['activationCode'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$activationCode = activationCode;
    result$data['activationCode'] = l$activationCode;
    return result$data;
  }

  CopyWith$Input$GitlabSubscriptionActivateInput<
          Input$GitlabSubscriptionActivateInput>
      get copyWith => CopyWith$Input$GitlabSubscriptionActivateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GitlabSubscriptionActivateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$activationCode = activationCode;
    final lOther$activationCode = other.activationCode;
    if (l$activationCode != lOther$activationCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$activationCode = activationCode;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$activationCode,
    ]);
  }
}

abstract class CopyWith$Input$GitlabSubscriptionActivateInput<TRes> {
  factory CopyWith$Input$GitlabSubscriptionActivateInput(
    Input$GitlabSubscriptionActivateInput instance,
    TRes Function(Input$GitlabSubscriptionActivateInput) then,
  ) = _CopyWithImpl$Input$GitlabSubscriptionActivateInput;

  factory CopyWith$Input$GitlabSubscriptionActivateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GitlabSubscriptionActivateInput;

  TRes call({
    String? clientMutationId,
    String? activationCode,
  });
}

class _CopyWithImpl$Input$GitlabSubscriptionActivateInput<TRes>
    implements CopyWith$Input$GitlabSubscriptionActivateInput<TRes> {
  _CopyWithImpl$Input$GitlabSubscriptionActivateInput(
    this._instance,
    this._then,
  );

  final Input$GitlabSubscriptionActivateInput _instance;

  final TRes Function(Input$GitlabSubscriptionActivateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? activationCode = _undefined,
  }) =>
      _then(Input$GitlabSubscriptionActivateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (activationCode != _undefined && activationCode != null)
          'activationCode': (activationCode as String),
      }));
}

class _CopyWithStubImpl$Input$GitlabSubscriptionActivateInput<TRes>
    implements CopyWith$Input$GitlabSubscriptionActivateInput<TRes> {
  _CopyWithStubImpl$Input$GitlabSubscriptionActivateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? activationCode,
  }) =>
      _res;
}

class Input$GroupUpdateInput {
  factory Input$GroupUpdateInput({
    String? clientMutationId,
    required String fullPath,
    required Enum$SharedRunnersSetting sharedRunnersSetting,
  }) =>
      Input$GroupUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        r'sharedRunnersSetting': sharedRunnersSetting,
      });

  Input$GroupUpdateInput._(this._$data);

  factory Input$GroupUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    final l$sharedRunnersSetting = data['sharedRunnersSetting'];
    result$data['sharedRunnersSetting'] =
        fromJson$Enum$SharedRunnersSetting((l$sharedRunnersSetting as String));
    return Input$GroupUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  Enum$SharedRunnersSetting get sharedRunnersSetting =>
      (_$data['sharedRunnersSetting'] as Enum$SharedRunnersSetting);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    final l$sharedRunnersSetting = sharedRunnersSetting;
    result$data['sharedRunnersSetting'] =
        toJson$Enum$SharedRunnersSetting(l$sharedRunnersSetting);
    return result$data;
  }

  CopyWith$Input$GroupUpdateInput<Input$GroupUpdateInput> get copyWith =>
      CopyWith$Input$GroupUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$sharedRunnersSetting = sharedRunnersSetting;
    final lOther$sharedRunnersSetting = other.sharedRunnersSetting;
    if (l$sharedRunnersSetting != lOther$sharedRunnersSetting) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$sharedRunnersSetting = sharedRunnersSetting;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      l$sharedRunnersSetting,
    ]);
  }
}

abstract class CopyWith$Input$GroupUpdateInput<TRes> {
  factory CopyWith$Input$GroupUpdateInput(
    Input$GroupUpdateInput instance,
    TRes Function(Input$GroupUpdateInput) then,
  ) = _CopyWithImpl$Input$GroupUpdateInput;

  factory CopyWith$Input$GroupUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupUpdateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    Enum$SharedRunnersSetting? sharedRunnersSetting,
  });
}

class _CopyWithImpl$Input$GroupUpdateInput<TRes>
    implements CopyWith$Input$GroupUpdateInput<TRes> {
  _CopyWithImpl$Input$GroupUpdateInput(
    this._instance,
    this._then,
  );

  final Input$GroupUpdateInput _instance;

  final TRes Function(Input$GroupUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? sharedRunnersSetting = _undefined,
  }) =>
      _then(Input$GroupUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (sharedRunnersSetting != _undefined && sharedRunnersSetting != null)
          'sharedRunnersSetting':
              (sharedRunnersSetting as Enum$SharedRunnersSetting),
      }));
}

class _CopyWithStubImpl$Input$GroupUpdateInput<TRes>
    implements CopyWith$Input$GroupUpdateInput<TRes> {
  _CopyWithStubImpl$Input$GroupUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    Enum$SharedRunnersSetting? sharedRunnersSetting,
  }) =>
      _res;
}

class Input$HttpIntegrationCreateInput {
  factory Input$HttpIntegrationCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String name,
    required bool active,
    String? payloadExample,
    List<Input$AlertManagementPayloadAlertFieldInput>? payloadAttributeMappings,
  }) =>
      Input$HttpIntegrationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'name': name,
        r'active': active,
        if (payloadExample != null) r'payloadExample': payloadExample,
        if (payloadAttributeMappings != null)
          r'payloadAttributeMappings': payloadAttributeMappings,
      });

  Input$HttpIntegrationCreateInput._(this._$data);

  factory Input$HttpIntegrationCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$active = data['active'];
    result$data['active'] = (l$active as bool);
    if (data.containsKey('payloadExample')) {
      final l$payloadExample = data['payloadExample'];
      result$data['payloadExample'] = (l$payloadExample as String?);
    }
    if (data.containsKey('payloadAttributeMappings')) {
      final l$payloadAttributeMappings = data['payloadAttributeMappings'];
      result$data['payloadAttributeMappings'] =
          (l$payloadAttributeMappings as List<dynamic>?)
              ?.map((e) => Input$AlertManagementPayloadAlertFieldInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    return Input$HttpIntegrationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get name => (_$data['name'] as String);
  bool get active => (_$data['active'] as bool);
  String? get payloadExample => (_$data['payloadExample'] as String?);
  List<Input$AlertManagementPayloadAlertFieldInput>?
      get payloadAttributeMappings => (_$data['payloadAttributeMappings']
          as List<Input$AlertManagementPayloadAlertFieldInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$name = name;
    result$data['name'] = l$name;
    final l$active = active;
    result$data['active'] = l$active;
    if (_$data.containsKey('payloadExample')) {
      final l$payloadExample = payloadExample;
      result$data['payloadExample'] = l$payloadExample;
    }
    if (_$data.containsKey('payloadAttributeMappings')) {
      final l$payloadAttributeMappings = payloadAttributeMappings;
      result$data['payloadAttributeMappings'] =
          l$payloadAttributeMappings?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$HttpIntegrationCreateInput<Input$HttpIntegrationCreateInput>
      get copyWith => CopyWith$Input$HttpIntegrationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HttpIntegrationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (l$active != lOther$active) {
      return false;
    }
    final l$payloadExample = payloadExample;
    final lOther$payloadExample = other.payloadExample;
    if (_$data.containsKey('payloadExample') !=
        other._$data.containsKey('payloadExample')) {
      return false;
    }
    if (l$payloadExample != lOther$payloadExample) {
      return false;
    }
    final l$payloadAttributeMappings = payloadAttributeMappings;
    final lOther$payloadAttributeMappings = other.payloadAttributeMappings;
    if (_$data.containsKey('payloadAttributeMappings') !=
        other._$data.containsKey('payloadAttributeMappings')) {
      return false;
    }
    if (l$payloadAttributeMappings != null &&
        lOther$payloadAttributeMappings != null) {
      if (l$payloadAttributeMappings.length !=
          lOther$payloadAttributeMappings.length) {
        return false;
      }
      for (int i = 0; i < l$payloadAttributeMappings.length; i++) {
        final l$payloadAttributeMappings$entry = l$payloadAttributeMappings[i];
        final lOther$payloadAttributeMappings$entry =
            lOther$payloadAttributeMappings[i];
        if (l$payloadAttributeMappings$entry !=
            lOther$payloadAttributeMappings$entry) {
          return false;
        }
      }
    } else if (l$payloadAttributeMappings != lOther$payloadAttributeMappings) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$name = name;
    final l$active = active;
    final l$payloadExample = payloadExample;
    final l$payloadAttributeMappings = payloadAttributeMappings;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$name,
      l$active,
      _$data.containsKey('payloadExample') ? l$payloadExample : const {},
      _$data.containsKey('payloadAttributeMappings')
          ? l$payloadAttributeMappings == null
              ? null
              : Object.hashAll(l$payloadAttributeMappings.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$HttpIntegrationCreateInput<TRes> {
  factory CopyWith$Input$HttpIntegrationCreateInput(
    Input$HttpIntegrationCreateInput instance,
    TRes Function(Input$HttpIntegrationCreateInput) then,
  ) = _CopyWithImpl$Input$HttpIntegrationCreateInput;

  factory CopyWith$Input$HttpIntegrationCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HttpIntegrationCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    bool? active,
    String? payloadExample,
    List<Input$AlertManagementPayloadAlertFieldInput>? payloadAttributeMappings,
  });
  TRes payloadAttributeMappings(
      Iterable<Input$AlertManagementPayloadAlertFieldInput>? Function(
              Iterable<
                  CopyWith$Input$AlertManagementPayloadAlertFieldInput<
                      Input$AlertManagementPayloadAlertFieldInput>>?)
          _fn);
}

class _CopyWithImpl$Input$HttpIntegrationCreateInput<TRes>
    implements CopyWith$Input$HttpIntegrationCreateInput<TRes> {
  _CopyWithImpl$Input$HttpIntegrationCreateInput(
    this._instance,
    this._then,
  );

  final Input$HttpIntegrationCreateInput _instance;

  final TRes Function(Input$HttpIntegrationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? name = _undefined,
    Object? active = _undefined,
    Object? payloadExample = _undefined,
    Object? payloadAttributeMappings = _undefined,
  }) =>
      _then(Input$HttpIntegrationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (active != _undefined && active != null) 'active': (active as bool),
        if (payloadExample != _undefined)
          'payloadExample': (payloadExample as String?),
        if (payloadAttributeMappings != _undefined)
          'payloadAttributeMappings': (payloadAttributeMappings
              as List<Input$AlertManagementPayloadAlertFieldInput>?),
      }));
  TRes payloadAttributeMappings(
          Iterable<Input$AlertManagementPayloadAlertFieldInput>? Function(
                  Iterable<
                      CopyWith$Input$AlertManagementPayloadAlertFieldInput<
                          Input$AlertManagementPayloadAlertFieldInput>>?)
              _fn) =>
      call(
          payloadAttributeMappings: _fn(_instance.payloadAttributeMappings
              ?.map((e) => CopyWith$Input$AlertManagementPayloadAlertFieldInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$HttpIntegrationCreateInput<TRes>
    implements CopyWith$Input$HttpIntegrationCreateInput<TRes> {
  _CopyWithStubImpl$Input$HttpIntegrationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    bool? active,
    String? payloadExample,
    List<Input$AlertManagementPayloadAlertFieldInput>? payloadAttributeMappings,
  }) =>
      _res;
  payloadAttributeMappings(_fn) => _res;
}

class Input$HttpIntegrationDestroyInput {
  factory Input$HttpIntegrationDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$HttpIntegrationDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$HttpIntegrationDestroyInput._(this._$data);

  factory Input$HttpIntegrationDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$HttpIntegrationDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$HttpIntegrationDestroyInput<Input$HttpIntegrationDestroyInput>
      get copyWith => CopyWith$Input$HttpIntegrationDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HttpIntegrationDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$HttpIntegrationDestroyInput<TRes> {
  factory CopyWith$Input$HttpIntegrationDestroyInput(
    Input$HttpIntegrationDestroyInput instance,
    TRes Function(Input$HttpIntegrationDestroyInput) then,
  ) = _CopyWithImpl$Input$HttpIntegrationDestroyInput;

  factory CopyWith$Input$HttpIntegrationDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HttpIntegrationDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$HttpIntegrationDestroyInput<TRes>
    implements CopyWith$Input$HttpIntegrationDestroyInput<TRes> {
  _CopyWithImpl$Input$HttpIntegrationDestroyInput(
    this._instance,
    this._then,
  );

  final Input$HttpIntegrationDestroyInput _instance;

  final TRes Function(Input$HttpIntegrationDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$HttpIntegrationDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$HttpIntegrationDestroyInput<TRes>
    implements CopyWith$Input$HttpIntegrationDestroyInput<TRes> {
  _CopyWithStubImpl$Input$HttpIntegrationDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$HttpIntegrationResetTokenInput {
  factory Input$HttpIntegrationResetTokenInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$HttpIntegrationResetTokenInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$HttpIntegrationResetTokenInput._(this._$data);

  factory Input$HttpIntegrationResetTokenInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$HttpIntegrationResetTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$HttpIntegrationResetTokenInput<
          Input$HttpIntegrationResetTokenInput>
      get copyWith => CopyWith$Input$HttpIntegrationResetTokenInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HttpIntegrationResetTokenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$HttpIntegrationResetTokenInput<TRes> {
  factory CopyWith$Input$HttpIntegrationResetTokenInput(
    Input$HttpIntegrationResetTokenInput instance,
    TRes Function(Input$HttpIntegrationResetTokenInput) then,
  ) = _CopyWithImpl$Input$HttpIntegrationResetTokenInput;

  factory CopyWith$Input$HttpIntegrationResetTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HttpIntegrationResetTokenInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$HttpIntegrationResetTokenInput<TRes>
    implements CopyWith$Input$HttpIntegrationResetTokenInput<TRes> {
  _CopyWithImpl$Input$HttpIntegrationResetTokenInput(
    this._instance,
    this._then,
  );

  final Input$HttpIntegrationResetTokenInput _instance;

  final TRes Function(Input$HttpIntegrationResetTokenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$HttpIntegrationResetTokenInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$HttpIntegrationResetTokenInput<TRes>
    implements CopyWith$Input$HttpIntegrationResetTokenInput<TRes> {
  _CopyWithStubImpl$Input$HttpIntegrationResetTokenInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$HttpIntegrationUpdateInput {
  factory Input$HttpIntegrationUpdateInput({
    String? clientMutationId,
    required String id,
    String? name,
    bool? active,
    String? payloadExample,
    List<Input$AlertManagementPayloadAlertFieldInput>? payloadAttributeMappings,
  }) =>
      Input$HttpIntegrationUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (name != null) r'name': name,
        if (active != null) r'active': active,
        if (payloadExample != null) r'payloadExample': payloadExample,
        if (payloadAttributeMappings != null)
          r'payloadAttributeMappings': payloadAttributeMappings,
      });

  Input$HttpIntegrationUpdateInput._(this._$data);

  factory Input$HttpIntegrationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    if (data.containsKey('payloadExample')) {
      final l$payloadExample = data['payloadExample'];
      result$data['payloadExample'] = (l$payloadExample as String?);
    }
    if (data.containsKey('payloadAttributeMappings')) {
      final l$payloadAttributeMappings = data['payloadAttributeMappings'];
      result$data['payloadAttributeMappings'] =
          (l$payloadAttributeMappings as List<dynamic>?)
              ?.map((e) => Input$AlertManagementPayloadAlertFieldInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    return Input$HttpIntegrationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get name => (_$data['name'] as String?);
  bool? get active => (_$data['active'] as bool?);
  String? get payloadExample => (_$data['payloadExample'] as String?);
  List<Input$AlertManagementPayloadAlertFieldInput>?
      get payloadAttributeMappings => (_$data['payloadAttributeMappings']
          as List<Input$AlertManagementPayloadAlertFieldInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    if (_$data.containsKey('payloadExample')) {
      final l$payloadExample = payloadExample;
      result$data['payloadExample'] = l$payloadExample;
    }
    if (_$data.containsKey('payloadAttributeMappings')) {
      final l$payloadAttributeMappings = payloadAttributeMappings;
      result$data['payloadAttributeMappings'] =
          l$payloadAttributeMappings?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$HttpIntegrationUpdateInput<Input$HttpIntegrationUpdateInput>
      get copyWith => CopyWith$Input$HttpIntegrationUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$HttpIntegrationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$payloadExample = payloadExample;
    final lOther$payloadExample = other.payloadExample;
    if (_$data.containsKey('payloadExample') !=
        other._$data.containsKey('payloadExample')) {
      return false;
    }
    if (l$payloadExample != lOther$payloadExample) {
      return false;
    }
    final l$payloadAttributeMappings = payloadAttributeMappings;
    final lOther$payloadAttributeMappings = other.payloadAttributeMappings;
    if (_$data.containsKey('payloadAttributeMappings') !=
        other._$data.containsKey('payloadAttributeMappings')) {
      return false;
    }
    if (l$payloadAttributeMappings != null &&
        lOther$payloadAttributeMappings != null) {
      if (l$payloadAttributeMappings.length !=
          lOther$payloadAttributeMappings.length) {
        return false;
      }
      for (int i = 0; i < l$payloadAttributeMappings.length; i++) {
        final l$payloadAttributeMappings$entry = l$payloadAttributeMappings[i];
        final lOther$payloadAttributeMappings$entry =
            lOther$payloadAttributeMappings[i];
        if (l$payloadAttributeMappings$entry !=
            lOther$payloadAttributeMappings$entry) {
          return false;
        }
      }
    } else if (l$payloadAttributeMappings != lOther$payloadAttributeMappings) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$name = name;
    final l$active = active;
    final l$payloadExample = payloadExample;
    final l$payloadAttributeMappings = payloadAttributeMappings;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('payloadExample') ? l$payloadExample : const {},
      _$data.containsKey('payloadAttributeMappings')
          ? l$payloadAttributeMappings == null
              ? null
              : Object.hashAll(l$payloadAttributeMappings.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$HttpIntegrationUpdateInput<TRes> {
  factory CopyWith$Input$HttpIntegrationUpdateInput(
    Input$HttpIntegrationUpdateInput instance,
    TRes Function(Input$HttpIntegrationUpdateInput) then,
  ) = _CopyWithImpl$Input$HttpIntegrationUpdateInput;

  factory CopyWith$Input$HttpIntegrationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HttpIntegrationUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? name,
    bool? active,
    String? payloadExample,
    List<Input$AlertManagementPayloadAlertFieldInput>? payloadAttributeMappings,
  });
  TRes payloadAttributeMappings(
      Iterable<Input$AlertManagementPayloadAlertFieldInput>? Function(
              Iterable<
                  CopyWith$Input$AlertManagementPayloadAlertFieldInput<
                      Input$AlertManagementPayloadAlertFieldInput>>?)
          _fn);
}

class _CopyWithImpl$Input$HttpIntegrationUpdateInput<TRes>
    implements CopyWith$Input$HttpIntegrationUpdateInput<TRes> {
  _CopyWithImpl$Input$HttpIntegrationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$HttpIntegrationUpdateInput _instance;

  final TRes Function(Input$HttpIntegrationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? active = _undefined,
    Object? payloadExample = _undefined,
    Object? payloadAttributeMappings = _undefined,
  }) =>
      _then(Input$HttpIntegrationUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined) 'name': (name as String?),
        if (active != _undefined) 'active': (active as bool?),
        if (payloadExample != _undefined)
          'payloadExample': (payloadExample as String?),
        if (payloadAttributeMappings != _undefined)
          'payloadAttributeMappings': (payloadAttributeMappings
              as List<Input$AlertManagementPayloadAlertFieldInput>?),
      }));
  TRes payloadAttributeMappings(
          Iterable<Input$AlertManagementPayloadAlertFieldInput>? Function(
                  Iterable<
                      CopyWith$Input$AlertManagementPayloadAlertFieldInput<
                          Input$AlertManagementPayloadAlertFieldInput>>?)
              _fn) =>
      call(
          payloadAttributeMappings: _fn(_instance.payloadAttributeMappings
              ?.map((e) => CopyWith$Input$AlertManagementPayloadAlertFieldInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$HttpIntegrationUpdateInput<TRes>
    implements CopyWith$Input$HttpIntegrationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$HttpIntegrationUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? name,
    bool? active,
    String? payloadExample,
    List<Input$AlertManagementPayloadAlertFieldInput>? payloadAttributeMappings,
  }) =>
      _res;
  payloadAttributeMappings(_fn) => _res;
}

class Input$IssuableResourceLinkCreateInput {
  factory Input$IssuableResourceLinkCreateInput({
    String? clientMutationId,
    required String id,
    required String link,
    String? linkText,
    Enum$IssuableResourceLinkType? linkType,
  }) =>
      Input$IssuableResourceLinkCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'link': link,
        if (linkText != null) r'linkText': linkText,
        if (linkType != null) r'linkType': linkType,
      });

  Input$IssuableResourceLinkCreateInput._(this._$data);

  factory Input$IssuableResourceLinkCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$link = data['link'];
    result$data['link'] = (l$link as String);
    if (data.containsKey('linkText')) {
      final l$linkText = data['linkText'];
      result$data['linkText'] = (l$linkText as String?);
    }
    if (data.containsKey('linkType')) {
      final l$linkType = data['linkType'];
      result$data['linkType'] = l$linkType == null
          ? null
          : fromJson$Enum$IssuableResourceLinkType((l$linkType as String));
    }
    return Input$IssuableResourceLinkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String get link => (_$data['link'] as String);
  String? get linkText => (_$data['linkText'] as String?);
  Enum$IssuableResourceLinkType? get linkType =>
      (_$data['linkType'] as Enum$IssuableResourceLinkType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$link = link;
    result$data['link'] = l$link;
    if (_$data.containsKey('linkText')) {
      final l$linkText = linkText;
      result$data['linkText'] = l$linkText;
    }
    if (_$data.containsKey('linkType')) {
      final l$linkType = linkType;
      result$data['linkType'] = l$linkType == null
          ? null
          : toJson$Enum$IssuableResourceLinkType(l$linkType);
    }
    return result$data;
  }

  CopyWith$Input$IssuableResourceLinkCreateInput<
          Input$IssuableResourceLinkCreateInput>
      get copyWith => CopyWith$Input$IssuableResourceLinkCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssuableResourceLinkCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$link = link;
    final lOther$link = other.link;
    if (l$link != lOther$link) {
      return false;
    }
    final l$linkText = linkText;
    final lOther$linkText = other.linkText;
    if (_$data.containsKey('linkText') !=
        other._$data.containsKey('linkText')) {
      return false;
    }
    if (l$linkText != lOther$linkText) {
      return false;
    }
    final l$linkType = linkType;
    final lOther$linkType = other.linkType;
    if (_$data.containsKey('linkType') !=
        other._$data.containsKey('linkType')) {
      return false;
    }
    if (l$linkType != lOther$linkType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$link = link;
    final l$linkText = linkText;
    final l$linkType = linkType;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$link,
      _$data.containsKey('linkText') ? l$linkText : const {},
      _$data.containsKey('linkType') ? l$linkType : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssuableResourceLinkCreateInput<TRes> {
  factory CopyWith$Input$IssuableResourceLinkCreateInput(
    Input$IssuableResourceLinkCreateInput instance,
    TRes Function(Input$IssuableResourceLinkCreateInput) then,
  ) = _CopyWithImpl$Input$IssuableResourceLinkCreateInput;

  factory CopyWith$Input$IssuableResourceLinkCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssuableResourceLinkCreateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? link,
    String? linkText,
    Enum$IssuableResourceLinkType? linkType,
  });
}

class _CopyWithImpl$Input$IssuableResourceLinkCreateInput<TRes>
    implements CopyWith$Input$IssuableResourceLinkCreateInput<TRes> {
  _CopyWithImpl$Input$IssuableResourceLinkCreateInput(
    this._instance,
    this._then,
  );

  final Input$IssuableResourceLinkCreateInput _instance;

  final TRes Function(Input$IssuableResourceLinkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? link = _undefined,
    Object? linkText = _undefined,
    Object? linkType = _undefined,
  }) =>
      _then(Input$IssuableResourceLinkCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (link != _undefined && link != null) 'link': (link as String),
        if (linkText != _undefined) 'linkText': (linkText as String?),
        if (linkType != _undefined)
          'linkType': (linkType as Enum$IssuableResourceLinkType?),
      }));
}

class _CopyWithStubImpl$Input$IssuableResourceLinkCreateInput<TRes>
    implements CopyWith$Input$IssuableResourceLinkCreateInput<TRes> {
  _CopyWithStubImpl$Input$IssuableResourceLinkCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? link,
    String? linkText,
    Enum$IssuableResourceLinkType? linkType,
  }) =>
      _res;
}

class Input$IssuableResourceLinkDestroyInput {
  factory Input$IssuableResourceLinkDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$IssuableResourceLinkDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$IssuableResourceLinkDestroyInput._(this._$data);

  factory Input$IssuableResourceLinkDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$IssuableResourceLinkDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$IssuableResourceLinkDestroyInput<
          Input$IssuableResourceLinkDestroyInput>
      get copyWith => CopyWith$Input$IssuableResourceLinkDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssuableResourceLinkDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$IssuableResourceLinkDestroyInput<TRes> {
  factory CopyWith$Input$IssuableResourceLinkDestroyInput(
    Input$IssuableResourceLinkDestroyInput instance,
    TRes Function(Input$IssuableResourceLinkDestroyInput) then,
  ) = _CopyWithImpl$Input$IssuableResourceLinkDestroyInput;

  factory CopyWith$Input$IssuableResourceLinkDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssuableResourceLinkDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$IssuableResourceLinkDestroyInput<TRes>
    implements CopyWith$Input$IssuableResourceLinkDestroyInput<TRes> {
  _CopyWithImpl$Input$IssuableResourceLinkDestroyInput(
    this._instance,
    this._then,
  );

  final Input$IssuableResourceLinkDestroyInput _instance;

  final TRes Function(Input$IssuableResourceLinkDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$IssuableResourceLinkDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$IssuableResourceLinkDestroyInput<TRes>
    implements CopyWith$Input$IssuableResourceLinkDestroyInput<TRes> {
  _CopyWithStubImpl$Input$IssuableResourceLinkDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$IssueMoveInput {
  factory Input$IssueMoveInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required String targetProjectPath,
  }) =>
      Input$IssueMoveInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'targetProjectPath': targetProjectPath,
      });

  Input$IssueMoveInput._(this._$data);

  factory Input$IssueMoveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$targetProjectPath = data['targetProjectPath'];
    result$data['targetProjectPath'] = (l$targetProjectPath as String);
    return Input$IssueMoveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get targetProjectPath => (_$data['targetProjectPath'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$targetProjectPath = targetProjectPath;
    result$data['targetProjectPath'] = l$targetProjectPath;
    return result$data;
  }

  CopyWith$Input$IssueMoveInput<Input$IssueMoveInput> get copyWith =>
      CopyWith$Input$IssueMoveInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueMoveInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$targetProjectPath = targetProjectPath;
    final lOther$targetProjectPath = other.targetProjectPath;
    if (l$targetProjectPath != lOther$targetProjectPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$targetProjectPath = targetProjectPath;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$targetProjectPath,
    ]);
  }
}

abstract class CopyWith$Input$IssueMoveInput<TRes> {
  factory CopyWith$Input$IssueMoveInput(
    Input$IssueMoveInput instance,
    TRes Function(Input$IssueMoveInput) then,
  ) = _CopyWithImpl$Input$IssueMoveInput;

  factory CopyWith$Input$IssueMoveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueMoveInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? targetProjectPath,
  });
}

class _CopyWithImpl$Input$IssueMoveInput<TRes>
    implements CopyWith$Input$IssueMoveInput<TRes> {
  _CopyWithImpl$Input$IssueMoveInput(
    this._instance,
    this._then,
  );

  final Input$IssueMoveInput _instance;

  final TRes Function(Input$IssueMoveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? targetProjectPath = _undefined,
  }) =>
      _then(Input$IssueMoveInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (targetProjectPath != _undefined && targetProjectPath != null)
          'targetProjectPath': (targetProjectPath as String),
      }));
}

class _CopyWithStubImpl$Input$IssueMoveInput<TRes>
    implements CopyWith$Input$IssueMoveInput<TRes> {
  _CopyWithStubImpl$Input$IssueMoveInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? targetProjectPath,
  }) =>
      _res;
}

class Input$IssueMoveListInput {
  factory Input$IssueMoveListInput({
    String? clientMutationId,
    required String boardId,
    required String projectPath,
    required String iid,
    String? fromListId,
    String? toListId,
    String? moveBeforeId,
    String? moveAfterId,
    String? epicId,
  }) =>
      Input$IssueMoveListInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'boardId': boardId,
        r'projectPath': projectPath,
        r'iid': iid,
        if (fromListId != null) r'fromListId': fromListId,
        if (toListId != null) r'toListId': toListId,
        if (moveBeforeId != null) r'moveBeforeId': moveBeforeId,
        if (moveAfterId != null) r'moveAfterId': moveAfterId,
        if (epicId != null) r'epicId': epicId,
      });

  Input$IssueMoveListInput._(this._$data);

  factory Input$IssueMoveListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$boardId = data['boardId'];
    result$data['boardId'] = (l$boardId as String);
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('fromListId')) {
      final l$fromListId = data['fromListId'];
      result$data['fromListId'] = (l$fromListId as String?);
    }
    if (data.containsKey('toListId')) {
      final l$toListId = data['toListId'];
      result$data['toListId'] = (l$toListId as String?);
    }
    if (data.containsKey('moveBeforeId')) {
      final l$moveBeforeId = data['moveBeforeId'];
      result$data['moveBeforeId'] = (l$moveBeforeId as String?);
    }
    if (data.containsKey('moveAfterId')) {
      final l$moveAfterId = data['moveAfterId'];
      result$data['moveAfterId'] = (l$moveAfterId as String?);
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    return Input$IssueMoveListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get boardId => (_$data['boardId'] as String);
  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get fromListId => (_$data['fromListId'] as String?);
  String? get toListId => (_$data['toListId'] as String?);
  String? get moveBeforeId => (_$data['moveBeforeId'] as String?);
  String? get moveAfterId => (_$data['moveAfterId'] as String?);
  String? get epicId => (_$data['epicId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$boardId = boardId;
    result$data['boardId'] = l$boardId;
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('fromListId')) {
      final l$fromListId = fromListId;
      result$data['fromListId'] = l$fromListId;
    }
    if (_$data.containsKey('toListId')) {
      final l$toListId = toListId;
      result$data['toListId'] = l$toListId;
    }
    if (_$data.containsKey('moveBeforeId')) {
      final l$moveBeforeId = moveBeforeId;
      result$data['moveBeforeId'] = l$moveBeforeId;
    }
    if (_$data.containsKey('moveAfterId')) {
      final l$moveAfterId = moveAfterId;
      result$data['moveAfterId'] = l$moveAfterId;
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    return result$data;
  }

  CopyWith$Input$IssueMoveListInput<Input$IssueMoveListInput> get copyWith =>
      CopyWith$Input$IssueMoveListInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueMoveListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$boardId = boardId;
    final lOther$boardId = other.boardId;
    if (l$boardId != lOther$boardId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$fromListId = fromListId;
    final lOther$fromListId = other.fromListId;
    if (_$data.containsKey('fromListId') !=
        other._$data.containsKey('fromListId')) {
      return false;
    }
    if (l$fromListId != lOther$fromListId) {
      return false;
    }
    final l$toListId = toListId;
    final lOther$toListId = other.toListId;
    if (_$data.containsKey('toListId') !=
        other._$data.containsKey('toListId')) {
      return false;
    }
    if (l$toListId != lOther$toListId) {
      return false;
    }
    final l$moveBeforeId = moveBeforeId;
    final lOther$moveBeforeId = other.moveBeforeId;
    if (_$data.containsKey('moveBeforeId') !=
        other._$data.containsKey('moveBeforeId')) {
      return false;
    }
    if (l$moveBeforeId != lOther$moveBeforeId) {
      return false;
    }
    final l$moveAfterId = moveAfterId;
    final lOther$moveAfterId = other.moveAfterId;
    if (_$data.containsKey('moveAfterId') !=
        other._$data.containsKey('moveAfterId')) {
      return false;
    }
    if (l$moveAfterId != lOther$moveAfterId) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$boardId = boardId;
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$fromListId = fromListId;
    final l$toListId = toListId;
    final l$moveBeforeId = moveBeforeId;
    final l$moveAfterId = moveAfterId;
    final l$epicId = epicId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$boardId,
      l$projectPath,
      l$iid,
      _$data.containsKey('fromListId') ? l$fromListId : const {},
      _$data.containsKey('toListId') ? l$toListId : const {},
      _$data.containsKey('moveBeforeId') ? l$moveBeforeId : const {},
      _$data.containsKey('moveAfterId') ? l$moveAfterId : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueMoveListInput<TRes> {
  factory CopyWith$Input$IssueMoveListInput(
    Input$IssueMoveListInput instance,
    TRes Function(Input$IssueMoveListInput) then,
  ) = _CopyWithImpl$Input$IssueMoveListInput;

  factory CopyWith$Input$IssueMoveListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueMoveListInput;

  TRes call({
    String? clientMutationId,
    String? boardId,
    String? projectPath,
    String? iid,
    String? fromListId,
    String? toListId,
    String? moveBeforeId,
    String? moveAfterId,
    String? epicId,
  });
}

class _CopyWithImpl$Input$IssueMoveListInput<TRes>
    implements CopyWith$Input$IssueMoveListInput<TRes> {
  _CopyWithImpl$Input$IssueMoveListInput(
    this._instance,
    this._then,
  );

  final Input$IssueMoveListInput _instance;

  final TRes Function(Input$IssueMoveListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? boardId = _undefined,
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? fromListId = _undefined,
    Object? toListId = _undefined,
    Object? moveBeforeId = _undefined,
    Object? moveAfterId = _undefined,
    Object? epicId = _undefined,
  }) =>
      _then(Input$IssueMoveListInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (boardId != _undefined && boardId != null)
          'boardId': (boardId as String),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (fromListId != _undefined) 'fromListId': (fromListId as String?),
        if (toListId != _undefined) 'toListId': (toListId as String?),
        if (moveBeforeId != _undefined)
          'moveBeforeId': (moveBeforeId as String?),
        if (moveAfterId != _undefined) 'moveAfterId': (moveAfterId as String?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
      }));
}

class _CopyWithStubImpl$Input$IssueMoveListInput<TRes>
    implements CopyWith$Input$IssueMoveListInput<TRes> {
  _CopyWithStubImpl$Input$IssueMoveListInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? boardId,
    String? projectPath,
    String? iid,
    String? fromListId,
    String? toListId,
    String? moveBeforeId,
    String? moveAfterId,
    String? epicId,
  }) =>
      _res;
}

class Input$IssueSetAssigneesInput {
  factory Input$IssueSetAssigneesInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      Input$IssueSetAssigneesInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'assigneeUsernames': assigneeUsernames,
        if (operationMode != null) r'operationMode': operationMode,
      });

  Input$IssueSetAssigneesInput._(this._$data);

  factory Input$IssueSetAssigneesInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$assigneeUsernames = data['assigneeUsernames'];
    result$data['assigneeUsernames'] = (l$assigneeUsernames as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    if (data.containsKey('operationMode')) {
      final l$operationMode = data['operationMode'];
      result$data['operationMode'] = l$operationMode == null
          ? null
          : fromJson$Enum$MutationOperationMode((l$operationMode as String));
    }
    return Input$IssueSetAssigneesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get assigneeUsernames =>
      (_$data['assigneeUsernames'] as List<String>);
  Enum$MutationOperationMode? get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$assigneeUsernames = assigneeUsernames;
    result$data['assigneeUsernames'] =
        l$assigneeUsernames.map((e) => e).toList();
    if (_$data.containsKey('operationMode')) {
      final l$operationMode = operationMode;
      result$data['operationMode'] = l$operationMode == null
          ? null
          : toJson$Enum$MutationOperationMode(l$operationMode);
    }
    return result$data;
  }

  CopyWith$Input$IssueSetAssigneesInput<Input$IssueSetAssigneesInput>
      get copyWith => CopyWith$Input$IssueSetAssigneesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetAssigneesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$assigneeUsernames = assigneeUsernames;
    final lOther$assigneeUsernames = other.assigneeUsernames;
    if (l$assigneeUsernames.length != lOther$assigneeUsernames.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeUsernames.length; i++) {
      final l$assigneeUsernames$entry = l$assigneeUsernames[i];
      final lOther$assigneeUsernames$entry = lOther$assigneeUsernames[i];
      if (l$assigneeUsernames$entry != lOther$assigneeUsernames$entry) {
        return false;
      }
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (_$data.containsKey('operationMode') !=
        other._$data.containsKey('operationMode')) {
      return false;
    }
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$assigneeUsernames = assigneeUsernames;
    final l$operationMode = operationMode;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$assigneeUsernames.map((v) => v)),
      _$data.containsKey('operationMode') ? l$operationMode : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetAssigneesInput<TRes> {
  factory CopyWith$Input$IssueSetAssigneesInput(
    Input$IssueSetAssigneesInput instance,
    TRes Function(Input$IssueSetAssigneesInput) then,
  ) = _CopyWithImpl$Input$IssueSetAssigneesInput;

  factory CopyWith$Input$IssueSetAssigneesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetAssigneesInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  });
}

class _CopyWithImpl$Input$IssueSetAssigneesInput<TRes>
    implements CopyWith$Input$IssueSetAssigneesInput<TRes> {
  _CopyWithImpl$Input$IssueSetAssigneesInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetAssigneesInput _instance;

  final TRes Function(Input$IssueSetAssigneesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? assigneeUsernames = _undefined,
    Object? operationMode = _undefined,
  }) =>
      _then(Input$IssueSetAssigneesInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (assigneeUsernames != _undefined && assigneeUsernames != null)
          'assigneeUsernames': (assigneeUsernames as List<String>),
        if (operationMode != _undefined)
          'operationMode': (operationMode as Enum$MutationOperationMode?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetAssigneesInput<TRes>
    implements CopyWith$Input$IssueSetAssigneesInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetAssigneesInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      _res;
}

class Input$IssueSetConfidentialInput {
  factory Input$IssueSetConfidentialInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required bool confidential,
  }) =>
      Input$IssueSetConfidentialInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'confidential': confidential,
      });

  Input$IssueSetConfidentialInput._(this._$data);

  factory Input$IssueSetConfidentialInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$confidential = data['confidential'];
    result$data['confidential'] = (l$confidential as bool);
    return Input$IssueSetConfidentialInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get confidential => (_$data['confidential'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$confidential = confidential;
    result$data['confidential'] = l$confidential;
    return result$data;
  }

  CopyWith$Input$IssueSetConfidentialInput<Input$IssueSetConfidentialInput>
      get copyWith => CopyWith$Input$IssueSetConfidentialInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetConfidentialInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (l$confidential != lOther$confidential) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$confidential = confidential;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$confidential,
    ]);
  }
}

abstract class CopyWith$Input$IssueSetConfidentialInput<TRes> {
  factory CopyWith$Input$IssueSetConfidentialInput(
    Input$IssueSetConfidentialInput instance,
    TRes Function(Input$IssueSetConfidentialInput) then,
  ) = _CopyWithImpl$Input$IssueSetConfidentialInput;

  factory CopyWith$Input$IssueSetConfidentialInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetConfidentialInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? confidential,
  });
}

class _CopyWithImpl$Input$IssueSetConfidentialInput<TRes>
    implements CopyWith$Input$IssueSetConfidentialInput<TRes> {
  _CopyWithImpl$Input$IssueSetConfidentialInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetConfidentialInput _instance;

  final TRes Function(Input$IssueSetConfidentialInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? confidential = _undefined,
  }) =>
      _then(Input$IssueSetConfidentialInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (confidential != _undefined && confidential != null)
          'confidential': (confidential as bool),
      }));
}

class _CopyWithStubImpl$Input$IssueSetConfidentialInput<TRes>
    implements CopyWith$Input$IssueSetConfidentialInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetConfidentialInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? confidential,
  }) =>
      _res;
}

class Input$IssueSetCrmContactsInput {
  factory Input$IssueSetCrmContactsInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> contactIds,
    Enum$MutationOperationMode? operationMode,
  }) =>
      Input$IssueSetCrmContactsInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'contactIds': contactIds,
        if (operationMode != null) r'operationMode': operationMode,
      });

  Input$IssueSetCrmContactsInput._(this._$data);

  factory Input$IssueSetCrmContactsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$contactIds = data['contactIds'];
    result$data['contactIds'] =
        (l$contactIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('operationMode')) {
      final l$operationMode = data['operationMode'];
      result$data['operationMode'] = l$operationMode == null
          ? null
          : fromJson$Enum$MutationOperationMode((l$operationMode as String));
    }
    return Input$IssueSetCrmContactsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get contactIds => (_$data['contactIds'] as List<String>);
  Enum$MutationOperationMode? get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$contactIds = contactIds;
    result$data['contactIds'] = l$contactIds.map((e) => e).toList();
    if (_$data.containsKey('operationMode')) {
      final l$operationMode = operationMode;
      result$data['operationMode'] = l$operationMode == null
          ? null
          : toJson$Enum$MutationOperationMode(l$operationMode);
    }
    return result$data;
  }

  CopyWith$Input$IssueSetCrmContactsInput<Input$IssueSetCrmContactsInput>
      get copyWith => CopyWith$Input$IssueSetCrmContactsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetCrmContactsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$contactIds = contactIds;
    final lOther$contactIds = other.contactIds;
    if (l$contactIds.length != lOther$contactIds.length) {
      return false;
    }
    for (int i = 0; i < l$contactIds.length; i++) {
      final l$contactIds$entry = l$contactIds[i];
      final lOther$contactIds$entry = lOther$contactIds[i];
      if (l$contactIds$entry != lOther$contactIds$entry) {
        return false;
      }
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (_$data.containsKey('operationMode') !=
        other._$data.containsKey('operationMode')) {
      return false;
    }
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$contactIds = contactIds;
    final l$operationMode = operationMode;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$contactIds.map((v) => v)),
      _$data.containsKey('operationMode') ? l$operationMode : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetCrmContactsInput<TRes> {
  factory CopyWith$Input$IssueSetCrmContactsInput(
    Input$IssueSetCrmContactsInput instance,
    TRes Function(Input$IssueSetCrmContactsInput) then,
  ) = _CopyWithImpl$Input$IssueSetCrmContactsInput;

  factory CopyWith$Input$IssueSetCrmContactsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetCrmContactsInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? contactIds,
    Enum$MutationOperationMode? operationMode,
  });
}

class _CopyWithImpl$Input$IssueSetCrmContactsInput<TRes>
    implements CopyWith$Input$IssueSetCrmContactsInput<TRes> {
  _CopyWithImpl$Input$IssueSetCrmContactsInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetCrmContactsInput _instance;

  final TRes Function(Input$IssueSetCrmContactsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? contactIds = _undefined,
    Object? operationMode = _undefined,
  }) =>
      _then(Input$IssueSetCrmContactsInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (contactIds != _undefined && contactIds != null)
          'contactIds': (contactIds as List<String>),
        if (operationMode != _undefined)
          'operationMode': (operationMode as Enum$MutationOperationMode?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetCrmContactsInput<TRes>
    implements CopyWith$Input$IssueSetCrmContactsInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetCrmContactsInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? contactIds,
    Enum$MutationOperationMode? operationMode,
  }) =>
      _res;
}

class Input$IssueSetDueDateInput {
  factory Input$IssueSetDueDateInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? dueDate,
  }) =>
      Input$IssueSetDueDateInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (dueDate != null) r'dueDate': dueDate,
      });

  Input$IssueSetDueDateInput._(this._$data);

  factory Input$IssueSetDueDateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    return Input$IssueSetDueDateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get dueDate => (_$data['dueDate'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    return result$data;
  }

  CopyWith$Input$IssueSetDueDateInput<Input$IssueSetDueDateInput>
      get copyWith => CopyWith$Input$IssueSetDueDateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetDueDateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$dueDate = dueDate;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('dueDate') ? l$dueDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetDueDateInput<TRes> {
  factory CopyWith$Input$IssueSetDueDateInput(
    Input$IssueSetDueDateInput instance,
    TRes Function(Input$IssueSetDueDateInput) then,
  ) = _CopyWithImpl$Input$IssueSetDueDateInput;

  factory CopyWith$Input$IssueSetDueDateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetDueDateInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? dueDate,
  });
}

class _CopyWithImpl$Input$IssueSetDueDateInput<TRes>
    implements CopyWith$Input$IssueSetDueDateInput<TRes> {
  _CopyWithImpl$Input$IssueSetDueDateInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetDueDateInput _instance;

  final TRes Function(Input$IssueSetDueDateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? dueDate = _undefined,
  }) =>
      _then(Input$IssueSetDueDateInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetDueDateInput<TRes>
    implements CopyWith$Input$IssueSetDueDateInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetDueDateInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? dueDate,
  }) =>
      _res;
}

class Input$IssueSetEpicInput {
  factory Input$IssueSetEpicInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? epicId,
  }) =>
      Input$IssueSetEpicInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (epicId != null) r'epicId': epicId,
      });

  Input$IssueSetEpicInput._(this._$data);

  factory Input$IssueSetEpicInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    return Input$IssueSetEpicInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get epicId => (_$data['epicId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    return result$data;
  }

  CopyWith$Input$IssueSetEpicInput<Input$IssueSetEpicInput> get copyWith =>
      CopyWith$Input$IssueSetEpicInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetEpicInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$epicId = epicId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetEpicInput<TRes> {
  factory CopyWith$Input$IssueSetEpicInput(
    Input$IssueSetEpicInput instance,
    TRes Function(Input$IssueSetEpicInput) then,
  ) = _CopyWithImpl$Input$IssueSetEpicInput;

  factory CopyWith$Input$IssueSetEpicInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetEpicInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? epicId,
  });
}

class _CopyWithImpl$Input$IssueSetEpicInput<TRes>
    implements CopyWith$Input$IssueSetEpicInput<TRes> {
  _CopyWithImpl$Input$IssueSetEpicInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetEpicInput _instance;

  final TRes Function(Input$IssueSetEpicInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? epicId = _undefined,
  }) =>
      _then(Input$IssueSetEpicInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetEpicInput<TRes>
    implements CopyWith$Input$IssueSetEpicInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetEpicInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? epicId,
  }) =>
      _res;
}

class Input$IssueSetEscalationPolicyInput {
  factory Input$IssueSetEscalationPolicyInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? escalationPolicyId,
  }) =>
      Input$IssueSetEscalationPolicyInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (escalationPolicyId != null)
          r'escalationPolicyId': escalationPolicyId,
      });

  Input$IssueSetEscalationPolicyInput._(this._$data);

  factory Input$IssueSetEscalationPolicyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('escalationPolicyId')) {
      final l$escalationPolicyId = data['escalationPolicyId'];
      result$data['escalationPolicyId'] = (l$escalationPolicyId as String?);
    }
    return Input$IssueSetEscalationPolicyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get escalationPolicyId => (_$data['escalationPolicyId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('escalationPolicyId')) {
      final l$escalationPolicyId = escalationPolicyId;
      result$data['escalationPolicyId'] = l$escalationPolicyId;
    }
    return result$data;
  }

  CopyWith$Input$IssueSetEscalationPolicyInput<
          Input$IssueSetEscalationPolicyInput>
      get copyWith => CopyWith$Input$IssueSetEscalationPolicyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetEscalationPolicyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$escalationPolicyId = escalationPolicyId;
    final lOther$escalationPolicyId = other.escalationPolicyId;
    if (_$data.containsKey('escalationPolicyId') !=
        other._$data.containsKey('escalationPolicyId')) {
      return false;
    }
    if (l$escalationPolicyId != lOther$escalationPolicyId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$escalationPolicyId = escalationPolicyId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('escalationPolicyId')
          ? l$escalationPolicyId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetEscalationPolicyInput<TRes> {
  factory CopyWith$Input$IssueSetEscalationPolicyInput(
    Input$IssueSetEscalationPolicyInput instance,
    TRes Function(Input$IssueSetEscalationPolicyInput) then,
  ) = _CopyWithImpl$Input$IssueSetEscalationPolicyInput;

  factory CopyWith$Input$IssueSetEscalationPolicyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetEscalationPolicyInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? escalationPolicyId,
  });
}

class _CopyWithImpl$Input$IssueSetEscalationPolicyInput<TRes>
    implements CopyWith$Input$IssueSetEscalationPolicyInput<TRes> {
  _CopyWithImpl$Input$IssueSetEscalationPolicyInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetEscalationPolicyInput _instance;

  final TRes Function(Input$IssueSetEscalationPolicyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? escalationPolicyId = _undefined,
  }) =>
      _then(Input$IssueSetEscalationPolicyInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (escalationPolicyId != _undefined)
          'escalationPolicyId': (escalationPolicyId as String?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetEscalationPolicyInput<TRes>
    implements CopyWith$Input$IssueSetEscalationPolicyInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetEscalationPolicyInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? escalationPolicyId,
  }) =>
      _res;
}

class Input$IssueSetEscalationStatusInput {
  factory Input$IssueSetEscalationStatusInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required Enum$IssueEscalationStatus status,
  }) =>
      Input$IssueSetEscalationStatusInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'status': status,
      });

  Input$IssueSetEscalationStatusInput._(this._$data);

  factory Input$IssueSetEscalationStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$status = data['status'];
    result$data['status'] =
        fromJson$Enum$IssueEscalationStatus((l$status as String));
    return Input$IssueSetEscalationStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$IssueEscalationStatus get status =>
      (_$data['status'] as Enum$IssueEscalationStatus);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$status = status;
    result$data['status'] = toJson$Enum$IssueEscalationStatus(l$status);
    return result$data;
  }

  CopyWith$Input$IssueSetEscalationStatusInput<
          Input$IssueSetEscalationStatusInput>
      get copyWith => CopyWith$Input$IssueSetEscalationStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetEscalationStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$status = status;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$IssueSetEscalationStatusInput<TRes> {
  factory CopyWith$Input$IssueSetEscalationStatusInput(
    Input$IssueSetEscalationStatusInput instance,
    TRes Function(Input$IssueSetEscalationStatusInput) then,
  ) = _CopyWithImpl$Input$IssueSetEscalationStatusInput;

  factory CopyWith$Input$IssueSetEscalationStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetEscalationStatusInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$IssueEscalationStatus? status,
  });
}

class _CopyWithImpl$Input$IssueSetEscalationStatusInput<TRes>
    implements CopyWith$Input$IssueSetEscalationStatusInput<TRes> {
  _CopyWithImpl$Input$IssueSetEscalationStatusInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetEscalationStatusInput _instance;

  final TRes Function(Input$IssueSetEscalationStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$IssueSetEscalationStatusInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (status != _undefined && status != null)
          'status': (status as Enum$IssueEscalationStatus),
      }));
}

class _CopyWithStubImpl$Input$IssueSetEscalationStatusInput<TRes>
    implements CopyWith$Input$IssueSetEscalationStatusInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetEscalationStatusInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$IssueEscalationStatus? status,
  }) =>
      _res;
}

class Input$IssueSetIterationInput {
  factory Input$IssueSetIterationInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? iterationId,
  }) =>
      Input$IssueSetIterationInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (iterationId != null) r'iterationId': iterationId,
      });

  Input$IssueSetIterationInput._(this._$data);

  factory Input$IssueSetIterationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    return Input$IssueSetIterationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get iterationId => (_$data['iterationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    return result$data;
  }

  CopyWith$Input$IssueSetIterationInput<Input$IssueSetIterationInput>
      get copyWith => CopyWith$Input$IssueSetIterationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetIterationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$iterationId = iterationId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetIterationInput<TRes> {
  factory CopyWith$Input$IssueSetIterationInput(
    Input$IssueSetIterationInput instance,
    TRes Function(Input$IssueSetIterationInput) then,
  ) = _CopyWithImpl$Input$IssueSetIterationInput;

  factory CopyWith$Input$IssueSetIterationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetIterationInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? iterationId,
  });
}

class _CopyWithImpl$Input$IssueSetIterationInput<TRes>
    implements CopyWith$Input$IssueSetIterationInput<TRes> {
  _CopyWithImpl$Input$IssueSetIterationInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetIterationInput _instance;

  final TRes Function(Input$IssueSetIterationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? iterationId = _undefined,
  }) =>
      _then(Input$IssueSetIterationInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetIterationInput<TRes>
    implements CopyWith$Input$IssueSetIterationInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetIterationInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? iterationId,
  }) =>
      _res;
}

class Input$IssueSetLockedInput {
  factory Input$IssueSetLockedInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required bool locked,
  }) =>
      Input$IssueSetLockedInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'locked': locked,
      });

  Input$IssueSetLockedInput._(this._$data);

  factory Input$IssueSetLockedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$locked = data['locked'];
    result$data['locked'] = (l$locked as bool);
    return Input$IssueSetLockedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get locked => (_$data['locked'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$locked = locked;
    result$data['locked'] = l$locked;
    return result$data;
  }

  CopyWith$Input$IssueSetLockedInput<Input$IssueSetLockedInput> get copyWith =>
      CopyWith$Input$IssueSetLockedInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetLockedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$locked = locked;
    final lOther$locked = other.locked;
    if (l$locked != lOther$locked) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$locked = locked;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$locked,
    ]);
  }
}

abstract class CopyWith$Input$IssueSetLockedInput<TRes> {
  factory CopyWith$Input$IssueSetLockedInput(
    Input$IssueSetLockedInput instance,
    TRes Function(Input$IssueSetLockedInput) then,
  ) = _CopyWithImpl$Input$IssueSetLockedInput;

  factory CopyWith$Input$IssueSetLockedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetLockedInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? locked,
  });
}

class _CopyWithImpl$Input$IssueSetLockedInput<TRes>
    implements CopyWith$Input$IssueSetLockedInput<TRes> {
  _CopyWithImpl$Input$IssueSetLockedInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetLockedInput _instance;

  final TRes Function(Input$IssueSetLockedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? locked = _undefined,
  }) =>
      _then(Input$IssueSetLockedInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (locked != _undefined && locked != null) 'locked': (locked as bool),
      }));
}

class _CopyWithStubImpl$Input$IssueSetLockedInput<TRes>
    implements CopyWith$Input$IssueSetLockedInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetLockedInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? locked,
  }) =>
      _res;
}

class Input$IssueSetSeverityInput {
  factory Input$IssueSetSeverityInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required Enum$IssuableSeverity severity,
  }) =>
      Input$IssueSetSeverityInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'severity': severity,
      });

  Input$IssueSetSeverityInput._(this._$data);

  factory Input$IssueSetSeverityInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$severity = data['severity'];
    result$data['severity'] =
        fromJson$Enum$IssuableSeverity((l$severity as String));
    return Input$IssueSetSeverityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$IssuableSeverity get severity =>
      (_$data['severity'] as Enum$IssuableSeverity);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$severity = severity;
    result$data['severity'] = toJson$Enum$IssuableSeverity(l$severity);
    return result$data;
  }

  CopyWith$Input$IssueSetSeverityInput<Input$IssueSetSeverityInput>
      get copyWith => CopyWith$Input$IssueSetSeverityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetSeverityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$severity = severity;
    final lOther$severity = other.severity;
    if (l$severity != lOther$severity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$severity = severity;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$severity,
    ]);
  }
}

abstract class CopyWith$Input$IssueSetSeverityInput<TRes> {
  factory CopyWith$Input$IssueSetSeverityInput(
    Input$IssueSetSeverityInput instance,
    TRes Function(Input$IssueSetSeverityInput) then,
  ) = _CopyWithImpl$Input$IssueSetSeverityInput;

  factory CopyWith$Input$IssueSetSeverityInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetSeverityInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$IssuableSeverity? severity,
  });
}

class _CopyWithImpl$Input$IssueSetSeverityInput<TRes>
    implements CopyWith$Input$IssueSetSeverityInput<TRes> {
  _CopyWithImpl$Input$IssueSetSeverityInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetSeverityInput _instance;

  final TRes Function(Input$IssueSetSeverityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? severity = _undefined,
  }) =>
      _then(Input$IssueSetSeverityInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (severity != _undefined && severity != null)
          'severity': (severity as Enum$IssuableSeverity),
      }));
}

class _CopyWithStubImpl$Input$IssueSetSeverityInput<TRes>
    implements CopyWith$Input$IssueSetSeverityInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetSeverityInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$IssuableSeverity? severity,
  }) =>
      _res;
}

class Input$IssueSetSubscriptionInput {
  factory Input$IssueSetSubscriptionInput({
    String? clientMutationId,
    required bool subscribedState,
    required String projectPath,
    required String iid,
  }) =>
      Input$IssueSetSubscriptionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subscribedState': subscribedState,
        r'projectPath': projectPath,
        r'iid': iid,
      });

  Input$IssueSetSubscriptionInput._(this._$data);

  factory Input$IssueSetSubscriptionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subscribedState = data['subscribedState'];
    result$data['subscribedState'] = (l$subscribedState as bool);
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    return Input$IssueSetSubscriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get subscribedState => (_$data['subscribedState'] as bool);
  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subscribedState = subscribedState;
    result$data['subscribedState'] = l$subscribedState;
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    return result$data;
  }

  CopyWith$Input$IssueSetSubscriptionInput<Input$IssueSetSubscriptionInput>
      get copyWith => CopyWith$Input$IssueSetSubscriptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetSubscriptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subscribedState = subscribedState;
    final lOther$subscribedState = other.subscribedState;
    if (l$subscribedState != lOther$subscribedState) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subscribedState = subscribedState;
    final l$projectPath = projectPath;
    final l$iid = iid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subscribedState,
      l$projectPath,
      l$iid,
    ]);
  }
}

abstract class CopyWith$Input$IssueSetSubscriptionInput<TRes> {
  factory CopyWith$Input$IssueSetSubscriptionInput(
    Input$IssueSetSubscriptionInput instance,
    TRes Function(Input$IssueSetSubscriptionInput) then,
  ) = _CopyWithImpl$Input$IssueSetSubscriptionInput;

  factory CopyWith$Input$IssueSetSubscriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetSubscriptionInput;

  TRes call({
    String? clientMutationId,
    bool? subscribedState,
    String? projectPath,
    String? iid,
  });
}

class _CopyWithImpl$Input$IssueSetSubscriptionInput<TRes>
    implements CopyWith$Input$IssueSetSubscriptionInput<TRes> {
  _CopyWithImpl$Input$IssueSetSubscriptionInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetSubscriptionInput _instance;

  final TRes Function(Input$IssueSetSubscriptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subscribedState = _undefined,
    Object? projectPath = _undefined,
    Object? iid = _undefined,
  }) =>
      _then(Input$IssueSetSubscriptionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subscribedState != _undefined && subscribedState != null)
          'subscribedState': (subscribedState as bool),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
      }));
}

class _CopyWithStubImpl$Input$IssueSetSubscriptionInput<TRes>
    implements CopyWith$Input$IssueSetSubscriptionInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetSubscriptionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? subscribedState,
    String? projectPath,
    String? iid,
  }) =>
      _res;
}

class Input$IssueSetWeightInput {
  factory Input$IssueSetWeightInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    int? weight,
  }) =>
      Input$IssueSetWeightInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (weight != null) r'weight': weight,
      });

  Input$IssueSetWeightInput._(this._$data);

  factory Input$IssueSetWeightInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as int?);
    }
    return Input$IssueSetWeightInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  int? get weight => (_$data['weight'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    return result$data;
  }

  CopyWith$Input$IssueSetWeightInput<Input$IssueSetWeightInput> get copyWith =>
      CopyWith$Input$IssueSetWeightInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueSetWeightInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$weight = weight;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('weight') ? l$weight : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueSetWeightInput<TRes> {
  factory CopyWith$Input$IssueSetWeightInput(
    Input$IssueSetWeightInput instance,
    TRes Function(Input$IssueSetWeightInput) then,
  ) = _CopyWithImpl$Input$IssueSetWeightInput;

  factory CopyWith$Input$IssueSetWeightInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueSetWeightInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    int? weight,
  });
}

class _CopyWithImpl$Input$IssueSetWeightInput<TRes>
    implements CopyWith$Input$IssueSetWeightInput<TRes> {
  _CopyWithImpl$Input$IssueSetWeightInput(
    this._instance,
    this._then,
  );

  final Input$IssueSetWeightInput _instance;

  final TRes Function(Input$IssueSetWeightInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? weight = _undefined,
  }) =>
      _then(Input$IssueSetWeightInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (weight != _undefined) 'weight': (weight as int?),
      }));
}

class _CopyWithStubImpl$Input$IssueSetWeightInput<TRes>
    implements CopyWith$Input$IssueSetWeightInput<TRes> {
  _CopyWithStubImpl$Input$IssueSetWeightInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    int? weight,
  }) =>
      _res;
}

class Input$IterationCadenceCreateInput {
  factory Input$IterationCadenceCreateInput({
    String? clientMutationId,
    required String groupPath,
    String? title,
    int? durationInWeeks,
    int? iterationsInAdvance,
    String? startDate,
    required bool automatic,
    required bool active,
    bool? rollOver,
    String? description,
  }) =>
      Input$IterationCadenceCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        if (title != null) r'title': title,
        if (durationInWeeks != null) r'durationInWeeks': durationInWeeks,
        if (iterationsInAdvance != null)
          r'iterationsInAdvance': iterationsInAdvance,
        if (startDate != null) r'startDate': startDate,
        r'automatic': automatic,
        r'active': active,
        if (rollOver != null) r'rollOver': rollOver,
        if (description != null) r'description': description,
      });

  Input$IterationCadenceCreateInput._(this._$data);

  factory Input$IterationCadenceCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('durationInWeeks')) {
      final l$durationInWeeks = data['durationInWeeks'];
      result$data['durationInWeeks'] = (l$durationInWeeks as int?);
    }
    if (data.containsKey('iterationsInAdvance')) {
      final l$iterationsInAdvance = data['iterationsInAdvance'];
      result$data['iterationsInAdvance'] = (l$iterationsInAdvance as int?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    final l$automatic = data['automatic'];
    result$data['automatic'] = (l$automatic as bool);
    final l$active = data['active'];
    result$data['active'] = (l$active as bool);
    if (data.containsKey('rollOver')) {
      final l$rollOver = data['rollOver'];
      result$data['rollOver'] = (l$rollOver as bool?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$IterationCadenceCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  String? get title => (_$data['title'] as String?);
  int? get durationInWeeks => (_$data['durationInWeeks'] as int?);
  int? get iterationsInAdvance => (_$data['iterationsInAdvance'] as int?);
  String? get startDate => (_$data['startDate'] as String?);
  bool get automatic => (_$data['automatic'] as bool);
  bool get active => (_$data['active'] as bool);
  bool? get rollOver => (_$data['rollOver'] as bool?);
  String? get description => (_$data['description'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('durationInWeeks')) {
      final l$durationInWeeks = durationInWeeks;
      result$data['durationInWeeks'] = l$durationInWeeks;
    }
    if (_$data.containsKey('iterationsInAdvance')) {
      final l$iterationsInAdvance = iterationsInAdvance;
      result$data['iterationsInAdvance'] = l$iterationsInAdvance;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    final l$automatic = automatic;
    result$data['automatic'] = l$automatic;
    final l$active = active;
    result$data['active'] = l$active;
    if (_$data.containsKey('rollOver')) {
      final l$rollOver = rollOver;
      result$data['rollOver'] = l$rollOver;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$IterationCadenceCreateInput<Input$IterationCadenceCreateInput>
      get copyWith => CopyWith$Input$IterationCadenceCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IterationCadenceCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$durationInWeeks = durationInWeeks;
    final lOther$durationInWeeks = other.durationInWeeks;
    if (_$data.containsKey('durationInWeeks') !=
        other._$data.containsKey('durationInWeeks')) {
      return false;
    }
    if (l$durationInWeeks != lOther$durationInWeeks) {
      return false;
    }
    final l$iterationsInAdvance = iterationsInAdvance;
    final lOther$iterationsInAdvance = other.iterationsInAdvance;
    if (_$data.containsKey('iterationsInAdvance') !=
        other._$data.containsKey('iterationsInAdvance')) {
      return false;
    }
    if (l$iterationsInAdvance != lOther$iterationsInAdvance) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$automatic = automatic;
    final lOther$automatic = other.automatic;
    if (l$automatic != lOther$automatic) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (l$active != lOther$active) {
      return false;
    }
    final l$rollOver = rollOver;
    final lOther$rollOver = other.rollOver;
    if (_$data.containsKey('rollOver') !=
        other._$data.containsKey('rollOver')) {
      return false;
    }
    if (l$rollOver != lOther$rollOver) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$title = title;
    final l$durationInWeeks = durationInWeeks;
    final l$iterationsInAdvance = iterationsInAdvance;
    final l$startDate = startDate;
    final l$automatic = automatic;
    final l$active = active;
    final l$rollOver = rollOver;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('durationInWeeks') ? l$durationInWeeks : const {},
      _$data.containsKey('iterationsInAdvance')
          ? l$iterationsInAdvance
          : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      l$automatic,
      l$active,
      _$data.containsKey('rollOver') ? l$rollOver : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$IterationCadenceCreateInput<TRes> {
  factory CopyWith$Input$IterationCadenceCreateInput(
    Input$IterationCadenceCreateInput instance,
    TRes Function(Input$IterationCadenceCreateInput) then,
  ) = _CopyWithImpl$Input$IterationCadenceCreateInput;

  factory CopyWith$Input$IterationCadenceCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IterationCadenceCreateInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    String? title,
    int? durationInWeeks,
    int? iterationsInAdvance,
    String? startDate,
    bool? automatic,
    bool? active,
    bool? rollOver,
    String? description,
  });
}

class _CopyWithImpl$Input$IterationCadenceCreateInput<TRes>
    implements CopyWith$Input$IterationCadenceCreateInput<TRes> {
  _CopyWithImpl$Input$IterationCadenceCreateInput(
    this._instance,
    this._then,
  );

  final Input$IterationCadenceCreateInput _instance;

  final TRes Function(Input$IterationCadenceCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? title = _undefined,
    Object? durationInWeeks = _undefined,
    Object? iterationsInAdvance = _undefined,
    Object? startDate = _undefined,
    Object? automatic = _undefined,
    Object? active = _undefined,
    Object? rollOver = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$IterationCadenceCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (title != _undefined) 'title': (title as String?),
        if (durationInWeeks != _undefined)
          'durationInWeeks': (durationInWeeks as int?),
        if (iterationsInAdvance != _undefined)
          'iterationsInAdvance': (iterationsInAdvance as int?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (automatic != _undefined && automatic != null)
          'automatic': (automatic as bool),
        if (active != _undefined && active != null) 'active': (active as bool),
        if (rollOver != _undefined) 'rollOver': (rollOver as bool?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$IterationCadenceCreateInput<TRes>
    implements CopyWith$Input$IterationCadenceCreateInput<TRes> {
  _CopyWithStubImpl$Input$IterationCadenceCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    String? title,
    int? durationInWeeks,
    int? iterationsInAdvance,
    String? startDate,
    bool? automatic,
    bool? active,
    bool? rollOver,
    String? description,
  }) =>
      _res;
}

class Input$IterationCadenceDestroyInput {
  factory Input$IterationCadenceDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$IterationCadenceDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$IterationCadenceDestroyInput._(this._$data);

  factory Input$IterationCadenceDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$IterationCadenceDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$IterationCadenceDestroyInput<
          Input$IterationCadenceDestroyInput>
      get copyWith => CopyWith$Input$IterationCadenceDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IterationCadenceDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$IterationCadenceDestroyInput<TRes> {
  factory CopyWith$Input$IterationCadenceDestroyInput(
    Input$IterationCadenceDestroyInput instance,
    TRes Function(Input$IterationCadenceDestroyInput) then,
  ) = _CopyWithImpl$Input$IterationCadenceDestroyInput;

  factory CopyWith$Input$IterationCadenceDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IterationCadenceDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$IterationCadenceDestroyInput<TRes>
    implements CopyWith$Input$IterationCadenceDestroyInput<TRes> {
  _CopyWithImpl$Input$IterationCadenceDestroyInput(
    this._instance,
    this._then,
  );

  final Input$IterationCadenceDestroyInput _instance;

  final TRes Function(Input$IterationCadenceDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$IterationCadenceDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$IterationCadenceDestroyInput<TRes>
    implements CopyWith$Input$IterationCadenceDestroyInput<TRes> {
  _CopyWithStubImpl$Input$IterationCadenceDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$IterationCadenceUpdateInput {
  factory Input$IterationCadenceUpdateInput({
    String? clientMutationId,
    required String id,
    String? title,
    int? durationInWeeks,
    int? iterationsInAdvance,
    String? startDate,
    bool? automatic,
    bool? active,
    bool? rollOver,
    String? description,
  }) =>
      Input$IterationCadenceUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (title != null) r'title': title,
        if (durationInWeeks != null) r'durationInWeeks': durationInWeeks,
        if (iterationsInAdvance != null)
          r'iterationsInAdvance': iterationsInAdvance,
        if (startDate != null) r'startDate': startDate,
        if (automatic != null) r'automatic': automatic,
        if (active != null) r'active': active,
        if (rollOver != null) r'rollOver': rollOver,
        if (description != null) r'description': description,
      });

  Input$IterationCadenceUpdateInput._(this._$data);

  factory Input$IterationCadenceUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('durationInWeeks')) {
      final l$durationInWeeks = data['durationInWeeks'];
      result$data['durationInWeeks'] = (l$durationInWeeks as int?);
    }
    if (data.containsKey('iterationsInAdvance')) {
      final l$iterationsInAdvance = data['iterationsInAdvance'];
      result$data['iterationsInAdvance'] = (l$iterationsInAdvance as int?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('automatic')) {
      final l$automatic = data['automatic'];
      result$data['automatic'] = (l$automatic as bool?);
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    if (data.containsKey('rollOver')) {
      final l$rollOver = data['rollOver'];
      result$data['rollOver'] = (l$rollOver as bool?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$IterationCadenceUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get title => (_$data['title'] as String?);
  int? get durationInWeeks => (_$data['durationInWeeks'] as int?);
  int? get iterationsInAdvance => (_$data['iterationsInAdvance'] as int?);
  String? get startDate => (_$data['startDate'] as String?);
  bool? get automatic => (_$data['automatic'] as bool?);
  bool? get active => (_$data['active'] as bool?);
  bool? get rollOver => (_$data['rollOver'] as bool?);
  String? get description => (_$data['description'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('durationInWeeks')) {
      final l$durationInWeeks = durationInWeeks;
      result$data['durationInWeeks'] = l$durationInWeeks;
    }
    if (_$data.containsKey('iterationsInAdvance')) {
      final l$iterationsInAdvance = iterationsInAdvance;
      result$data['iterationsInAdvance'] = l$iterationsInAdvance;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('automatic')) {
      final l$automatic = automatic;
      result$data['automatic'] = l$automatic;
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    if (_$data.containsKey('rollOver')) {
      final l$rollOver = rollOver;
      result$data['rollOver'] = l$rollOver;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$IterationCadenceUpdateInput<Input$IterationCadenceUpdateInput>
      get copyWith => CopyWith$Input$IterationCadenceUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IterationCadenceUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$durationInWeeks = durationInWeeks;
    final lOther$durationInWeeks = other.durationInWeeks;
    if (_$data.containsKey('durationInWeeks') !=
        other._$data.containsKey('durationInWeeks')) {
      return false;
    }
    if (l$durationInWeeks != lOther$durationInWeeks) {
      return false;
    }
    final l$iterationsInAdvance = iterationsInAdvance;
    final lOther$iterationsInAdvance = other.iterationsInAdvance;
    if (_$data.containsKey('iterationsInAdvance') !=
        other._$data.containsKey('iterationsInAdvance')) {
      return false;
    }
    if (l$iterationsInAdvance != lOther$iterationsInAdvance) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$automatic = automatic;
    final lOther$automatic = other.automatic;
    if (_$data.containsKey('automatic') !=
        other._$data.containsKey('automatic')) {
      return false;
    }
    if (l$automatic != lOther$automatic) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$rollOver = rollOver;
    final lOther$rollOver = other.rollOver;
    if (_$data.containsKey('rollOver') !=
        other._$data.containsKey('rollOver')) {
      return false;
    }
    if (l$rollOver != lOther$rollOver) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$title = title;
    final l$durationInWeeks = durationInWeeks;
    final l$iterationsInAdvance = iterationsInAdvance;
    final l$startDate = startDate;
    final l$automatic = automatic;
    final l$active = active;
    final l$rollOver = rollOver;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('durationInWeeks') ? l$durationInWeeks : const {},
      _$data.containsKey('iterationsInAdvance')
          ? l$iterationsInAdvance
          : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('automatic') ? l$automatic : const {},
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('rollOver') ? l$rollOver : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$IterationCadenceUpdateInput<TRes> {
  factory CopyWith$Input$IterationCadenceUpdateInput(
    Input$IterationCadenceUpdateInput instance,
    TRes Function(Input$IterationCadenceUpdateInput) then,
  ) = _CopyWithImpl$Input$IterationCadenceUpdateInput;

  factory CopyWith$Input$IterationCadenceUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IterationCadenceUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? title,
    int? durationInWeeks,
    int? iterationsInAdvance,
    String? startDate,
    bool? automatic,
    bool? active,
    bool? rollOver,
    String? description,
  });
}

class _CopyWithImpl$Input$IterationCadenceUpdateInput<TRes>
    implements CopyWith$Input$IterationCadenceUpdateInput<TRes> {
  _CopyWithImpl$Input$IterationCadenceUpdateInput(
    this._instance,
    this._then,
  );

  final Input$IterationCadenceUpdateInput _instance;

  final TRes Function(Input$IterationCadenceUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? title = _undefined,
    Object? durationInWeeks = _undefined,
    Object? iterationsInAdvance = _undefined,
    Object? startDate = _undefined,
    Object? automatic = _undefined,
    Object? active = _undefined,
    Object? rollOver = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$IterationCadenceUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (durationInWeeks != _undefined)
          'durationInWeeks': (durationInWeeks as int?),
        if (iterationsInAdvance != _undefined)
          'iterationsInAdvance': (iterationsInAdvance as int?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (automatic != _undefined) 'automatic': (automatic as bool?),
        if (active != _undefined) 'active': (active as bool?),
        if (rollOver != _undefined) 'rollOver': (rollOver as bool?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$IterationCadenceUpdateInput<TRes>
    implements CopyWith$Input$IterationCadenceUpdateInput<TRes> {
  _CopyWithStubImpl$Input$IterationCadenceUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? title,
    int? durationInWeeks,
    int? iterationsInAdvance,
    String? startDate,
    bool? automatic,
    bool? active,
    bool? rollOver,
    String? description,
  }) =>
      _res;
}

class Input$IterationDeleteInput {
  factory Input$IterationDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$IterationDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$IterationDeleteInput._(this._$data);

  factory Input$IterationDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$IterationDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$IterationDeleteInput<Input$IterationDeleteInput>
      get copyWith => CopyWith$Input$IterationDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IterationDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$IterationDeleteInput<TRes> {
  factory CopyWith$Input$IterationDeleteInput(
    Input$IterationDeleteInput instance,
    TRes Function(Input$IterationDeleteInput) then,
  ) = _CopyWithImpl$Input$IterationDeleteInput;

  factory CopyWith$Input$IterationDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IterationDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$IterationDeleteInput<TRes>
    implements CopyWith$Input$IterationDeleteInput<TRes> {
  _CopyWithImpl$Input$IterationDeleteInput(
    this._instance,
    this._then,
  );

  final Input$IterationDeleteInput _instance;

  final TRes Function(Input$IterationDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$IterationDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$IterationDeleteInput<TRes>
    implements CopyWith$Input$IterationDeleteInput<TRes> {
  _CopyWithStubImpl$Input$IterationDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$JiraImportStartInput {
  factory Input$JiraImportStartInput({
    String? clientMutationId,
    required String jiraProjectKey,
    String? jiraProjectName,
    required String projectPath,
    List<Input$JiraUsersMappingInputType>? usersMapping,
  }) =>
      Input$JiraImportStartInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'jiraProjectKey': jiraProjectKey,
        if (jiraProjectName != null) r'jiraProjectName': jiraProjectName,
        r'projectPath': projectPath,
        if (usersMapping != null) r'usersMapping': usersMapping,
      });

  Input$JiraImportStartInput._(this._$data);

  factory Input$JiraImportStartInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$jiraProjectKey = data['jiraProjectKey'];
    result$data['jiraProjectKey'] = (l$jiraProjectKey as String);
    if (data.containsKey('jiraProjectName')) {
      final l$jiraProjectName = data['jiraProjectName'];
      result$data['jiraProjectName'] = (l$jiraProjectName as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('usersMapping')) {
      final l$usersMapping = data['usersMapping'];
      result$data['usersMapping'] = (l$usersMapping as List<dynamic>?)
          ?.map((e) => Input$JiraUsersMappingInputType.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$JiraImportStartInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get jiraProjectKey => (_$data['jiraProjectKey'] as String);
  String? get jiraProjectName => (_$data['jiraProjectName'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  List<Input$JiraUsersMappingInputType>? get usersMapping =>
      (_$data['usersMapping'] as List<Input$JiraUsersMappingInputType>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$jiraProjectKey = jiraProjectKey;
    result$data['jiraProjectKey'] = l$jiraProjectKey;
    if (_$data.containsKey('jiraProjectName')) {
      final l$jiraProjectName = jiraProjectName;
      result$data['jiraProjectName'] = l$jiraProjectName;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('usersMapping')) {
      final l$usersMapping = usersMapping;
      result$data['usersMapping'] =
          l$usersMapping?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$JiraImportStartInput<Input$JiraImportStartInput>
      get copyWith => CopyWith$Input$JiraImportStartInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JiraImportStartInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$jiraProjectKey = jiraProjectKey;
    final lOther$jiraProjectKey = other.jiraProjectKey;
    if (l$jiraProjectKey != lOther$jiraProjectKey) {
      return false;
    }
    final l$jiraProjectName = jiraProjectName;
    final lOther$jiraProjectName = other.jiraProjectName;
    if (_$data.containsKey('jiraProjectName') !=
        other._$data.containsKey('jiraProjectName')) {
      return false;
    }
    if (l$jiraProjectName != lOther$jiraProjectName) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$usersMapping = usersMapping;
    final lOther$usersMapping = other.usersMapping;
    if (_$data.containsKey('usersMapping') !=
        other._$data.containsKey('usersMapping')) {
      return false;
    }
    if (l$usersMapping != null && lOther$usersMapping != null) {
      if (l$usersMapping.length != lOther$usersMapping.length) {
        return false;
      }
      for (int i = 0; i < l$usersMapping.length; i++) {
        final l$usersMapping$entry = l$usersMapping[i];
        final lOther$usersMapping$entry = lOther$usersMapping[i];
        if (l$usersMapping$entry != lOther$usersMapping$entry) {
          return false;
        }
      }
    } else if (l$usersMapping != lOther$usersMapping) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$jiraProjectKey = jiraProjectKey;
    final l$jiraProjectName = jiraProjectName;
    final l$projectPath = projectPath;
    final l$usersMapping = usersMapping;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$jiraProjectKey,
      _$data.containsKey('jiraProjectName') ? l$jiraProjectName : const {},
      l$projectPath,
      _$data.containsKey('usersMapping')
          ? l$usersMapping == null
              ? null
              : Object.hashAll(l$usersMapping.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$JiraImportStartInput<TRes> {
  factory CopyWith$Input$JiraImportStartInput(
    Input$JiraImportStartInput instance,
    TRes Function(Input$JiraImportStartInput) then,
  ) = _CopyWithImpl$Input$JiraImportStartInput;

  factory CopyWith$Input$JiraImportStartInput.stub(TRes res) =
      _CopyWithStubImpl$Input$JiraImportStartInput;

  TRes call({
    String? clientMutationId,
    String? jiraProjectKey,
    String? jiraProjectName,
    String? projectPath,
    List<Input$JiraUsersMappingInputType>? usersMapping,
  });
  TRes usersMapping(
      Iterable<Input$JiraUsersMappingInputType>? Function(
              Iterable<
                  CopyWith$Input$JiraUsersMappingInputType<
                      Input$JiraUsersMappingInputType>>?)
          _fn);
}

class _CopyWithImpl$Input$JiraImportStartInput<TRes>
    implements CopyWith$Input$JiraImportStartInput<TRes> {
  _CopyWithImpl$Input$JiraImportStartInput(
    this._instance,
    this._then,
  );

  final Input$JiraImportStartInput _instance;

  final TRes Function(Input$JiraImportStartInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? jiraProjectKey = _undefined,
    Object? jiraProjectName = _undefined,
    Object? projectPath = _undefined,
    Object? usersMapping = _undefined,
  }) =>
      _then(Input$JiraImportStartInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (jiraProjectKey != _undefined && jiraProjectKey != null)
          'jiraProjectKey': (jiraProjectKey as String),
        if (jiraProjectName != _undefined)
          'jiraProjectName': (jiraProjectName as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (usersMapping != _undefined)
          'usersMapping':
              (usersMapping as List<Input$JiraUsersMappingInputType>?),
      }));
  TRes usersMapping(
          Iterable<Input$JiraUsersMappingInputType>? Function(
                  Iterable<
                      CopyWith$Input$JiraUsersMappingInputType<
                          Input$JiraUsersMappingInputType>>?)
              _fn) =>
      call(
          usersMapping: _fn(_instance.usersMapping
              ?.map((e) => CopyWith$Input$JiraUsersMappingInputType(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$JiraImportStartInput<TRes>
    implements CopyWith$Input$JiraImportStartInput<TRes> {
  _CopyWithStubImpl$Input$JiraImportStartInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? jiraProjectKey,
    String? jiraProjectName,
    String? projectPath,
    List<Input$JiraUsersMappingInputType>? usersMapping,
  }) =>
      _res;
  usersMapping(_fn) => _res;
}

class Input$JiraImportUsersInput {
  factory Input$JiraImportUsersInput({
    String? clientMutationId,
    required String projectPath,
    int? startAt,
  }) =>
      Input$JiraImportUsersInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        if (startAt != null) r'startAt': startAt,
      });

  Input$JiraImportUsersInput._(this._$data);

  factory Input$JiraImportUsersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('startAt')) {
      final l$startAt = data['startAt'];
      result$data['startAt'] = (l$startAt as int?);
    }
    return Input$JiraImportUsersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  int? get startAt => (_$data['startAt'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('startAt')) {
      final l$startAt = startAt;
      result$data['startAt'] = l$startAt;
    }
    return result$data;
  }

  CopyWith$Input$JiraImportUsersInput<Input$JiraImportUsersInput>
      get copyWith => CopyWith$Input$JiraImportUsersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JiraImportUsersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$startAt = startAt;
    final lOther$startAt = other.startAt;
    if (_$data.containsKey('startAt') != other._$data.containsKey('startAt')) {
      return false;
    }
    if (l$startAt != lOther$startAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$startAt = startAt;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      _$data.containsKey('startAt') ? l$startAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$JiraImportUsersInput<TRes> {
  factory CopyWith$Input$JiraImportUsersInput(
    Input$JiraImportUsersInput instance,
    TRes Function(Input$JiraImportUsersInput) then,
  ) = _CopyWithImpl$Input$JiraImportUsersInput;

  factory CopyWith$Input$JiraImportUsersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$JiraImportUsersInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    int? startAt,
  });
}

class _CopyWithImpl$Input$JiraImportUsersInput<TRes>
    implements CopyWith$Input$JiraImportUsersInput<TRes> {
  _CopyWithImpl$Input$JiraImportUsersInput(
    this._instance,
    this._then,
  );

  final Input$JiraImportUsersInput _instance;

  final TRes Function(Input$JiraImportUsersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? startAt = _undefined,
  }) =>
      _then(Input$JiraImportUsersInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (startAt != _undefined) 'startAt': (startAt as int?),
      }));
}

class _CopyWithStubImpl$Input$JiraImportUsersInput<TRes>
    implements CopyWith$Input$JiraImportUsersInput<TRes> {
  _CopyWithStubImpl$Input$JiraImportUsersInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    int? startAt,
  }) =>
      _res;
}

class Input$JiraUsersMappingInputType {
  factory Input$JiraUsersMappingInputType({
    int? gitlabId,
    required String jiraAccountId,
  }) =>
      Input$JiraUsersMappingInputType._({
        if (gitlabId != null) r'gitlabId': gitlabId,
        r'jiraAccountId': jiraAccountId,
      });

  Input$JiraUsersMappingInputType._(this._$data);

  factory Input$JiraUsersMappingInputType.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('gitlabId')) {
      final l$gitlabId = data['gitlabId'];
      result$data['gitlabId'] = (l$gitlabId as int?);
    }
    final l$jiraAccountId = data['jiraAccountId'];
    result$data['jiraAccountId'] = (l$jiraAccountId as String);
    return Input$JiraUsersMappingInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get gitlabId => (_$data['gitlabId'] as int?);
  String get jiraAccountId => (_$data['jiraAccountId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('gitlabId')) {
      final l$gitlabId = gitlabId;
      result$data['gitlabId'] = l$gitlabId;
    }
    final l$jiraAccountId = jiraAccountId;
    result$data['jiraAccountId'] = l$jiraAccountId;
    return result$data;
  }

  CopyWith$Input$JiraUsersMappingInputType<Input$JiraUsersMappingInputType>
      get copyWith => CopyWith$Input$JiraUsersMappingInputType(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JiraUsersMappingInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$gitlabId = gitlabId;
    final lOther$gitlabId = other.gitlabId;
    if (_$data.containsKey('gitlabId') !=
        other._$data.containsKey('gitlabId')) {
      return false;
    }
    if (l$gitlabId != lOther$gitlabId) {
      return false;
    }
    final l$jiraAccountId = jiraAccountId;
    final lOther$jiraAccountId = other.jiraAccountId;
    if (l$jiraAccountId != lOther$jiraAccountId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gitlabId = gitlabId;
    final l$jiraAccountId = jiraAccountId;
    return Object.hashAll([
      _$data.containsKey('gitlabId') ? l$gitlabId : const {},
      l$jiraAccountId,
    ]);
  }
}

abstract class CopyWith$Input$JiraUsersMappingInputType<TRes> {
  factory CopyWith$Input$JiraUsersMappingInputType(
    Input$JiraUsersMappingInputType instance,
    TRes Function(Input$JiraUsersMappingInputType) then,
  ) = _CopyWithImpl$Input$JiraUsersMappingInputType;

  factory CopyWith$Input$JiraUsersMappingInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$JiraUsersMappingInputType;

  TRes call({
    int? gitlabId,
    String? jiraAccountId,
  });
}

class _CopyWithImpl$Input$JiraUsersMappingInputType<TRes>
    implements CopyWith$Input$JiraUsersMappingInputType<TRes> {
  _CopyWithImpl$Input$JiraUsersMappingInputType(
    this._instance,
    this._then,
  );

  final Input$JiraUsersMappingInputType _instance;

  final TRes Function(Input$JiraUsersMappingInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gitlabId = _undefined,
    Object? jiraAccountId = _undefined,
  }) =>
      _then(Input$JiraUsersMappingInputType._({
        ..._instance._$data,
        if (gitlabId != _undefined) 'gitlabId': (gitlabId as int?),
        if (jiraAccountId != _undefined && jiraAccountId != null)
          'jiraAccountId': (jiraAccountId as String),
      }));
}

class _CopyWithStubImpl$Input$JiraUsersMappingInputType<TRes>
    implements CopyWith$Input$JiraUsersMappingInputType<TRes> {
  _CopyWithStubImpl$Input$JiraUsersMappingInputType(this._res);

  TRes _res;

  call({
    int? gitlabId,
    String? jiraAccountId,
  }) =>
      _res;
}

class Input$JobCancelInput {
  factory Input$JobCancelInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$JobCancelInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$JobCancelInput._(this._$data);

  factory Input$JobCancelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$JobCancelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$JobCancelInput<Input$JobCancelInput> get copyWith =>
      CopyWith$Input$JobCancelInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JobCancelInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$JobCancelInput<TRes> {
  factory CopyWith$Input$JobCancelInput(
    Input$JobCancelInput instance,
    TRes Function(Input$JobCancelInput) then,
  ) = _CopyWithImpl$Input$JobCancelInput;

  factory CopyWith$Input$JobCancelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$JobCancelInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$JobCancelInput<TRes>
    implements CopyWith$Input$JobCancelInput<TRes> {
  _CopyWithImpl$Input$JobCancelInput(
    this._instance,
    this._then,
  );

  final Input$JobCancelInput _instance;

  final TRes Function(Input$JobCancelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$JobCancelInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$JobCancelInput<TRes>
    implements CopyWith$Input$JobCancelInput<TRes> {
  _CopyWithStubImpl$Input$JobCancelInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$JobPlayInput {
  factory Input$JobPlayInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$JobPlayInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$JobPlayInput._(this._$data);

  factory Input$JobPlayInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$JobPlayInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$JobPlayInput<Input$JobPlayInput> get copyWith =>
      CopyWith$Input$JobPlayInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JobPlayInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$JobPlayInput<TRes> {
  factory CopyWith$Input$JobPlayInput(
    Input$JobPlayInput instance,
    TRes Function(Input$JobPlayInput) then,
  ) = _CopyWithImpl$Input$JobPlayInput;

  factory CopyWith$Input$JobPlayInput.stub(TRes res) =
      _CopyWithStubImpl$Input$JobPlayInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$JobPlayInput<TRes>
    implements CopyWith$Input$JobPlayInput<TRes> {
  _CopyWithImpl$Input$JobPlayInput(
    this._instance,
    this._then,
  );

  final Input$JobPlayInput _instance;

  final TRes Function(Input$JobPlayInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$JobPlayInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$JobPlayInput<TRes>
    implements CopyWith$Input$JobPlayInput<TRes> {
  _CopyWithStubImpl$Input$JobPlayInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$JobRetryInput {
  factory Input$JobRetryInput({
    required String id,
    String? clientMutationId,
    List<Input$CiVariableInput>? variables,
  }) =>
      Input$JobRetryInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (variables != null) r'variables': variables,
      });

  Input$JobRetryInput._(this._$data);

  factory Input$JobRetryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('variables')) {
      final l$variables = data['variables'];
      result$data['variables'] = (l$variables as List<dynamic>?)
          ?.map((e) =>
              Input$CiVariableInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$JobRetryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<Input$CiVariableInput>? get variables =>
      (_$data['variables'] as List<Input$CiVariableInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('variables')) {
      final l$variables = variables;
      result$data['variables'] = l$variables?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$JobRetryInput<Input$JobRetryInput> get copyWith =>
      CopyWith$Input$JobRetryInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JobRetryInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (_$data.containsKey('variables') !=
        other._$data.containsKey('variables')) {
      return false;
    }
    if (l$variables != null && lOther$variables != null) {
      if (l$variables.length != lOther$variables.length) {
        return false;
      }
      for (int i = 0; i < l$variables.length; i++) {
        final l$variables$entry = l$variables[i];
        final lOther$variables$entry = lOther$variables[i];
        if (l$variables$entry != lOther$variables$entry) {
          return false;
        }
      }
    } else if (l$variables != lOther$variables) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    final l$variables = variables;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('variables')
          ? l$variables == null
              ? null
              : Object.hashAll(l$variables.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$JobRetryInput<TRes> {
  factory CopyWith$Input$JobRetryInput(
    Input$JobRetryInput instance,
    TRes Function(Input$JobRetryInput) then,
  ) = _CopyWithImpl$Input$JobRetryInput;

  factory CopyWith$Input$JobRetryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$JobRetryInput;

  TRes call({
    String? id,
    String? clientMutationId,
    List<Input$CiVariableInput>? variables,
  });
  TRes variables(
      Iterable<Input$CiVariableInput>? Function(
              Iterable<CopyWith$Input$CiVariableInput<Input$CiVariableInput>>?)
          _fn);
}

class _CopyWithImpl$Input$JobRetryInput<TRes>
    implements CopyWith$Input$JobRetryInput<TRes> {
  _CopyWithImpl$Input$JobRetryInput(
    this._instance,
    this._then,
  );

  final Input$JobRetryInput _instance;

  final TRes Function(Input$JobRetryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
    Object? variables = _undefined,
  }) =>
      _then(Input$JobRetryInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (variables != _undefined)
          'variables': (variables as List<Input$CiVariableInput>?),
      }));
  TRes variables(
          Iterable<Input$CiVariableInput>? Function(
                  Iterable<
                      CopyWith$Input$CiVariableInput<Input$CiVariableInput>>?)
              _fn) =>
      call(
          variables: _fn(
              _instance.variables?.map((e) => CopyWith$Input$CiVariableInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$JobRetryInput<TRes>
    implements CopyWith$Input$JobRetryInput<TRes> {
  _CopyWithStubImpl$Input$JobRetryInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
    List<Input$CiVariableInput>? variables,
  }) =>
      _res;
  variables(_fn) => _res;
}

class Input$JobUnscheduleInput {
  factory Input$JobUnscheduleInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$JobUnscheduleInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$JobUnscheduleInput._(this._$data);

  factory Input$JobUnscheduleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$JobUnscheduleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$JobUnscheduleInput<Input$JobUnscheduleInput> get copyWith =>
      CopyWith$Input$JobUnscheduleInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JobUnscheduleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$JobUnscheduleInput<TRes> {
  factory CopyWith$Input$JobUnscheduleInput(
    Input$JobUnscheduleInput instance,
    TRes Function(Input$JobUnscheduleInput) then,
  ) = _CopyWithImpl$Input$JobUnscheduleInput;

  factory CopyWith$Input$JobUnscheduleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$JobUnscheduleInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$JobUnscheduleInput<TRes>
    implements CopyWith$Input$JobUnscheduleInput<TRes> {
  _CopyWithImpl$Input$JobUnscheduleInput(
    this._instance,
    this._then,
  );

  final Input$JobUnscheduleInput _instance;

  final TRes Function(Input$JobUnscheduleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$JobUnscheduleInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$JobUnscheduleInput<TRes>
    implements CopyWith$Input$JobUnscheduleInput<TRes> {
  _CopyWithStubImpl$Input$JobUnscheduleInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$LabelCreateInput {
  factory Input$LabelCreateInput({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    required String title,
    String? description,
    String? color,
  }) =>
      Input$LabelCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (projectPath != null) r'projectPath': projectPath,
        if (groupPath != null) r'groupPath': groupPath,
        r'title': title,
        if (description != null) r'description': description,
        if (color != null) r'color': color,
      });

  Input$LabelCreateInput._(this._$data);

  factory Input$LabelCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('projectPath')) {
      final l$projectPath = data['projectPath'];
      result$data['projectPath'] = (l$projectPath as String?);
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = (l$color as String?);
    }
    return Input$LabelCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get projectPath => (_$data['projectPath'] as String?);
  String? get groupPath => (_$data['groupPath'] as String?);
  String get title => (_$data['title'] as String);
  String? get description => (_$data['description'] as String?);
  String? get color => (_$data['color'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('projectPath')) {
      final l$projectPath = projectPath;
      result$data['projectPath'] = l$projectPath;
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color;
    }
    return result$data;
  }

  CopyWith$Input$LabelCreateInput<Input$LabelCreateInput> get copyWith =>
      CopyWith$Input$LabelCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LabelCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (_$data.containsKey('projectPath') !=
        other._$data.containsKey('projectPath')) {
      return false;
    }
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$groupPath = groupPath;
    final l$title = title;
    final l$description = description;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('projectPath') ? l$projectPath : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
      l$title,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$LabelCreateInput<TRes> {
  factory CopyWith$Input$LabelCreateInput(
    Input$LabelCreateInput instance,
    TRes Function(Input$LabelCreateInput) then,
  ) = _CopyWithImpl$Input$LabelCreateInput;

  factory CopyWith$Input$LabelCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LabelCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? title,
    String? description,
    String? color,
  });
}

class _CopyWithImpl$Input$LabelCreateInput<TRes>
    implements CopyWith$Input$LabelCreateInput<TRes> {
  _CopyWithImpl$Input$LabelCreateInput(
    this._instance,
    this._then,
  );

  final Input$LabelCreateInput _instance;

  final TRes Function(Input$LabelCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? groupPath = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$LabelCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined) 'projectPath': (projectPath as String?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (description != _undefined) 'description': (description as String?),
        if (color != _undefined) 'color': (color as String?),
      }));
}

class _CopyWithStubImpl$Input$LabelCreateInput<TRes>
    implements CopyWith$Input$LabelCreateInput<TRes> {
  _CopyWithStubImpl$Input$LabelCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? title,
    String? description,
    String? color,
  }) =>
      _res;
}

class Input$MarkAsSpamSnippetInput {
  factory Input$MarkAsSpamSnippetInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$MarkAsSpamSnippetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$MarkAsSpamSnippetInput._(this._$data);

  factory Input$MarkAsSpamSnippetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$MarkAsSpamSnippetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$MarkAsSpamSnippetInput<Input$MarkAsSpamSnippetInput>
      get copyWith => CopyWith$Input$MarkAsSpamSnippetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkAsSpamSnippetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$MarkAsSpamSnippetInput<TRes> {
  factory CopyWith$Input$MarkAsSpamSnippetInput(
    Input$MarkAsSpamSnippetInput instance,
    TRes Function(Input$MarkAsSpamSnippetInput) then,
  ) = _CopyWithImpl$Input$MarkAsSpamSnippetInput;

  factory CopyWith$Input$MarkAsSpamSnippetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkAsSpamSnippetInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$MarkAsSpamSnippetInput<TRes>
    implements CopyWith$Input$MarkAsSpamSnippetInput<TRes> {
  _CopyWithImpl$Input$MarkAsSpamSnippetInput(
    this._instance,
    this._then,
  );

  final Input$MarkAsSpamSnippetInput _instance;

  final TRes Function(Input$MarkAsSpamSnippetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$MarkAsSpamSnippetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$MarkAsSpamSnippetInput<TRes>
    implements CopyWith$Input$MarkAsSpamSnippetInput<TRes> {
  _CopyWithStubImpl$Input$MarkAsSpamSnippetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$MergeRequestAcceptInput {
  factory Input$MergeRequestAcceptInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    Enum$MergeStrategyEnum? strategy,
    String? commitMessage,
    required String sha,
    String? squashCommitMessage,
    bool? shouldRemoveSourceBranch,
    bool? squash,
  }) =>
      Input$MergeRequestAcceptInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (strategy != null) r'strategy': strategy,
        if (commitMessage != null) r'commitMessage': commitMessage,
        r'sha': sha,
        if (squashCommitMessage != null)
          r'squashCommitMessage': squashCommitMessage,
        if (shouldRemoveSourceBranch != null)
          r'shouldRemoveSourceBranch': shouldRemoveSourceBranch,
        if (squash != null) r'squash': squash,
      });

  Input$MergeRequestAcceptInput._(this._$data);

  factory Input$MergeRequestAcceptInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('strategy')) {
      final l$strategy = data['strategy'];
      result$data['strategy'] = l$strategy == null
          ? null
          : fromJson$Enum$MergeStrategyEnum((l$strategy as String));
    }
    if (data.containsKey('commitMessage')) {
      final l$commitMessage = data['commitMessage'];
      result$data['commitMessage'] = (l$commitMessage as String?);
    }
    final l$sha = data['sha'];
    result$data['sha'] = (l$sha as String);
    if (data.containsKey('squashCommitMessage')) {
      final l$squashCommitMessage = data['squashCommitMessage'];
      result$data['squashCommitMessage'] = (l$squashCommitMessage as String?);
    }
    if (data.containsKey('shouldRemoveSourceBranch')) {
      final l$shouldRemoveSourceBranch = data['shouldRemoveSourceBranch'];
      result$data['shouldRemoveSourceBranch'] =
          (l$shouldRemoveSourceBranch as bool?);
    }
    if (data.containsKey('squash')) {
      final l$squash = data['squash'];
      result$data['squash'] = (l$squash as bool?);
    }
    return Input$MergeRequestAcceptInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$MergeStrategyEnum? get strategy =>
      (_$data['strategy'] as Enum$MergeStrategyEnum?);
  String? get commitMessage => (_$data['commitMessage'] as String?);
  String get sha => (_$data['sha'] as String);
  String? get squashCommitMessage => (_$data['squashCommitMessage'] as String?);
  bool? get shouldRemoveSourceBranch =>
      (_$data['shouldRemoveSourceBranch'] as bool?);
  bool? get squash => (_$data['squash'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('strategy')) {
      final l$strategy = strategy;
      result$data['strategy'] =
          l$strategy == null ? null : toJson$Enum$MergeStrategyEnum(l$strategy);
    }
    if (_$data.containsKey('commitMessage')) {
      final l$commitMessage = commitMessage;
      result$data['commitMessage'] = l$commitMessage;
    }
    final l$sha = sha;
    result$data['sha'] = l$sha;
    if (_$data.containsKey('squashCommitMessage')) {
      final l$squashCommitMessage = squashCommitMessage;
      result$data['squashCommitMessage'] = l$squashCommitMessage;
    }
    if (_$data.containsKey('shouldRemoveSourceBranch')) {
      final l$shouldRemoveSourceBranch = shouldRemoveSourceBranch;
      result$data['shouldRemoveSourceBranch'] = l$shouldRemoveSourceBranch;
    }
    if (_$data.containsKey('squash')) {
      final l$squash = squash;
      result$data['squash'] = l$squash;
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestAcceptInput<Input$MergeRequestAcceptInput>
      get copyWith => CopyWith$Input$MergeRequestAcceptInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestAcceptInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$strategy = strategy;
    final lOther$strategy = other.strategy;
    if (_$data.containsKey('strategy') !=
        other._$data.containsKey('strategy')) {
      return false;
    }
    if (l$strategy != lOther$strategy) {
      return false;
    }
    final l$commitMessage = commitMessage;
    final lOther$commitMessage = other.commitMessage;
    if (_$data.containsKey('commitMessage') !=
        other._$data.containsKey('commitMessage')) {
      return false;
    }
    if (l$commitMessage != lOther$commitMessage) {
      return false;
    }
    final l$sha = sha;
    final lOther$sha = other.sha;
    if (l$sha != lOther$sha) {
      return false;
    }
    final l$squashCommitMessage = squashCommitMessage;
    final lOther$squashCommitMessage = other.squashCommitMessage;
    if (_$data.containsKey('squashCommitMessage') !=
        other._$data.containsKey('squashCommitMessage')) {
      return false;
    }
    if (l$squashCommitMessage != lOther$squashCommitMessage) {
      return false;
    }
    final l$shouldRemoveSourceBranch = shouldRemoveSourceBranch;
    final lOther$shouldRemoveSourceBranch = other.shouldRemoveSourceBranch;
    if (_$data.containsKey('shouldRemoveSourceBranch') !=
        other._$data.containsKey('shouldRemoveSourceBranch')) {
      return false;
    }
    if (l$shouldRemoveSourceBranch != lOther$shouldRemoveSourceBranch) {
      return false;
    }
    final l$squash = squash;
    final lOther$squash = other.squash;
    if (_$data.containsKey('squash') != other._$data.containsKey('squash')) {
      return false;
    }
    if (l$squash != lOther$squash) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$strategy = strategy;
    final l$commitMessage = commitMessage;
    final l$sha = sha;
    final l$squashCommitMessage = squashCommitMessage;
    final l$shouldRemoveSourceBranch = shouldRemoveSourceBranch;
    final l$squash = squash;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('strategy') ? l$strategy : const {},
      _$data.containsKey('commitMessage') ? l$commitMessage : const {},
      l$sha,
      _$data.containsKey('squashCommitMessage')
          ? l$squashCommitMessage
          : const {},
      _$data.containsKey('shouldRemoveSourceBranch')
          ? l$shouldRemoveSourceBranch
          : const {},
      _$data.containsKey('squash') ? l$squash : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestAcceptInput<TRes> {
  factory CopyWith$Input$MergeRequestAcceptInput(
    Input$MergeRequestAcceptInput instance,
    TRes Function(Input$MergeRequestAcceptInput) then,
  ) = _CopyWithImpl$Input$MergeRequestAcceptInput;

  factory CopyWith$Input$MergeRequestAcceptInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestAcceptInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$MergeStrategyEnum? strategy,
    String? commitMessage,
    String? sha,
    String? squashCommitMessage,
    bool? shouldRemoveSourceBranch,
    bool? squash,
  });
}

class _CopyWithImpl$Input$MergeRequestAcceptInput<TRes>
    implements CopyWith$Input$MergeRequestAcceptInput<TRes> {
  _CopyWithImpl$Input$MergeRequestAcceptInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestAcceptInput _instance;

  final TRes Function(Input$MergeRequestAcceptInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? strategy = _undefined,
    Object? commitMessage = _undefined,
    Object? sha = _undefined,
    Object? squashCommitMessage = _undefined,
    Object? shouldRemoveSourceBranch = _undefined,
    Object? squash = _undefined,
  }) =>
      _then(Input$MergeRequestAcceptInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (strategy != _undefined)
          'strategy': (strategy as Enum$MergeStrategyEnum?),
        if (commitMessage != _undefined)
          'commitMessage': (commitMessage as String?),
        if (sha != _undefined && sha != null) 'sha': (sha as String),
        if (squashCommitMessage != _undefined)
          'squashCommitMessage': (squashCommitMessage as String?),
        if (shouldRemoveSourceBranch != _undefined)
          'shouldRemoveSourceBranch': (shouldRemoveSourceBranch as bool?),
        if (squash != _undefined) 'squash': (squash as bool?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestAcceptInput<TRes>
    implements CopyWith$Input$MergeRequestAcceptInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestAcceptInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$MergeStrategyEnum? strategy,
    String? commitMessage,
    String? sha,
    String? squashCommitMessage,
    bool? shouldRemoveSourceBranch,
    bool? squash,
  }) =>
      _res;
}

class Input$MergeRequestCreateInput {
  factory Input$MergeRequestCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String title,
    required String sourceBranch,
    required String targetBranch,
    String? description,
    List<String>? labels,
  }) =>
      Input$MergeRequestCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'title': title,
        r'sourceBranch': sourceBranch,
        r'targetBranch': targetBranch,
        if (description != null) r'description': description,
        if (labels != null) r'labels': labels,
      });

  Input$MergeRequestCreateInput._(this._$data);

  factory Input$MergeRequestCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$sourceBranch = data['sourceBranch'];
    result$data['sourceBranch'] = (l$sourceBranch as String);
    final l$targetBranch = data['targetBranch'];
    result$data['targetBranch'] = (l$targetBranch as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$MergeRequestCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get title => (_$data['title'] as String);
  String get sourceBranch => (_$data['sourceBranch'] as String);
  String get targetBranch => (_$data['targetBranch'] as String);
  String? get description => (_$data['description'] as String?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$title = title;
    result$data['title'] = l$title;
    final l$sourceBranch = sourceBranch;
    result$data['sourceBranch'] = l$sourceBranch;
    final l$targetBranch = targetBranch;
    result$data['targetBranch'] = l$targetBranch;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestCreateInput<Input$MergeRequestCreateInput>
      get copyWith => CopyWith$Input$MergeRequestCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$sourceBranch = sourceBranch;
    final lOther$sourceBranch = other.sourceBranch;
    if (l$sourceBranch != lOther$sourceBranch) {
      return false;
    }
    final l$targetBranch = targetBranch;
    final lOther$targetBranch = other.targetBranch;
    if (l$targetBranch != lOther$targetBranch) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$title = title;
    final l$sourceBranch = sourceBranch;
    final l$targetBranch = targetBranch;
    final l$description = description;
    final l$labels = labels;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$title,
      l$sourceBranch,
      l$targetBranch,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestCreateInput<TRes> {
  factory CopyWith$Input$MergeRequestCreateInput(
    Input$MergeRequestCreateInput instance,
    TRes Function(Input$MergeRequestCreateInput) then,
  ) = _CopyWithImpl$Input$MergeRequestCreateInput;

  factory CopyWith$Input$MergeRequestCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? title,
    String? sourceBranch,
    String? targetBranch,
    String? description,
    List<String>? labels,
  });
}

class _CopyWithImpl$Input$MergeRequestCreateInput<TRes>
    implements CopyWith$Input$MergeRequestCreateInput<TRes> {
  _CopyWithImpl$Input$MergeRequestCreateInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestCreateInput _instance;

  final TRes Function(Input$MergeRequestCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? title = _undefined,
    Object? sourceBranch = _undefined,
    Object? targetBranch = _undefined,
    Object? description = _undefined,
    Object? labels = _undefined,
  }) =>
      _then(Input$MergeRequestCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (sourceBranch != _undefined && sourceBranch != null)
          'sourceBranch': (sourceBranch as String),
        if (targetBranch != _undefined && targetBranch != null)
          'targetBranch': (targetBranch as String),
        if (description != _undefined) 'description': (description as String?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestCreateInput<TRes>
    implements CopyWith$Input$MergeRequestCreateInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? title,
    String? sourceBranch,
    String? targetBranch,
    String? description,
    List<String>? labels,
  }) =>
      _res;
}

class Input$MergeRequestReviewerRereviewInput {
  factory Input$MergeRequestReviewerRereviewInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required String userId,
  }) =>
      Input$MergeRequestReviewerRereviewInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
      });

  Input$MergeRequestReviewerRereviewInput._(this._$data);

  factory Input$MergeRequestReviewerRereviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$MergeRequestReviewerRereviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get userId => (_$data['userId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$MergeRequestReviewerRereviewInput<
          Input$MergeRequestReviewerRereviewInput>
      get copyWith => CopyWith$Input$MergeRequestReviewerRereviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestReviewerRereviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestReviewerRereviewInput<TRes> {
  factory CopyWith$Input$MergeRequestReviewerRereviewInput(
    Input$MergeRequestReviewerRereviewInput instance,
    TRes Function(Input$MergeRequestReviewerRereviewInput) then,
  ) = _CopyWithImpl$Input$MergeRequestReviewerRereviewInput;

  factory CopyWith$Input$MergeRequestReviewerRereviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestReviewerRereviewInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$MergeRequestReviewerRereviewInput<TRes>
    implements CopyWith$Input$MergeRequestReviewerRereviewInput<TRes> {
  _CopyWithImpl$Input$MergeRequestReviewerRereviewInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestReviewerRereviewInput _instance;

  final TRes Function(Input$MergeRequestReviewerRereviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$MergeRequestReviewerRereviewInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestReviewerRereviewInput<TRes>
    implements CopyWith$Input$MergeRequestReviewerRereviewInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestReviewerRereviewInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? userId,
  }) =>
      _res;
}

class Input$MergeRequestSetAssigneesInput {
  factory Input$MergeRequestSetAssigneesInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      Input$MergeRequestSetAssigneesInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'assigneeUsernames': assigneeUsernames,
        if (operationMode != null) r'operationMode': operationMode,
      });

  Input$MergeRequestSetAssigneesInput._(this._$data);

  factory Input$MergeRequestSetAssigneesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$assigneeUsernames = data['assigneeUsernames'];
    result$data['assigneeUsernames'] = (l$assigneeUsernames as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    if (data.containsKey('operationMode')) {
      final l$operationMode = data['operationMode'];
      result$data['operationMode'] = l$operationMode == null
          ? null
          : fromJson$Enum$MutationOperationMode((l$operationMode as String));
    }
    return Input$MergeRequestSetAssigneesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get assigneeUsernames =>
      (_$data['assigneeUsernames'] as List<String>);
  Enum$MutationOperationMode? get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$assigneeUsernames = assigneeUsernames;
    result$data['assigneeUsernames'] =
        l$assigneeUsernames.map((e) => e).toList();
    if (_$data.containsKey('operationMode')) {
      final l$operationMode = operationMode;
      result$data['operationMode'] = l$operationMode == null
          ? null
          : toJson$Enum$MutationOperationMode(l$operationMode);
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestSetAssigneesInput<
          Input$MergeRequestSetAssigneesInput>
      get copyWith => CopyWith$Input$MergeRequestSetAssigneesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetAssigneesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$assigneeUsernames = assigneeUsernames;
    final lOther$assigneeUsernames = other.assigneeUsernames;
    if (l$assigneeUsernames.length != lOther$assigneeUsernames.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeUsernames.length; i++) {
      final l$assigneeUsernames$entry = l$assigneeUsernames[i];
      final lOther$assigneeUsernames$entry = lOther$assigneeUsernames[i];
      if (l$assigneeUsernames$entry != lOther$assigneeUsernames$entry) {
        return false;
      }
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (_$data.containsKey('operationMode') !=
        other._$data.containsKey('operationMode')) {
      return false;
    }
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$assigneeUsernames = assigneeUsernames;
    final l$operationMode = operationMode;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$assigneeUsernames.map((v) => v)),
      _$data.containsKey('operationMode') ? l$operationMode : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetAssigneesInput<TRes> {
  factory CopyWith$Input$MergeRequestSetAssigneesInput(
    Input$MergeRequestSetAssigneesInput instance,
    TRes Function(Input$MergeRequestSetAssigneesInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetAssigneesInput;

  factory CopyWith$Input$MergeRequestSetAssigneesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetAssigneesInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  });
}

class _CopyWithImpl$Input$MergeRequestSetAssigneesInput<TRes>
    implements CopyWith$Input$MergeRequestSetAssigneesInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetAssigneesInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetAssigneesInput _instance;

  final TRes Function(Input$MergeRequestSetAssigneesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? assigneeUsernames = _undefined,
    Object? operationMode = _undefined,
  }) =>
      _then(Input$MergeRequestSetAssigneesInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (assigneeUsernames != _undefined && assigneeUsernames != null)
          'assigneeUsernames': (assigneeUsernames as List<String>),
        if (operationMode != _undefined)
          'operationMode': (operationMode as Enum$MutationOperationMode?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetAssigneesInput<TRes>
    implements CopyWith$Input$MergeRequestSetAssigneesInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetAssigneesInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? assigneeUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      _res;
}

class Input$MergeRequestSetDraftInput {
  factory Input$MergeRequestSetDraftInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required bool draft,
  }) =>
      Input$MergeRequestSetDraftInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'draft': draft,
      });

  Input$MergeRequestSetDraftInput._(this._$data);

  factory Input$MergeRequestSetDraftInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$draft = data['draft'];
    result$data['draft'] = (l$draft as bool);
    return Input$MergeRequestSetDraftInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get draft => (_$data['draft'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$draft = draft;
    result$data['draft'] = l$draft;
    return result$data;
  }

  CopyWith$Input$MergeRequestSetDraftInput<Input$MergeRequestSetDraftInput>
      get copyWith => CopyWith$Input$MergeRequestSetDraftInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetDraftInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$draft = draft;
    final lOther$draft = other.draft;
    if (l$draft != lOther$draft) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$draft = draft;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$draft,
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetDraftInput<TRes> {
  factory CopyWith$Input$MergeRequestSetDraftInput(
    Input$MergeRequestSetDraftInput instance,
    TRes Function(Input$MergeRequestSetDraftInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetDraftInput;

  factory CopyWith$Input$MergeRequestSetDraftInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetDraftInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? draft,
  });
}

class _CopyWithImpl$Input$MergeRequestSetDraftInput<TRes>
    implements CopyWith$Input$MergeRequestSetDraftInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetDraftInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetDraftInput _instance;

  final TRes Function(Input$MergeRequestSetDraftInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? draft = _undefined,
  }) =>
      _then(Input$MergeRequestSetDraftInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (draft != _undefined && draft != null) 'draft': (draft as bool),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetDraftInput<TRes>
    implements CopyWith$Input$MergeRequestSetDraftInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetDraftInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? draft,
  }) =>
      _res;
}

class Input$MergeRequestSetLabelsInput {
  factory Input$MergeRequestSetLabelsInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> labelIds,
    Enum$MutationOperationMode? operationMode,
  }) =>
      Input$MergeRequestSetLabelsInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelIds': labelIds,
        if (operationMode != null) r'operationMode': operationMode,
      });

  Input$MergeRequestSetLabelsInput._(this._$data);

  factory Input$MergeRequestSetLabelsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('operationMode')) {
      final l$operationMode = data['operationMode'];
      result$data['operationMode'] = l$operationMode == null
          ? null
          : fromJson$Enum$MutationOperationMode((l$operationMode as String));
    }
    return Input$MergeRequestSetLabelsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get labelIds => (_$data['labelIds'] as List<String>);
  Enum$MutationOperationMode? get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    if (_$data.containsKey('operationMode')) {
      final l$operationMode = operationMode;
      result$data['operationMode'] = l$operationMode == null
          ? null
          : toJson$Enum$MutationOperationMode(l$operationMode);
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestSetLabelsInput<Input$MergeRequestSetLabelsInput>
      get copyWith => CopyWith$Input$MergeRequestSetLabelsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetLabelsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (_$data.containsKey('operationMode') !=
        other._$data.containsKey('operationMode')) {
      return false;
    }
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$labelIds = labelIds;
    final l$operationMode = operationMode;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$labelIds.map((v) => v)),
      _$data.containsKey('operationMode') ? l$operationMode : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetLabelsInput<TRes> {
  factory CopyWith$Input$MergeRequestSetLabelsInput(
    Input$MergeRequestSetLabelsInput instance,
    TRes Function(Input$MergeRequestSetLabelsInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetLabelsInput;

  factory CopyWith$Input$MergeRequestSetLabelsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetLabelsInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? labelIds,
    Enum$MutationOperationMode? operationMode,
  });
}

class _CopyWithImpl$Input$MergeRequestSetLabelsInput<TRes>
    implements CopyWith$Input$MergeRequestSetLabelsInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetLabelsInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetLabelsInput _instance;

  final TRes Function(Input$MergeRequestSetLabelsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? labelIds = _undefined,
    Object? operationMode = _undefined,
  }) =>
      _then(Input$MergeRequestSetLabelsInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
        if (operationMode != _undefined)
          'operationMode': (operationMode as Enum$MutationOperationMode?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetLabelsInput<TRes>
    implements CopyWith$Input$MergeRequestSetLabelsInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetLabelsInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? labelIds,
    Enum$MutationOperationMode? operationMode,
  }) =>
      _res;
}

class Input$MergeRequestSetLockedInput {
  factory Input$MergeRequestSetLockedInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required bool locked,
  }) =>
      Input$MergeRequestSetLockedInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'locked': locked,
      });

  Input$MergeRequestSetLockedInput._(this._$data);

  factory Input$MergeRequestSetLockedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$locked = data['locked'];
    result$data['locked'] = (l$locked as bool);
    return Input$MergeRequestSetLockedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get locked => (_$data['locked'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$locked = locked;
    result$data['locked'] = l$locked;
    return result$data;
  }

  CopyWith$Input$MergeRequestSetLockedInput<Input$MergeRequestSetLockedInput>
      get copyWith => CopyWith$Input$MergeRequestSetLockedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetLockedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$locked = locked;
    final lOther$locked = other.locked;
    if (l$locked != lOther$locked) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$locked = locked;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$locked,
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetLockedInput<TRes> {
  factory CopyWith$Input$MergeRequestSetLockedInput(
    Input$MergeRequestSetLockedInput instance,
    TRes Function(Input$MergeRequestSetLockedInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetLockedInput;

  factory CopyWith$Input$MergeRequestSetLockedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetLockedInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? locked,
  });
}

class _CopyWithImpl$Input$MergeRequestSetLockedInput<TRes>
    implements CopyWith$Input$MergeRequestSetLockedInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetLockedInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetLockedInput _instance;

  final TRes Function(Input$MergeRequestSetLockedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? locked = _undefined,
  }) =>
      _then(Input$MergeRequestSetLockedInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (locked != _undefined && locked != null) 'locked': (locked as bool),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetLockedInput<TRes>
    implements CopyWith$Input$MergeRequestSetLockedInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetLockedInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    bool? locked,
  }) =>
      _res;
}

class Input$MergeRequestSetMilestoneInput {
  factory Input$MergeRequestSetMilestoneInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? milestoneId,
  }) =>
      Input$MergeRequestSetMilestoneInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (milestoneId != null) r'milestoneId': milestoneId,
      });

  Input$MergeRequestSetMilestoneInput._(this._$data);

  factory Input$MergeRequestSetMilestoneInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    return Input$MergeRequestSetMilestoneInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestSetMilestoneInput<
          Input$MergeRequestSetMilestoneInput>
      get copyWith => CopyWith$Input$MergeRequestSetMilestoneInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetMilestoneInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$milestoneId = milestoneId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetMilestoneInput<TRes> {
  factory CopyWith$Input$MergeRequestSetMilestoneInput(
    Input$MergeRequestSetMilestoneInput instance,
    TRes Function(Input$MergeRequestSetMilestoneInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetMilestoneInput;

  factory CopyWith$Input$MergeRequestSetMilestoneInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetMilestoneInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? milestoneId,
  });
}

class _CopyWithImpl$Input$MergeRequestSetMilestoneInput<TRes>
    implements CopyWith$Input$MergeRequestSetMilestoneInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetMilestoneInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetMilestoneInput _instance;

  final TRes Function(Input$MergeRequestSetMilestoneInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? milestoneId = _undefined,
  }) =>
      _then(Input$MergeRequestSetMilestoneInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetMilestoneInput<TRes>
    implements CopyWith$Input$MergeRequestSetMilestoneInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetMilestoneInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? milestoneId,
  }) =>
      _res;
}

class Input$MergeRequestSetReviewersInput {
  factory Input$MergeRequestSetReviewersInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required List<String> reviewerUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      Input$MergeRequestSetReviewersInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'reviewerUsernames': reviewerUsernames,
        if (operationMode != null) r'operationMode': operationMode,
      });

  Input$MergeRequestSetReviewersInput._(this._$data);

  factory Input$MergeRequestSetReviewersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$reviewerUsernames = data['reviewerUsernames'];
    result$data['reviewerUsernames'] = (l$reviewerUsernames as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    if (data.containsKey('operationMode')) {
      final l$operationMode = data['operationMode'];
      result$data['operationMode'] = l$operationMode == null
          ? null
          : fromJson$Enum$MutationOperationMode((l$operationMode as String));
    }
    return Input$MergeRequestSetReviewersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get reviewerUsernames =>
      (_$data['reviewerUsernames'] as List<String>);
  Enum$MutationOperationMode? get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$reviewerUsernames = reviewerUsernames;
    result$data['reviewerUsernames'] =
        l$reviewerUsernames.map((e) => e).toList();
    if (_$data.containsKey('operationMode')) {
      final l$operationMode = operationMode;
      result$data['operationMode'] = l$operationMode == null
          ? null
          : toJson$Enum$MutationOperationMode(l$operationMode);
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestSetReviewersInput<
          Input$MergeRequestSetReviewersInput>
      get copyWith => CopyWith$Input$MergeRequestSetReviewersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetReviewersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$reviewerUsernames = reviewerUsernames;
    final lOther$reviewerUsernames = other.reviewerUsernames;
    if (l$reviewerUsernames.length != lOther$reviewerUsernames.length) {
      return false;
    }
    for (int i = 0; i < l$reviewerUsernames.length; i++) {
      final l$reviewerUsernames$entry = l$reviewerUsernames[i];
      final lOther$reviewerUsernames$entry = lOther$reviewerUsernames[i];
      if (l$reviewerUsernames$entry != lOther$reviewerUsernames$entry) {
        return false;
      }
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (_$data.containsKey('operationMode') !=
        other._$data.containsKey('operationMode')) {
      return false;
    }
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$reviewerUsernames = reviewerUsernames;
    final l$operationMode = operationMode;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$reviewerUsernames.map((v) => v)),
      _$data.containsKey('operationMode') ? l$operationMode : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetReviewersInput<TRes> {
  factory CopyWith$Input$MergeRequestSetReviewersInput(
    Input$MergeRequestSetReviewersInput instance,
    TRes Function(Input$MergeRequestSetReviewersInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetReviewersInput;

  factory CopyWith$Input$MergeRequestSetReviewersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetReviewersInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? reviewerUsernames,
    Enum$MutationOperationMode? operationMode,
  });
}

class _CopyWithImpl$Input$MergeRequestSetReviewersInput<TRes>
    implements CopyWith$Input$MergeRequestSetReviewersInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetReviewersInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetReviewersInput _instance;

  final TRes Function(Input$MergeRequestSetReviewersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? reviewerUsernames = _undefined,
    Object? operationMode = _undefined,
  }) =>
      _then(Input$MergeRequestSetReviewersInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (reviewerUsernames != _undefined && reviewerUsernames != null)
          'reviewerUsernames': (reviewerUsernames as List<String>),
        if (operationMode != _undefined)
          'operationMode': (operationMode as Enum$MutationOperationMode?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetReviewersInput<TRes>
    implements CopyWith$Input$MergeRequestSetReviewersInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetReviewersInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    List<String>? reviewerUsernames,
    Enum$MutationOperationMode? operationMode,
  }) =>
      _res;
}

class Input$MergeRequestSetSubscriptionInput {
  factory Input$MergeRequestSetSubscriptionInput({
    String? clientMutationId,
    required bool subscribedState,
    required String projectPath,
    required String iid,
  }) =>
      Input$MergeRequestSetSubscriptionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subscribedState': subscribedState,
        r'projectPath': projectPath,
        r'iid': iid,
      });

  Input$MergeRequestSetSubscriptionInput._(this._$data);

  factory Input$MergeRequestSetSubscriptionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subscribedState = data['subscribedState'];
    result$data['subscribedState'] = (l$subscribedState as bool);
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    return Input$MergeRequestSetSubscriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get subscribedState => (_$data['subscribedState'] as bool);
  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subscribedState = subscribedState;
    result$data['subscribedState'] = l$subscribedState;
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    return result$data;
  }

  CopyWith$Input$MergeRequestSetSubscriptionInput<
          Input$MergeRequestSetSubscriptionInput>
      get copyWith => CopyWith$Input$MergeRequestSetSubscriptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestSetSubscriptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subscribedState = subscribedState;
    final lOther$subscribedState = other.subscribedState;
    if (l$subscribedState != lOther$subscribedState) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subscribedState = subscribedState;
    final l$projectPath = projectPath;
    final l$iid = iid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subscribedState,
      l$projectPath,
      l$iid,
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestSetSubscriptionInput<TRes> {
  factory CopyWith$Input$MergeRequestSetSubscriptionInput(
    Input$MergeRequestSetSubscriptionInput instance,
    TRes Function(Input$MergeRequestSetSubscriptionInput) then,
  ) = _CopyWithImpl$Input$MergeRequestSetSubscriptionInput;

  factory CopyWith$Input$MergeRequestSetSubscriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestSetSubscriptionInput;

  TRes call({
    String? clientMutationId,
    bool? subscribedState,
    String? projectPath,
    String? iid,
  });
}

class _CopyWithImpl$Input$MergeRequestSetSubscriptionInput<TRes>
    implements CopyWith$Input$MergeRequestSetSubscriptionInput<TRes> {
  _CopyWithImpl$Input$MergeRequestSetSubscriptionInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestSetSubscriptionInput _instance;

  final TRes Function(Input$MergeRequestSetSubscriptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subscribedState = _undefined,
    Object? projectPath = _undefined,
    Object? iid = _undefined,
  }) =>
      _then(Input$MergeRequestSetSubscriptionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subscribedState != _undefined && subscribedState != null)
          'subscribedState': (subscribedState as bool),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestSetSubscriptionInput<TRes>
    implements CopyWith$Input$MergeRequestSetSubscriptionInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestSetSubscriptionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? subscribedState,
    String? projectPath,
    String? iid,
  }) =>
      _res;
}

class Input$MergeRequestUpdateInput {
  factory Input$MergeRequestUpdateInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? title,
    String? targetBranch,
    String? description,
    Enum$MergeRequestNewState? state,
  }) =>
      Input$MergeRequestUpdateInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (title != null) r'title': title,
        if (targetBranch != null) r'targetBranch': targetBranch,
        if (description != null) r'description': description,
        if (state != null) r'state': state,
      });

  Input$MergeRequestUpdateInput._(this._$data);

  factory Input$MergeRequestUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('targetBranch')) {
      final l$targetBranch = data['targetBranch'];
      result$data['targetBranch'] = (l$targetBranch as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$MergeRequestNewState((l$state as String));
    }
    return Input$MergeRequestUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get title => (_$data['title'] as String?);
  String? get targetBranch => (_$data['targetBranch'] as String?);
  String? get description => (_$data['description'] as String?);
  Enum$MergeRequestNewState? get state =>
      (_$data['state'] as Enum$MergeRequestNewState?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('targetBranch')) {
      final l$targetBranch = targetBranch;
      result$data['targetBranch'] = l$targetBranch;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$MergeRequestNewState(l$state);
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestUpdateInput<Input$MergeRequestUpdateInput>
      get copyWith => CopyWith$Input$MergeRequestUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$targetBranch = targetBranch;
    final lOther$targetBranch = other.targetBranch;
    if (_$data.containsKey('targetBranch') !=
        other._$data.containsKey('targetBranch')) {
      return false;
    }
    if (l$targetBranch != lOther$targetBranch) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$title = title;
    final l$targetBranch = targetBranch;
    final l$description = description;
    final l$state = state;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('targetBranch') ? l$targetBranch : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('state') ? l$state : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestUpdateInput<TRes> {
  factory CopyWith$Input$MergeRequestUpdateInput(
    Input$MergeRequestUpdateInput instance,
    TRes Function(Input$MergeRequestUpdateInput) then,
  ) = _CopyWithImpl$Input$MergeRequestUpdateInput;

  factory CopyWith$Input$MergeRequestUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestUpdateInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? title,
    String? targetBranch,
    String? description,
    Enum$MergeRequestNewState? state,
  });
}

class _CopyWithImpl$Input$MergeRequestUpdateInput<TRes>
    implements CopyWith$Input$MergeRequestUpdateInput<TRes> {
  _CopyWithImpl$Input$MergeRequestUpdateInput(
    this._instance,
    this._then,
  );

  final Input$MergeRequestUpdateInput _instance;

  final TRes Function(Input$MergeRequestUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? title = _undefined,
    Object? targetBranch = _undefined,
    Object? description = _undefined,
    Object? state = _undefined,
  }) =>
      _then(Input$MergeRequestUpdateInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (targetBranch != _undefined)
          'targetBranch': (targetBranch as String?),
        if (description != _undefined) 'description': (description as String?),
        if (state != _undefined) 'state': (state as Enum$MergeRequestNewState?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestUpdateInput<TRes>
    implements CopyWith$Input$MergeRequestUpdateInput<TRes> {
  _CopyWithStubImpl$Input$MergeRequestUpdateInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? title,
    String? targetBranch,
    String? description,
    Enum$MergeRequestNewState? state,
  }) =>
      _res;
}

class Input$MergeRequestsResolverNegatedParams {
  factory Input$MergeRequestsResolverNegatedParams({
    List<String>? labels,
    String? milestoneTitle,
  }) =>
      Input$MergeRequestsResolverNegatedParams._({
        if (labels != null) r'labels': labels,
        if (milestoneTitle != null) r'milestoneTitle': milestoneTitle,
      });

  Input$MergeRequestsResolverNegatedParams._(this._$data);

  factory Input$MergeRequestsResolverNegatedParams.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = data['milestoneTitle'];
      result$data['milestoneTitle'] = (l$milestoneTitle as String?);
    }
    return Input$MergeRequestsResolverNegatedParams._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get labels => (_$data['labels'] as List<String>?);
  String? get milestoneTitle => (_$data['milestoneTitle'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = milestoneTitle;
      result$data['milestoneTitle'] = l$milestoneTitle;
    }
    return result$data;
  }

  CopyWith$Input$MergeRequestsResolverNegatedParams<
          Input$MergeRequestsResolverNegatedParams>
      get copyWith => CopyWith$Input$MergeRequestsResolverNegatedParams(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeRequestsResolverNegatedParams) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$milestoneTitle = milestoneTitle;
    final lOther$milestoneTitle = other.milestoneTitle;
    if (_$data.containsKey('milestoneTitle') !=
        other._$data.containsKey('milestoneTitle')) {
      return false;
    }
    if (l$milestoneTitle != lOther$milestoneTitle) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labels = labels;
    final l$milestoneTitle = milestoneTitle;
    return Object.hashAll([
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('milestoneTitle') ? l$milestoneTitle : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeRequestsResolverNegatedParams<TRes> {
  factory CopyWith$Input$MergeRequestsResolverNegatedParams(
    Input$MergeRequestsResolverNegatedParams instance,
    TRes Function(Input$MergeRequestsResolverNegatedParams) then,
  ) = _CopyWithImpl$Input$MergeRequestsResolverNegatedParams;

  factory CopyWith$Input$MergeRequestsResolverNegatedParams.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeRequestsResolverNegatedParams;

  TRes call({
    List<String>? labels,
    String? milestoneTitle,
  });
}

class _CopyWithImpl$Input$MergeRequestsResolverNegatedParams<TRes>
    implements CopyWith$Input$MergeRequestsResolverNegatedParams<TRes> {
  _CopyWithImpl$Input$MergeRequestsResolverNegatedParams(
    this._instance,
    this._then,
  );

  final Input$MergeRequestsResolverNegatedParams _instance;

  final TRes Function(Input$MergeRequestsResolverNegatedParams) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? labels = _undefined,
    Object? milestoneTitle = _undefined,
  }) =>
      _then(Input$MergeRequestsResolverNegatedParams._({
        ..._instance._$data,
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (milestoneTitle != _undefined)
          'milestoneTitle': (milestoneTitle as String?),
      }));
}

class _CopyWithStubImpl$Input$MergeRequestsResolverNegatedParams<TRes>
    implements CopyWith$Input$MergeRequestsResolverNegatedParams<TRes> {
  _CopyWithStubImpl$Input$MergeRequestsResolverNegatedParams(this._res);

  TRes _res;

  call({
    List<String>? labels,
    String? milestoneTitle,
  }) =>
      _res;
}

class Input$NamespaceBanDestroyInput {
  factory Input$NamespaceBanDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$NamespaceBanDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$NamespaceBanDestroyInput._(this._$data);

  factory Input$NamespaceBanDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$NamespaceBanDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$NamespaceBanDestroyInput<Input$NamespaceBanDestroyInput>
      get copyWith => CopyWith$Input$NamespaceBanDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NamespaceBanDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$NamespaceBanDestroyInput<TRes> {
  factory CopyWith$Input$NamespaceBanDestroyInput(
    Input$NamespaceBanDestroyInput instance,
    TRes Function(Input$NamespaceBanDestroyInput) then,
  ) = _CopyWithImpl$Input$NamespaceBanDestroyInput;

  factory CopyWith$Input$NamespaceBanDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NamespaceBanDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$NamespaceBanDestroyInput<TRes>
    implements CopyWith$Input$NamespaceBanDestroyInput<TRes> {
  _CopyWithImpl$Input$NamespaceBanDestroyInput(
    this._instance,
    this._then,
  );

  final Input$NamespaceBanDestroyInput _instance;

  final TRes Function(Input$NamespaceBanDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$NamespaceBanDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$NamespaceBanDestroyInput<TRes>
    implements CopyWith$Input$NamespaceBanDestroyInput<TRes> {
  _CopyWithStubImpl$Input$NamespaceBanDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$NamespaceCiCdSettingsUpdateInput {
  factory Input$NamespaceCiCdSettingsUpdateInput({
    String? clientMutationId,
    bool? allowStaleRunnerPruning,
    required String fullPath,
  }) =>
      Input$NamespaceCiCdSettingsUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (allowStaleRunnerPruning != null)
          r'allowStaleRunnerPruning': allowStaleRunnerPruning,
        r'fullPath': fullPath,
      });

  Input$NamespaceCiCdSettingsUpdateInput._(this._$data);

  factory Input$NamespaceCiCdSettingsUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('allowStaleRunnerPruning')) {
      final l$allowStaleRunnerPruning = data['allowStaleRunnerPruning'];
      result$data['allowStaleRunnerPruning'] =
          (l$allowStaleRunnerPruning as bool?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    return Input$NamespaceCiCdSettingsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get allowStaleRunnerPruning =>
      (_$data['allowStaleRunnerPruning'] as bool?);
  String get fullPath => (_$data['fullPath'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('allowStaleRunnerPruning')) {
      final l$allowStaleRunnerPruning = allowStaleRunnerPruning;
      result$data['allowStaleRunnerPruning'] = l$allowStaleRunnerPruning;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    return result$data;
  }

  CopyWith$Input$NamespaceCiCdSettingsUpdateInput<
          Input$NamespaceCiCdSettingsUpdateInput>
      get copyWith => CopyWith$Input$NamespaceCiCdSettingsUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NamespaceCiCdSettingsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$allowStaleRunnerPruning = allowStaleRunnerPruning;
    final lOther$allowStaleRunnerPruning = other.allowStaleRunnerPruning;
    if (_$data.containsKey('allowStaleRunnerPruning') !=
        other._$data.containsKey('allowStaleRunnerPruning')) {
      return false;
    }
    if (l$allowStaleRunnerPruning != lOther$allowStaleRunnerPruning) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$allowStaleRunnerPruning = allowStaleRunnerPruning;
    final l$fullPath = fullPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('allowStaleRunnerPruning')
          ? l$allowStaleRunnerPruning
          : const {},
      l$fullPath,
    ]);
  }
}

abstract class CopyWith$Input$NamespaceCiCdSettingsUpdateInput<TRes> {
  factory CopyWith$Input$NamespaceCiCdSettingsUpdateInput(
    Input$NamespaceCiCdSettingsUpdateInput instance,
    TRes Function(Input$NamespaceCiCdSettingsUpdateInput) then,
  ) = _CopyWithImpl$Input$NamespaceCiCdSettingsUpdateInput;

  factory CopyWith$Input$NamespaceCiCdSettingsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NamespaceCiCdSettingsUpdateInput;

  TRes call({
    String? clientMutationId,
    bool? allowStaleRunnerPruning,
    String? fullPath,
  });
}

class _CopyWithImpl$Input$NamespaceCiCdSettingsUpdateInput<TRes>
    implements CopyWith$Input$NamespaceCiCdSettingsUpdateInput<TRes> {
  _CopyWithImpl$Input$NamespaceCiCdSettingsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$NamespaceCiCdSettingsUpdateInput _instance;

  final TRes Function(Input$NamespaceCiCdSettingsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? allowStaleRunnerPruning = _undefined,
    Object? fullPath = _undefined,
  }) =>
      _then(Input$NamespaceCiCdSettingsUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (allowStaleRunnerPruning != _undefined)
          'allowStaleRunnerPruning': (allowStaleRunnerPruning as bool?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
      }));
}

class _CopyWithStubImpl$Input$NamespaceCiCdSettingsUpdateInput<TRes>
    implements CopyWith$Input$NamespaceCiCdSettingsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$NamespaceCiCdSettingsUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? allowStaleRunnerPruning,
    String? fullPath,
  }) =>
      _res;
}

class Input$NamespaceIncreaseStorageTemporarilyInput {
  factory Input$NamespaceIncreaseStorageTemporarilyInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$NamespaceIncreaseStorageTemporarilyInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$NamespaceIncreaseStorageTemporarilyInput._(this._$data);

  factory Input$NamespaceIncreaseStorageTemporarilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$NamespaceIncreaseStorageTemporarilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput<
          Input$NamespaceIncreaseStorageTemporarilyInput>
      get copyWith => CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NamespaceIncreaseStorageTemporarilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput<TRes> {
  factory CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput(
    Input$NamespaceIncreaseStorageTemporarilyInput instance,
    TRes Function(Input$NamespaceIncreaseStorageTemporarilyInput) then,
  ) = _CopyWithImpl$Input$NamespaceIncreaseStorageTemporarilyInput;

  factory CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NamespaceIncreaseStorageTemporarilyInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$NamespaceIncreaseStorageTemporarilyInput<TRes>
    implements CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput<TRes> {
  _CopyWithImpl$Input$NamespaceIncreaseStorageTemporarilyInput(
    this._instance,
    this._then,
  );

  final Input$NamespaceIncreaseStorageTemporarilyInput _instance;

  final TRes Function(Input$NamespaceIncreaseStorageTemporarilyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$NamespaceIncreaseStorageTemporarilyInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$NamespaceIncreaseStorageTemporarilyInput<TRes>
    implements CopyWith$Input$NamespaceIncreaseStorageTemporarilyInput<TRes> {
  _CopyWithStubImpl$Input$NamespaceIncreaseStorageTemporarilyInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$NegatedBoardIssueInput {
  factory Input$NegatedBoardIssueInput({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    List<String>? iids,
    String? milestoneTitle,
    List<String?>? assigneeUsername,
    String? releaseTag,
    List<Enum$IssueType>? types,
    Enum$MilestoneWildcardId? milestoneWildcardId,
    String? epicId,
    String? iterationTitle,
    String? weight,
    List<String>? iterationId,
    Enum$NegatedIterationWildcardId? iterationWildcardId,
  }) =>
      Input$NegatedBoardIssueInput._({
        if (labelName != null) r'labelName': labelName,
        if (authorUsername != null) r'authorUsername': authorUsername,
        if (myReactionEmoji != null) r'myReactionEmoji': myReactionEmoji,
        if (iids != null) r'iids': iids,
        if (milestoneTitle != null) r'milestoneTitle': milestoneTitle,
        if (assigneeUsername != null) r'assigneeUsername': assigneeUsername,
        if (releaseTag != null) r'releaseTag': releaseTag,
        if (types != null) r'types': types,
        if (milestoneWildcardId != null)
          r'milestoneWildcardId': milestoneWildcardId,
        if (epicId != null) r'epicId': epicId,
        if (iterationTitle != null) r'iterationTitle': iterationTitle,
        if (weight != null) r'weight': weight,
        if (iterationId != null) r'iterationId': iterationId,
        if (iterationWildcardId != null)
          r'iterationWildcardId': iterationWildcardId,
      });

  Input$NegatedBoardIssueInput._(this._$data);

  factory Input$NegatedBoardIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('labelName')) {
      final l$labelName = data['labelName'];
      result$data['labelName'] =
          (l$labelName as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as String?);
    }
    if (data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = data['myReactionEmoji'];
      result$data['myReactionEmoji'] = (l$myReactionEmoji as String?);
    }
    if (data.containsKey('iids')) {
      final l$iids = data['iids'];
      result$data['iids'] =
          (l$iids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = data['milestoneTitle'];
      result$data['milestoneTitle'] = (l$milestoneTitle as String?);
    }
    if (data.containsKey('assigneeUsername')) {
      final l$assigneeUsername = data['assigneeUsername'];
      result$data['assigneeUsername'] = (l$assigneeUsername as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('releaseTag')) {
      final l$releaseTag = data['releaseTag'];
      result$data['releaseTag'] = (l$releaseTag as String?);
    }
    if (data.containsKey('types')) {
      final l$types = data['types'];
      result$data['types'] = (l$types as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IssueType((e as String)))
          .toList();
    }
    if (data.containsKey('milestoneWildcardId')) {
      final l$milestoneWildcardId = data['milestoneWildcardId'];
      result$data['milestoneWildcardId'] = l$milestoneWildcardId == null
          ? null
          : fromJson$Enum$MilestoneWildcardId(
              (l$milestoneWildcardId as String));
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    if (data.containsKey('iterationTitle')) {
      final l$iterationTitle = data['iterationTitle'];
      result$data['iterationTitle'] = (l$iterationTitle as String?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] =
          (l$iterationId as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = data['iterationWildcardId'];
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : fromJson$Enum$NegatedIterationWildcardId(
              (l$iterationWildcardId as String));
    }
    return Input$NegatedBoardIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get labelName => (_$data['labelName'] as List<String?>?);
  String? get authorUsername => (_$data['authorUsername'] as String?);
  String? get myReactionEmoji => (_$data['myReactionEmoji'] as String?);
  List<String>? get iids => (_$data['iids'] as List<String>?);
  String? get milestoneTitle => (_$data['milestoneTitle'] as String?);
  List<String?>? get assigneeUsername =>
      (_$data['assigneeUsername'] as List<String?>?);
  String? get releaseTag => (_$data['releaseTag'] as String?);
  List<Enum$IssueType>? get types => (_$data['types'] as List<Enum$IssueType>?);
  Enum$MilestoneWildcardId? get milestoneWildcardId =>
      (_$data['milestoneWildcardId'] as Enum$MilestoneWildcardId?);
  String? get epicId => (_$data['epicId'] as String?);
  String? get iterationTitle => (_$data['iterationTitle'] as String?);
  String? get weight => (_$data['weight'] as String?);
  List<String>? get iterationId => (_$data['iterationId'] as List<String>?);
  Enum$NegatedIterationWildcardId? get iterationWildcardId =>
      (_$data['iterationWildcardId'] as Enum$NegatedIterationWildcardId?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('labelName')) {
      final l$labelName = labelName;
      result$data['labelName'] = l$labelName?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername;
    }
    if (_$data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = myReactionEmoji;
      result$data['myReactionEmoji'] = l$myReactionEmoji;
    }
    if (_$data.containsKey('iids')) {
      final l$iids = iids;
      result$data['iids'] = l$iids?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = milestoneTitle;
      result$data['milestoneTitle'] = l$milestoneTitle;
    }
    if (_$data.containsKey('assigneeUsername')) {
      final l$assigneeUsername = assigneeUsername;
      result$data['assigneeUsername'] =
          l$assigneeUsername?.map((e) => e).toList();
    }
    if (_$data.containsKey('releaseTag')) {
      final l$releaseTag = releaseTag;
      result$data['releaseTag'] = l$releaseTag;
    }
    if (_$data.containsKey('types')) {
      final l$types = types;
      result$data['types'] =
          l$types?.map((e) => toJson$Enum$IssueType(e)).toList();
    }
    if (_$data.containsKey('milestoneWildcardId')) {
      final l$milestoneWildcardId = milestoneWildcardId;
      result$data['milestoneWildcardId'] = l$milestoneWildcardId == null
          ? null
          : toJson$Enum$MilestoneWildcardId(l$milestoneWildcardId);
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    if (_$data.containsKey('iterationTitle')) {
      final l$iterationTitle = iterationTitle;
      result$data['iterationTitle'] = l$iterationTitle;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId?.map((e) => e).toList();
    }
    if (_$data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = iterationWildcardId;
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : toJson$Enum$NegatedIterationWildcardId(l$iterationWildcardId);
    }
    return result$data;
  }

  CopyWith$Input$NegatedBoardIssueInput<Input$NegatedBoardIssueInput>
      get copyWith => CopyWith$Input$NegatedBoardIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NegatedBoardIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelName = labelName;
    final lOther$labelName = other.labelName;
    if (_$data.containsKey('labelName') !=
        other._$data.containsKey('labelName')) {
      return false;
    }
    if (l$labelName != null && lOther$labelName != null) {
      if (l$labelName.length != lOther$labelName.length) {
        return false;
      }
      for (int i = 0; i < l$labelName.length; i++) {
        final l$labelName$entry = l$labelName[i];
        final lOther$labelName$entry = lOther$labelName[i];
        if (l$labelName$entry != lOther$labelName$entry) {
          return false;
        }
      }
    } else if (l$labelName != lOther$labelName) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$myReactionEmoji = myReactionEmoji;
    final lOther$myReactionEmoji = other.myReactionEmoji;
    if (_$data.containsKey('myReactionEmoji') !=
        other._$data.containsKey('myReactionEmoji')) {
      return false;
    }
    if (l$myReactionEmoji != lOther$myReactionEmoji) {
      return false;
    }
    final l$iids = iids;
    final lOther$iids = other.iids;
    if (_$data.containsKey('iids') != other._$data.containsKey('iids')) {
      return false;
    }
    if (l$iids != null && lOther$iids != null) {
      if (l$iids.length != lOther$iids.length) {
        return false;
      }
      for (int i = 0; i < l$iids.length; i++) {
        final l$iids$entry = l$iids[i];
        final lOther$iids$entry = lOther$iids[i];
        if (l$iids$entry != lOther$iids$entry) {
          return false;
        }
      }
    } else if (l$iids != lOther$iids) {
      return false;
    }
    final l$milestoneTitle = milestoneTitle;
    final lOther$milestoneTitle = other.milestoneTitle;
    if (_$data.containsKey('milestoneTitle') !=
        other._$data.containsKey('milestoneTitle')) {
      return false;
    }
    if (l$milestoneTitle != lOther$milestoneTitle) {
      return false;
    }
    final l$assigneeUsername = assigneeUsername;
    final lOther$assigneeUsername = other.assigneeUsername;
    if (_$data.containsKey('assigneeUsername') !=
        other._$data.containsKey('assigneeUsername')) {
      return false;
    }
    if (l$assigneeUsername != null && lOther$assigneeUsername != null) {
      if (l$assigneeUsername.length != lOther$assigneeUsername.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeUsername.length; i++) {
        final l$assigneeUsername$entry = l$assigneeUsername[i];
        final lOther$assigneeUsername$entry = lOther$assigneeUsername[i];
        if (l$assigneeUsername$entry != lOther$assigneeUsername$entry) {
          return false;
        }
      }
    } else if (l$assigneeUsername != lOther$assigneeUsername) {
      return false;
    }
    final l$releaseTag = releaseTag;
    final lOther$releaseTag = other.releaseTag;
    if (_$data.containsKey('releaseTag') !=
        other._$data.containsKey('releaseTag')) {
      return false;
    }
    if (l$releaseTag != lOther$releaseTag) {
      return false;
    }
    final l$types = types;
    final lOther$types = other.types;
    if (_$data.containsKey('types') != other._$data.containsKey('types')) {
      return false;
    }
    if (l$types != null && lOther$types != null) {
      if (l$types.length != lOther$types.length) {
        return false;
      }
      for (int i = 0; i < l$types.length; i++) {
        final l$types$entry = l$types[i];
        final lOther$types$entry = lOther$types[i];
        if (l$types$entry != lOther$types$entry) {
          return false;
        }
      }
    } else if (l$types != lOther$types) {
      return false;
    }
    final l$milestoneWildcardId = milestoneWildcardId;
    final lOther$milestoneWildcardId = other.milestoneWildcardId;
    if (_$data.containsKey('milestoneWildcardId') !=
        other._$data.containsKey('milestoneWildcardId')) {
      return false;
    }
    if (l$milestoneWildcardId != lOther$milestoneWildcardId) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    final l$iterationTitle = iterationTitle;
    final lOther$iterationTitle = other.iterationTitle;
    if (_$data.containsKey('iterationTitle') !=
        other._$data.containsKey('iterationTitle')) {
      return false;
    }
    if (l$iterationTitle != lOther$iterationTitle) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != null && lOther$iterationId != null) {
      if (l$iterationId.length != lOther$iterationId.length) {
        return false;
      }
      for (int i = 0; i < l$iterationId.length; i++) {
        final l$iterationId$entry = l$iterationId[i];
        final lOther$iterationId$entry = lOther$iterationId[i];
        if (l$iterationId$entry != lOther$iterationId$entry) {
          return false;
        }
      }
    } else if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$iterationWildcardId = iterationWildcardId;
    final lOther$iterationWildcardId = other.iterationWildcardId;
    if (_$data.containsKey('iterationWildcardId') !=
        other._$data.containsKey('iterationWildcardId')) {
      return false;
    }
    if (l$iterationWildcardId != lOther$iterationWildcardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelName = labelName;
    final l$authorUsername = authorUsername;
    final l$myReactionEmoji = myReactionEmoji;
    final l$iids = iids;
    final l$milestoneTitle = milestoneTitle;
    final l$assigneeUsername = assigneeUsername;
    final l$releaseTag = releaseTag;
    final l$types = types;
    final l$milestoneWildcardId = milestoneWildcardId;
    final l$epicId = epicId;
    final l$iterationTitle = iterationTitle;
    final l$weight = weight;
    final l$iterationId = iterationId;
    final l$iterationWildcardId = iterationWildcardId;
    return Object.hashAll([
      _$data.containsKey('labelName')
          ? l$labelName == null
              ? null
              : Object.hashAll(l$labelName.map((v) => v))
          : const {},
      _$data.containsKey('authorUsername') ? l$authorUsername : const {},
      _$data.containsKey('myReactionEmoji') ? l$myReactionEmoji : const {},
      _$data.containsKey('iids')
          ? l$iids == null
              ? null
              : Object.hashAll(l$iids.map((v) => v))
          : const {},
      _$data.containsKey('milestoneTitle') ? l$milestoneTitle : const {},
      _$data.containsKey('assigneeUsername')
          ? l$assigneeUsername == null
              ? null
              : Object.hashAll(l$assigneeUsername.map((v) => v))
          : const {},
      _$data.containsKey('releaseTag') ? l$releaseTag : const {},
      _$data.containsKey('types')
          ? l$types == null
              ? null
              : Object.hashAll(l$types.map((v) => v))
          : const {},
      _$data.containsKey('milestoneWildcardId')
          ? l$milestoneWildcardId
          : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
      _$data.containsKey('iterationTitle') ? l$iterationTitle : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('iterationId')
          ? l$iterationId == null
              ? null
              : Object.hashAll(l$iterationId.map((v) => v))
          : const {},
      _$data.containsKey('iterationWildcardId')
          ? l$iterationWildcardId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NegatedBoardIssueInput<TRes> {
  factory CopyWith$Input$NegatedBoardIssueInput(
    Input$NegatedBoardIssueInput instance,
    TRes Function(Input$NegatedBoardIssueInput) then,
  ) = _CopyWithImpl$Input$NegatedBoardIssueInput;

  factory CopyWith$Input$NegatedBoardIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NegatedBoardIssueInput;

  TRes call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    List<String>? iids,
    String? milestoneTitle,
    List<String?>? assigneeUsername,
    String? releaseTag,
    List<Enum$IssueType>? types,
    Enum$MilestoneWildcardId? milestoneWildcardId,
    String? epicId,
    String? iterationTitle,
    String? weight,
    List<String>? iterationId,
    Enum$NegatedIterationWildcardId? iterationWildcardId,
  });
}

class _CopyWithImpl$Input$NegatedBoardIssueInput<TRes>
    implements CopyWith$Input$NegatedBoardIssueInput<TRes> {
  _CopyWithImpl$Input$NegatedBoardIssueInput(
    this._instance,
    this._then,
  );

  final Input$NegatedBoardIssueInput _instance;

  final TRes Function(Input$NegatedBoardIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? labelName = _undefined,
    Object? authorUsername = _undefined,
    Object? myReactionEmoji = _undefined,
    Object? iids = _undefined,
    Object? milestoneTitle = _undefined,
    Object? assigneeUsername = _undefined,
    Object? releaseTag = _undefined,
    Object? types = _undefined,
    Object? milestoneWildcardId = _undefined,
    Object? epicId = _undefined,
    Object? iterationTitle = _undefined,
    Object? weight = _undefined,
    Object? iterationId = _undefined,
    Object? iterationWildcardId = _undefined,
  }) =>
      _then(Input$NegatedBoardIssueInput._({
        ..._instance._$data,
        if (labelName != _undefined) 'labelName': (labelName as List<String?>?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as String?),
        if (myReactionEmoji != _undefined)
          'myReactionEmoji': (myReactionEmoji as String?),
        if (iids != _undefined) 'iids': (iids as List<String>?),
        if (milestoneTitle != _undefined)
          'milestoneTitle': (milestoneTitle as String?),
        if (assigneeUsername != _undefined)
          'assigneeUsername': (assigneeUsername as List<String?>?),
        if (releaseTag != _undefined) 'releaseTag': (releaseTag as String?),
        if (types != _undefined) 'types': (types as List<Enum$IssueType>?),
        if (milestoneWildcardId != _undefined)
          'milestoneWildcardId':
              (milestoneWildcardId as Enum$MilestoneWildcardId?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
        if (iterationTitle != _undefined)
          'iterationTitle': (iterationTitle as String?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (iterationId != _undefined)
          'iterationId': (iterationId as List<String>?),
        if (iterationWildcardId != _undefined)
          'iterationWildcardId':
              (iterationWildcardId as Enum$NegatedIterationWildcardId?),
      }));
}

class _CopyWithStubImpl$Input$NegatedBoardIssueInput<TRes>
    implements CopyWith$Input$NegatedBoardIssueInput<TRes> {
  _CopyWithStubImpl$Input$NegatedBoardIssueInput(this._res);

  TRes _res;

  call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
    List<String>? iids,
    String? milestoneTitle,
    List<String?>? assigneeUsername,
    String? releaseTag,
    List<Enum$IssueType>? types,
    Enum$MilestoneWildcardId? milestoneWildcardId,
    String? epicId,
    String? iterationTitle,
    String? weight,
    List<String>? iterationId,
    Enum$NegatedIterationWildcardId? iterationWildcardId,
  }) =>
      _res;
}

class Input$NegatedEpicBoardIssueInput {
  factory Input$NegatedEpicBoardIssueInput({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
  }) =>
      Input$NegatedEpicBoardIssueInput._({
        if (labelName != null) r'labelName': labelName,
        if (authorUsername != null) r'authorUsername': authorUsername,
        if (myReactionEmoji != null) r'myReactionEmoji': myReactionEmoji,
      });

  Input$NegatedEpicBoardIssueInput._(this._$data);

  factory Input$NegatedEpicBoardIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('labelName')) {
      final l$labelName = data['labelName'];
      result$data['labelName'] =
          (l$labelName as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as String?);
    }
    if (data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = data['myReactionEmoji'];
      result$data['myReactionEmoji'] = (l$myReactionEmoji as String?);
    }
    return Input$NegatedEpicBoardIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get labelName => (_$data['labelName'] as List<String?>?);
  String? get authorUsername => (_$data['authorUsername'] as String?);
  String? get myReactionEmoji => (_$data['myReactionEmoji'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('labelName')) {
      final l$labelName = labelName;
      result$data['labelName'] = l$labelName?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername;
    }
    if (_$data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = myReactionEmoji;
      result$data['myReactionEmoji'] = l$myReactionEmoji;
    }
    return result$data;
  }

  CopyWith$Input$NegatedEpicBoardIssueInput<Input$NegatedEpicBoardIssueInput>
      get copyWith => CopyWith$Input$NegatedEpicBoardIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NegatedEpicBoardIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelName = labelName;
    final lOther$labelName = other.labelName;
    if (_$data.containsKey('labelName') !=
        other._$data.containsKey('labelName')) {
      return false;
    }
    if (l$labelName != null && lOther$labelName != null) {
      if (l$labelName.length != lOther$labelName.length) {
        return false;
      }
      for (int i = 0; i < l$labelName.length; i++) {
        final l$labelName$entry = l$labelName[i];
        final lOther$labelName$entry = lOther$labelName[i];
        if (l$labelName$entry != lOther$labelName$entry) {
          return false;
        }
      }
    } else if (l$labelName != lOther$labelName) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$myReactionEmoji = myReactionEmoji;
    final lOther$myReactionEmoji = other.myReactionEmoji;
    if (_$data.containsKey('myReactionEmoji') !=
        other._$data.containsKey('myReactionEmoji')) {
      return false;
    }
    if (l$myReactionEmoji != lOther$myReactionEmoji) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelName = labelName;
    final l$authorUsername = authorUsername;
    final l$myReactionEmoji = myReactionEmoji;
    return Object.hashAll([
      _$data.containsKey('labelName')
          ? l$labelName == null
              ? null
              : Object.hashAll(l$labelName.map((v) => v))
          : const {},
      _$data.containsKey('authorUsername') ? l$authorUsername : const {},
      _$data.containsKey('myReactionEmoji') ? l$myReactionEmoji : const {},
    ]);
  }
}

abstract class CopyWith$Input$NegatedEpicBoardIssueInput<TRes> {
  factory CopyWith$Input$NegatedEpicBoardIssueInput(
    Input$NegatedEpicBoardIssueInput instance,
    TRes Function(Input$NegatedEpicBoardIssueInput) then,
  ) = _CopyWithImpl$Input$NegatedEpicBoardIssueInput;

  factory CopyWith$Input$NegatedEpicBoardIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NegatedEpicBoardIssueInput;

  TRes call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
  });
}

class _CopyWithImpl$Input$NegatedEpicBoardIssueInput<TRes>
    implements CopyWith$Input$NegatedEpicBoardIssueInput<TRes> {
  _CopyWithImpl$Input$NegatedEpicBoardIssueInput(
    this._instance,
    this._then,
  );

  final Input$NegatedEpicBoardIssueInput _instance;

  final TRes Function(Input$NegatedEpicBoardIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? labelName = _undefined,
    Object? authorUsername = _undefined,
    Object? myReactionEmoji = _undefined,
  }) =>
      _then(Input$NegatedEpicBoardIssueInput._({
        ..._instance._$data,
        if (labelName != _undefined) 'labelName': (labelName as List<String?>?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as String?),
        if (myReactionEmoji != _undefined)
          'myReactionEmoji': (myReactionEmoji as String?),
      }));
}

class _CopyWithStubImpl$Input$NegatedEpicBoardIssueInput<TRes>
    implements CopyWith$Input$NegatedEpicBoardIssueInput<TRes> {
  _CopyWithStubImpl$Input$NegatedEpicBoardIssueInput(this._res);

  TRes _res;

  call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
  }) =>
      _res;
}

class Input$NegatedEpicFilterInput {
  factory Input$NegatedEpicFilterInput({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
  }) =>
      Input$NegatedEpicFilterInput._({
        if (labelName != null) r'labelName': labelName,
        if (authorUsername != null) r'authorUsername': authorUsername,
        if (myReactionEmoji != null) r'myReactionEmoji': myReactionEmoji,
      });

  Input$NegatedEpicFilterInput._(this._$data);

  factory Input$NegatedEpicFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('labelName')) {
      final l$labelName = data['labelName'];
      result$data['labelName'] =
          (l$labelName as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as String?);
    }
    if (data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = data['myReactionEmoji'];
      result$data['myReactionEmoji'] = (l$myReactionEmoji as String?);
    }
    return Input$NegatedEpicFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get labelName => (_$data['labelName'] as List<String?>?);
  String? get authorUsername => (_$data['authorUsername'] as String?);
  String? get myReactionEmoji => (_$data['myReactionEmoji'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('labelName')) {
      final l$labelName = labelName;
      result$data['labelName'] = l$labelName?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername;
    }
    if (_$data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = myReactionEmoji;
      result$data['myReactionEmoji'] = l$myReactionEmoji;
    }
    return result$data;
  }

  CopyWith$Input$NegatedEpicFilterInput<Input$NegatedEpicFilterInput>
      get copyWith => CopyWith$Input$NegatedEpicFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NegatedEpicFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelName = labelName;
    final lOther$labelName = other.labelName;
    if (_$data.containsKey('labelName') !=
        other._$data.containsKey('labelName')) {
      return false;
    }
    if (l$labelName != null && lOther$labelName != null) {
      if (l$labelName.length != lOther$labelName.length) {
        return false;
      }
      for (int i = 0; i < l$labelName.length; i++) {
        final l$labelName$entry = l$labelName[i];
        final lOther$labelName$entry = lOther$labelName[i];
        if (l$labelName$entry != lOther$labelName$entry) {
          return false;
        }
      }
    } else if (l$labelName != lOther$labelName) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$myReactionEmoji = myReactionEmoji;
    final lOther$myReactionEmoji = other.myReactionEmoji;
    if (_$data.containsKey('myReactionEmoji') !=
        other._$data.containsKey('myReactionEmoji')) {
      return false;
    }
    if (l$myReactionEmoji != lOther$myReactionEmoji) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelName = labelName;
    final l$authorUsername = authorUsername;
    final l$myReactionEmoji = myReactionEmoji;
    return Object.hashAll([
      _$data.containsKey('labelName')
          ? l$labelName == null
              ? null
              : Object.hashAll(l$labelName.map((v) => v))
          : const {},
      _$data.containsKey('authorUsername') ? l$authorUsername : const {},
      _$data.containsKey('myReactionEmoji') ? l$myReactionEmoji : const {},
    ]);
  }
}

abstract class CopyWith$Input$NegatedEpicFilterInput<TRes> {
  factory CopyWith$Input$NegatedEpicFilterInput(
    Input$NegatedEpicFilterInput instance,
    TRes Function(Input$NegatedEpicFilterInput) then,
  ) = _CopyWithImpl$Input$NegatedEpicFilterInput;

  factory CopyWith$Input$NegatedEpicFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NegatedEpicFilterInput;

  TRes call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
  });
}

class _CopyWithImpl$Input$NegatedEpicFilterInput<TRes>
    implements CopyWith$Input$NegatedEpicFilterInput<TRes> {
  _CopyWithImpl$Input$NegatedEpicFilterInput(
    this._instance,
    this._then,
  );

  final Input$NegatedEpicFilterInput _instance;

  final TRes Function(Input$NegatedEpicFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? labelName = _undefined,
    Object? authorUsername = _undefined,
    Object? myReactionEmoji = _undefined,
  }) =>
      _then(Input$NegatedEpicFilterInput._({
        ..._instance._$data,
        if (labelName != _undefined) 'labelName': (labelName as List<String?>?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as String?),
        if (myReactionEmoji != _undefined)
          'myReactionEmoji': (myReactionEmoji as String?),
      }));
}

class _CopyWithStubImpl$Input$NegatedEpicFilterInput<TRes>
    implements CopyWith$Input$NegatedEpicFilterInput<TRes> {
  _CopyWithStubImpl$Input$NegatedEpicFilterInput(this._res);

  TRes _res;

  call({
    List<String?>? labelName,
    String? authorUsername,
    String? myReactionEmoji,
  }) =>
      _res;
}

class Input$NegatedIssueFilterInput {
  factory Input$NegatedIssueFilterInput({
    String? assigneeId,
    List<String>? assigneeUsernames,
    String? authorUsername,
    List<String>? iids,
    List<String>? labelName,
    List<String>? milestoneTitle,
    Enum$NegatedMilestoneWildcardId? milestoneWildcardId,
    String? myReactionEmoji,
    List<String>? releaseTag,
    List<Enum$IssueType>? types,
    String? epicId,
    String? weight,
    List<String>? iterationId,
    Enum$IterationWildcardId? iterationWildcardId,
  }) =>
      Input$NegatedIssueFilterInput._({
        if (assigneeId != null) r'assigneeId': assigneeId,
        if (assigneeUsernames != null) r'assigneeUsernames': assigneeUsernames,
        if (authorUsername != null) r'authorUsername': authorUsername,
        if (iids != null) r'iids': iids,
        if (labelName != null) r'labelName': labelName,
        if (milestoneTitle != null) r'milestoneTitle': milestoneTitle,
        if (milestoneWildcardId != null)
          r'milestoneWildcardId': milestoneWildcardId,
        if (myReactionEmoji != null) r'myReactionEmoji': myReactionEmoji,
        if (releaseTag != null) r'releaseTag': releaseTag,
        if (types != null) r'types': types,
        if (epicId != null) r'epicId': epicId,
        if (weight != null) r'weight': weight,
        if (iterationId != null) r'iterationId': iterationId,
        if (iterationWildcardId != null)
          r'iterationWildcardId': iterationWildcardId,
      });

  Input$NegatedIssueFilterInput._(this._$data);

  factory Input$NegatedIssueFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assigneeId')) {
      final l$assigneeId = data['assigneeId'];
      result$data['assigneeId'] = (l$assigneeId as String?);
    }
    if (data.containsKey('assigneeUsernames')) {
      final l$assigneeUsernames = data['assigneeUsernames'];
      result$data['assigneeUsernames'] = (l$assigneeUsernames as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('authorUsername')) {
      final l$authorUsername = data['authorUsername'];
      result$data['authorUsername'] = (l$authorUsername as String?);
    }
    if (data.containsKey('iids')) {
      final l$iids = data['iids'];
      result$data['iids'] =
          (l$iids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('labelName')) {
      final l$labelName = data['labelName'];
      result$data['labelName'] =
          (l$labelName as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = data['milestoneTitle'];
      result$data['milestoneTitle'] = (l$milestoneTitle as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('milestoneWildcardId')) {
      final l$milestoneWildcardId = data['milestoneWildcardId'];
      result$data['milestoneWildcardId'] = l$milestoneWildcardId == null
          ? null
          : fromJson$Enum$NegatedMilestoneWildcardId(
              (l$milestoneWildcardId as String));
    }
    if (data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = data['myReactionEmoji'];
      result$data['myReactionEmoji'] = (l$myReactionEmoji as String?);
    }
    if (data.containsKey('releaseTag')) {
      final l$releaseTag = data['releaseTag'];
      result$data['releaseTag'] =
          (l$releaseTag as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('types')) {
      final l$types = data['types'];
      result$data['types'] = (l$types as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IssueType((e as String)))
          .toList();
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] =
          (l$iterationId as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = data['iterationWildcardId'];
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : fromJson$Enum$IterationWildcardId(
              (l$iterationWildcardId as String));
    }
    return Input$NegatedIssueFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get assigneeId => (_$data['assigneeId'] as String?);
  List<String>? get assigneeUsernames =>
      (_$data['assigneeUsernames'] as List<String>?);
  String? get authorUsername => (_$data['authorUsername'] as String?);
  List<String>? get iids => (_$data['iids'] as List<String>?);
  List<String>? get labelName => (_$data['labelName'] as List<String>?);
  List<String>? get milestoneTitle =>
      (_$data['milestoneTitle'] as List<String>?);
  Enum$NegatedMilestoneWildcardId? get milestoneWildcardId =>
      (_$data['milestoneWildcardId'] as Enum$NegatedMilestoneWildcardId?);
  String? get myReactionEmoji => (_$data['myReactionEmoji'] as String?);
  List<String>? get releaseTag => (_$data['releaseTag'] as List<String>?);
  List<Enum$IssueType>? get types => (_$data['types'] as List<Enum$IssueType>?);
  String? get epicId => (_$data['epicId'] as String?);
  String? get weight => (_$data['weight'] as String?);
  List<String>? get iterationId => (_$data['iterationId'] as List<String>?);
  Enum$IterationWildcardId? get iterationWildcardId =>
      (_$data['iterationWildcardId'] as Enum$IterationWildcardId?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assigneeId')) {
      final l$assigneeId = assigneeId;
      result$data['assigneeId'] = l$assigneeId;
    }
    if (_$data.containsKey('assigneeUsernames')) {
      final l$assigneeUsernames = assigneeUsernames;
      result$data['assigneeUsernames'] =
          l$assigneeUsernames?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorUsername')) {
      final l$authorUsername = authorUsername;
      result$data['authorUsername'] = l$authorUsername;
    }
    if (_$data.containsKey('iids')) {
      final l$iids = iids;
      result$data['iids'] = l$iids?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelName')) {
      final l$labelName = labelName;
      result$data['labelName'] = l$labelName?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneTitle')) {
      final l$milestoneTitle = milestoneTitle;
      result$data['milestoneTitle'] = l$milestoneTitle?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneWildcardId')) {
      final l$milestoneWildcardId = milestoneWildcardId;
      result$data['milestoneWildcardId'] = l$milestoneWildcardId == null
          ? null
          : toJson$Enum$NegatedMilestoneWildcardId(l$milestoneWildcardId);
    }
    if (_$data.containsKey('myReactionEmoji')) {
      final l$myReactionEmoji = myReactionEmoji;
      result$data['myReactionEmoji'] = l$myReactionEmoji;
    }
    if (_$data.containsKey('releaseTag')) {
      final l$releaseTag = releaseTag;
      result$data['releaseTag'] = l$releaseTag?.map((e) => e).toList();
    }
    if (_$data.containsKey('types')) {
      final l$types = types;
      result$data['types'] =
          l$types?.map((e) => toJson$Enum$IssueType(e)).toList();
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId?.map((e) => e).toList();
    }
    if (_$data.containsKey('iterationWildcardId')) {
      final l$iterationWildcardId = iterationWildcardId;
      result$data['iterationWildcardId'] = l$iterationWildcardId == null
          ? null
          : toJson$Enum$IterationWildcardId(l$iterationWildcardId);
    }
    return result$data;
  }

  CopyWith$Input$NegatedIssueFilterInput<Input$NegatedIssueFilterInput>
      get copyWith => CopyWith$Input$NegatedIssueFilterInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NegatedIssueFilterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeId = assigneeId;
    final lOther$assigneeId = other.assigneeId;
    if (_$data.containsKey('assigneeId') !=
        other._$data.containsKey('assigneeId')) {
      return false;
    }
    if (l$assigneeId != lOther$assigneeId) {
      return false;
    }
    final l$assigneeUsernames = assigneeUsernames;
    final lOther$assigneeUsernames = other.assigneeUsernames;
    if (_$data.containsKey('assigneeUsernames') !=
        other._$data.containsKey('assigneeUsernames')) {
      return false;
    }
    if (l$assigneeUsernames != null && lOther$assigneeUsernames != null) {
      if (l$assigneeUsernames.length != lOther$assigneeUsernames.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeUsernames.length; i++) {
        final l$assigneeUsernames$entry = l$assigneeUsernames[i];
        final lOther$assigneeUsernames$entry = lOther$assigneeUsernames[i];
        if (l$assigneeUsernames$entry != lOther$assigneeUsernames$entry) {
          return false;
        }
      }
    } else if (l$assigneeUsernames != lOther$assigneeUsernames) {
      return false;
    }
    final l$authorUsername = authorUsername;
    final lOther$authorUsername = other.authorUsername;
    if (_$data.containsKey('authorUsername') !=
        other._$data.containsKey('authorUsername')) {
      return false;
    }
    if (l$authorUsername != lOther$authorUsername) {
      return false;
    }
    final l$iids = iids;
    final lOther$iids = other.iids;
    if (_$data.containsKey('iids') != other._$data.containsKey('iids')) {
      return false;
    }
    if (l$iids != null && lOther$iids != null) {
      if (l$iids.length != lOther$iids.length) {
        return false;
      }
      for (int i = 0; i < l$iids.length; i++) {
        final l$iids$entry = l$iids[i];
        final lOther$iids$entry = lOther$iids[i];
        if (l$iids$entry != lOther$iids$entry) {
          return false;
        }
      }
    } else if (l$iids != lOther$iids) {
      return false;
    }
    final l$labelName = labelName;
    final lOther$labelName = other.labelName;
    if (_$data.containsKey('labelName') !=
        other._$data.containsKey('labelName')) {
      return false;
    }
    if (l$labelName != null && lOther$labelName != null) {
      if (l$labelName.length != lOther$labelName.length) {
        return false;
      }
      for (int i = 0; i < l$labelName.length; i++) {
        final l$labelName$entry = l$labelName[i];
        final lOther$labelName$entry = lOther$labelName[i];
        if (l$labelName$entry != lOther$labelName$entry) {
          return false;
        }
      }
    } else if (l$labelName != lOther$labelName) {
      return false;
    }
    final l$milestoneTitle = milestoneTitle;
    final lOther$milestoneTitle = other.milestoneTitle;
    if (_$data.containsKey('milestoneTitle') !=
        other._$data.containsKey('milestoneTitle')) {
      return false;
    }
    if (l$milestoneTitle != null && lOther$milestoneTitle != null) {
      if (l$milestoneTitle.length != lOther$milestoneTitle.length) {
        return false;
      }
      for (int i = 0; i < l$milestoneTitle.length; i++) {
        final l$milestoneTitle$entry = l$milestoneTitle[i];
        final lOther$milestoneTitle$entry = lOther$milestoneTitle[i];
        if (l$milestoneTitle$entry != lOther$milestoneTitle$entry) {
          return false;
        }
      }
    } else if (l$milestoneTitle != lOther$milestoneTitle) {
      return false;
    }
    final l$milestoneWildcardId = milestoneWildcardId;
    final lOther$milestoneWildcardId = other.milestoneWildcardId;
    if (_$data.containsKey('milestoneWildcardId') !=
        other._$data.containsKey('milestoneWildcardId')) {
      return false;
    }
    if (l$milestoneWildcardId != lOther$milestoneWildcardId) {
      return false;
    }
    final l$myReactionEmoji = myReactionEmoji;
    final lOther$myReactionEmoji = other.myReactionEmoji;
    if (_$data.containsKey('myReactionEmoji') !=
        other._$data.containsKey('myReactionEmoji')) {
      return false;
    }
    if (l$myReactionEmoji != lOther$myReactionEmoji) {
      return false;
    }
    final l$releaseTag = releaseTag;
    final lOther$releaseTag = other.releaseTag;
    if (_$data.containsKey('releaseTag') !=
        other._$data.containsKey('releaseTag')) {
      return false;
    }
    if (l$releaseTag != null && lOther$releaseTag != null) {
      if (l$releaseTag.length != lOther$releaseTag.length) {
        return false;
      }
      for (int i = 0; i < l$releaseTag.length; i++) {
        final l$releaseTag$entry = l$releaseTag[i];
        final lOther$releaseTag$entry = lOther$releaseTag[i];
        if (l$releaseTag$entry != lOther$releaseTag$entry) {
          return false;
        }
      }
    } else if (l$releaseTag != lOther$releaseTag) {
      return false;
    }
    final l$types = types;
    final lOther$types = other.types;
    if (_$data.containsKey('types') != other._$data.containsKey('types')) {
      return false;
    }
    if (l$types != null && lOther$types != null) {
      if (l$types.length != lOther$types.length) {
        return false;
      }
      for (int i = 0; i < l$types.length; i++) {
        final l$types$entry = l$types[i];
        final lOther$types$entry = lOther$types[i];
        if (l$types$entry != lOther$types$entry) {
          return false;
        }
      }
    } else if (l$types != lOther$types) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != null && lOther$iterationId != null) {
      if (l$iterationId.length != lOther$iterationId.length) {
        return false;
      }
      for (int i = 0; i < l$iterationId.length; i++) {
        final l$iterationId$entry = l$iterationId[i];
        final lOther$iterationId$entry = lOther$iterationId[i];
        if (l$iterationId$entry != lOther$iterationId$entry) {
          return false;
        }
      }
    } else if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$iterationWildcardId = iterationWildcardId;
    final lOther$iterationWildcardId = other.iterationWildcardId;
    if (_$data.containsKey('iterationWildcardId') !=
        other._$data.containsKey('iterationWildcardId')) {
      return false;
    }
    if (l$iterationWildcardId != lOther$iterationWildcardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeId = assigneeId;
    final l$assigneeUsernames = assigneeUsernames;
    final l$authorUsername = authorUsername;
    final l$iids = iids;
    final l$labelName = labelName;
    final l$milestoneTitle = milestoneTitle;
    final l$milestoneWildcardId = milestoneWildcardId;
    final l$myReactionEmoji = myReactionEmoji;
    final l$releaseTag = releaseTag;
    final l$types = types;
    final l$epicId = epicId;
    final l$weight = weight;
    final l$iterationId = iterationId;
    final l$iterationWildcardId = iterationWildcardId;
    return Object.hashAll([
      _$data.containsKey('assigneeId') ? l$assigneeId : const {},
      _$data.containsKey('assigneeUsernames')
          ? l$assigneeUsernames == null
              ? null
              : Object.hashAll(l$assigneeUsernames.map((v) => v))
          : const {},
      _$data.containsKey('authorUsername') ? l$authorUsername : const {},
      _$data.containsKey('iids')
          ? l$iids == null
              ? null
              : Object.hashAll(l$iids.map((v) => v))
          : const {},
      _$data.containsKey('labelName')
          ? l$labelName == null
              ? null
              : Object.hashAll(l$labelName.map((v) => v))
          : const {},
      _$data.containsKey('milestoneTitle')
          ? l$milestoneTitle == null
              ? null
              : Object.hashAll(l$milestoneTitle.map((v) => v))
          : const {},
      _$data.containsKey('milestoneWildcardId')
          ? l$milestoneWildcardId
          : const {},
      _$data.containsKey('myReactionEmoji') ? l$myReactionEmoji : const {},
      _$data.containsKey('releaseTag')
          ? l$releaseTag == null
              ? null
              : Object.hashAll(l$releaseTag.map((v) => v))
          : const {},
      _$data.containsKey('types')
          ? l$types == null
              ? null
              : Object.hashAll(l$types.map((v) => v))
          : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('iterationId')
          ? l$iterationId == null
              ? null
              : Object.hashAll(l$iterationId.map((v) => v))
          : const {},
      _$data.containsKey('iterationWildcardId')
          ? l$iterationWildcardId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NegatedIssueFilterInput<TRes> {
  factory CopyWith$Input$NegatedIssueFilterInput(
    Input$NegatedIssueFilterInput instance,
    TRes Function(Input$NegatedIssueFilterInput) then,
  ) = _CopyWithImpl$Input$NegatedIssueFilterInput;

  factory CopyWith$Input$NegatedIssueFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NegatedIssueFilterInput;

  TRes call({
    String? assigneeId,
    List<String>? assigneeUsernames,
    String? authorUsername,
    List<String>? iids,
    List<String>? labelName,
    List<String>? milestoneTitle,
    Enum$NegatedMilestoneWildcardId? milestoneWildcardId,
    String? myReactionEmoji,
    List<String>? releaseTag,
    List<Enum$IssueType>? types,
    String? epicId,
    String? weight,
    List<String>? iterationId,
    Enum$IterationWildcardId? iterationWildcardId,
  });
}

class _CopyWithImpl$Input$NegatedIssueFilterInput<TRes>
    implements CopyWith$Input$NegatedIssueFilterInput<TRes> {
  _CopyWithImpl$Input$NegatedIssueFilterInput(
    this._instance,
    this._then,
  );

  final Input$NegatedIssueFilterInput _instance;

  final TRes Function(Input$NegatedIssueFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assigneeId = _undefined,
    Object? assigneeUsernames = _undefined,
    Object? authorUsername = _undefined,
    Object? iids = _undefined,
    Object? labelName = _undefined,
    Object? milestoneTitle = _undefined,
    Object? milestoneWildcardId = _undefined,
    Object? myReactionEmoji = _undefined,
    Object? releaseTag = _undefined,
    Object? types = _undefined,
    Object? epicId = _undefined,
    Object? weight = _undefined,
    Object? iterationId = _undefined,
    Object? iterationWildcardId = _undefined,
  }) =>
      _then(Input$NegatedIssueFilterInput._({
        ..._instance._$data,
        if (assigneeId != _undefined) 'assigneeId': (assigneeId as String?),
        if (assigneeUsernames != _undefined)
          'assigneeUsernames': (assigneeUsernames as List<String>?),
        if (authorUsername != _undefined)
          'authorUsername': (authorUsername as String?),
        if (iids != _undefined) 'iids': (iids as List<String>?),
        if (labelName != _undefined) 'labelName': (labelName as List<String>?),
        if (milestoneTitle != _undefined)
          'milestoneTitle': (milestoneTitle as List<String>?),
        if (milestoneWildcardId != _undefined)
          'milestoneWildcardId':
              (milestoneWildcardId as Enum$NegatedMilestoneWildcardId?),
        if (myReactionEmoji != _undefined)
          'myReactionEmoji': (myReactionEmoji as String?),
        if (releaseTag != _undefined)
          'releaseTag': (releaseTag as List<String>?),
        if (types != _undefined) 'types': (types as List<Enum$IssueType>?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (iterationId != _undefined)
          'iterationId': (iterationId as List<String>?),
        if (iterationWildcardId != _undefined)
          'iterationWildcardId':
              (iterationWildcardId as Enum$IterationWildcardId?),
      }));
}

class _CopyWithStubImpl$Input$NegatedIssueFilterInput<TRes>
    implements CopyWith$Input$NegatedIssueFilterInput<TRes> {
  _CopyWithStubImpl$Input$NegatedIssueFilterInput(this._res);

  TRes _res;

  call({
    String? assigneeId,
    List<String>? assigneeUsernames,
    String? authorUsername,
    List<String>? iids,
    List<String>? labelName,
    List<String>? milestoneTitle,
    Enum$NegatedMilestoneWildcardId? milestoneWildcardId,
    String? myReactionEmoji,
    List<String>? releaseTag,
    List<Enum$IssueType>? types,
    String? epicId,
    String? weight,
    List<String>? iterationId,
    Enum$IterationWildcardId? iterationWildcardId,
  }) =>
      _res;
}

class Input$OncallRotationActivePeriodInputType {
  factory Input$OncallRotationActivePeriodInputType({
    required String startTime,
    required String endTime,
  }) =>
      Input$OncallRotationActivePeriodInputType._({
        r'startTime': startTime,
        r'endTime': endTime,
      });

  Input$OncallRotationActivePeriodInputType._(this._$data);

  factory Input$OncallRotationActivePeriodInputType.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$startTime = data['startTime'];
    result$data['startTime'] = (l$startTime as String);
    final l$endTime = data['endTime'];
    result$data['endTime'] = (l$endTime as String);
    return Input$OncallRotationActivePeriodInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  String get startTime => (_$data['startTime'] as String);
  String get endTime => (_$data['endTime'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$startTime = startTime;
    result$data['startTime'] = l$startTime;
    final l$endTime = endTime;
    result$data['endTime'] = l$endTime;
    return result$data;
  }

  CopyWith$Input$OncallRotationActivePeriodInputType<
          Input$OncallRotationActivePeriodInputType>
      get copyWith => CopyWith$Input$OncallRotationActivePeriodInputType(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallRotationActivePeriodInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$startTime = startTime;
    final lOther$startTime = other.startTime;
    if (l$startTime != lOther$startTime) {
      return false;
    }
    final l$endTime = endTime;
    final lOther$endTime = other.endTime;
    if (l$endTime != lOther$endTime) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$startTime = startTime;
    final l$endTime = endTime;
    return Object.hashAll([
      l$startTime,
      l$endTime,
    ]);
  }
}

abstract class CopyWith$Input$OncallRotationActivePeriodInputType<TRes> {
  factory CopyWith$Input$OncallRotationActivePeriodInputType(
    Input$OncallRotationActivePeriodInputType instance,
    TRes Function(Input$OncallRotationActivePeriodInputType) then,
  ) = _CopyWithImpl$Input$OncallRotationActivePeriodInputType;

  factory CopyWith$Input$OncallRotationActivePeriodInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallRotationActivePeriodInputType;

  TRes call({
    String? startTime,
    String? endTime,
  });
}

class _CopyWithImpl$Input$OncallRotationActivePeriodInputType<TRes>
    implements CopyWith$Input$OncallRotationActivePeriodInputType<TRes> {
  _CopyWithImpl$Input$OncallRotationActivePeriodInputType(
    this._instance,
    this._then,
  );

  final Input$OncallRotationActivePeriodInputType _instance;

  final TRes Function(Input$OncallRotationActivePeriodInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? startTime = _undefined,
    Object? endTime = _undefined,
  }) =>
      _then(Input$OncallRotationActivePeriodInputType._({
        ..._instance._$data,
        if (startTime != _undefined && startTime != null)
          'startTime': (startTime as String),
        if (endTime != _undefined && endTime != null)
          'endTime': (endTime as String),
      }));
}

class _CopyWithStubImpl$Input$OncallRotationActivePeriodInputType<TRes>
    implements CopyWith$Input$OncallRotationActivePeriodInputType<TRes> {
  _CopyWithStubImpl$Input$OncallRotationActivePeriodInputType(this._res);

  TRes _res;

  call({
    String? startTime,
    String? endTime,
  }) =>
      _res;
}

class Input$OncallRotationCreateInput {
  factory Input$OncallRotationCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String scheduleIid,
    required String name,
    required Input$OncallRotationDateInputType startsAt,
    Input$OncallRotationDateInputType? endsAt,
    required Input$OncallRotationLengthInputType rotationLength,
    Input$OncallRotationActivePeriodInputType? activePeriod,
    required List<Input$OncallUserInputType> participants,
  }) =>
      Input$OncallRotationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'scheduleIid': scheduleIid,
        r'name': name,
        r'startsAt': startsAt,
        if (endsAt != null) r'endsAt': endsAt,
        r'rotationLength': rotationLength,
        if (activePeriod != null) r'activePeriod': activePeriod,
        r'participants': participants,
      });

  Input$OncallRotationCreateInput._(this._$data);

  factory Input$OncallRotationCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$scheduleIid = data['scheduleIid'];
    result$data['scheduleIid'] = (l$scheduleIid as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$startsAt = data['startsAt'];
    result$data['startsAt'] = Input$OncallRotationDateInputType.fromJson(
        (l$startsAt as Map<String, dynamic>));
    if (data.containsKey('endsAt')) {
      final l$endsAt = data['endsAt'];
      result$data['endsAt'] = l$endsAt == null
          ? null
          : Input$OncallRotationDateInputType.fromJson(
              (l$endsAt as Map<String, dynamic>));
    }
    final l$rotationLength = data['rotationLength'];
    result$data['rotationLength'] =
        Input$OncallRotationLengthInputType.fromJson(
            (l$rotationLength as Map<String, dynamic>));
    if (data.containsKey('activePeriod')) {
      final l$activePeriod = data['activePeriod'];
      result$data['activePeriod'] = l$activePeriod == null
          ? null
          : Input$OncallRotationActivePeriodInputType.fromJson(
              (l$activePeriod as Map<String, dynamic>));
    }
    final l$participants = data['participants'];
    result$data['participants'] = (l$participants as List<dynamic>)
        .map((e) =>
            Input$OncallUserInputType.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$OncallRotationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get scheduleIid => (_$data['scheduleIid'] as String);
  String get name => (_$data['name'] as String);
  Input$OncallRotationDateInputType get startsAt =>
      (_$data['startsAt'] as Input$OncallRotationDateInputType);
  Input$OncallRotationDateInputType? get endsAt =>
      (_$data['endsAt'] as Input$OncallRotationDateInputType?);
  Input$OncallRotationLengthInputType get rotationLength =>
      (_$data['rotationLength'] as Input$OncallRotationLengthInputType);
  Input$OncallRotationActivePeriodInputType? get activePeriod =>
      (_$data['activePeriod'] as Input$OncallRotationActivePeriodInputType?);
  List<Input$OncallUserInputType> get participants =>
      (_$data['participants'] as List<Input$OncallUserInputType>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$scheduleIid = scheduleIid;
    result$data['scheduleIid'] = l$scheduleIid;
    final l$name = name;
    result$data['name'] = l$name;
    final l$startsAt = startsAt;
    result$data['startsAt'] = l$startsAt.toJson();
    if (_$data.containsKey('endsAt')) {
      final l$endsAt = endsAt;
      result$data['endsAt'] = l$endsAt?.toJson();
    }
    final l$rotationLength = rotationLength;
    result$data['rotationLength'] = l$rotationLength.toJson();
    if (_$data.containsKey('activePeriod')) {
      final l$activePeriod = activePeriod;
      result$data['activePeriod'] = l$activePeriod?.toJson();
    }
    final l$participants = participants;
    result$data['participants'] =
        l$participants.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$OncallRotationCreateInput<Input$OncallRotationCreateInput>
      get copyWith => CopyWith$Input$OncallRotationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallRotationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$scheduleIid = scheduleIid;
    final lOther$scheduleIid = other.scheduleIid;
    if (l$scheduleIid != lOther$scheduleIid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$startsAt = startsAt;
    final lOther$startsAt = other.startsAt;
    if (l$startsAt != lOther$startsAt) {
      return false;
    }
    final l$endsAt = endsAt;
    final lOther$endsAt = other.endsAt;
    if (_$data.containsKey('endsAt') != other._$data.containsKey('endsAt')) {
      return false;
    }
    if (l$endsAt != lOther$endsAt) {
      return false;
    }
    final l$rotationLength = rotationLength;
    final lOther$rotationLength = other.rotationLength;
    if (l$rotationLength != lOther$rotationLength) {
      return false;
    }
    final l$activePeriod = activePeriod;
    final lOther$activePeriod = other.activePeriod;
    if (_$data.containsKey('activePeriod') !=
        other._$data.containsKey('activePeriod')) {
      return false;
    }
    if (l$activePeriod != lOther$activePeriod) {
      return false;
    }
    final l$participants = participants;
    final lOther$participants = other.participants;
    if (l$participants.length != lOther$participants.length) {
      return false;
    }
    for (int i = 0; i < l$participants.length; i++) {
      final l$participants$entry = l$participants[i];
      final lOther$participants$entry = lOther$participants[i];
      if (l$participants$entry != lOther$participants$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$scheduleIid = scheduleIid;
    final l$name = name;
    final l$startsAt = startsAt;
    final l$endsAt = endsAt;
    final l$rotationLength = rotationLength;
    final l$activePeriod = activePeriod;
    final l$participants = participants;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$scheduleIid,
      l$name,
      l$startsAt,
      _$data.containsKey('endsAt') ? l$endsAt : const {},
      l$rotationLength,
      _$data.containsKey('activePeriod') ? l$activePeriod : const {},
      Object.hashAll(l$participants.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$OncallRotationCreateInput<TRes> {
  factory CopyWith$Input$OncallRotationCreateInput(
    Input$OncallRotationCreateInput instance,
    TRes Function(Input$OncallRotationCreateInput) then,
  ) = _CopyWithImpl$Input$OncallRotationCreateInput;

  factory CopyWith$Input$OncallRotationCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallRotationCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? scheduleIid,
    String? name,
    Input$OncallRotationDateInputType? startsAt,
    Input$OncallRotationDateInputType? endsAt,
    Input$OncallRotationLengthInputType? rotationLength,
    Input$OncallRotationActivePeriodInputType? activePeriod,
    List<Input$OncallUserInputType>? participants,
  });
  CopyWith$Input$OncallRotationDateInputType<TRes> get startsAt;
  CopyWith$Input$OncallRotationDateInputType<TRes> get endsAt;
  CopyWith$Input$OncallRotationLengthInputType<TRes> get rotationLength;
  CopyWith$Input$OncallRotationActivePeriodInputType<TRes> get activePeriod;
  TRes participants(
      Iterable<Input$OncallUserInputType> Function(
              Iterable<
                  CopyWith$Input$OncallUserInputType<
                      Input$OncallUserInputType>>)
          _fn);
}

class _CopyWithImpl$Input$OncallRotationCreateInput<TRes>
    implements CopyWith$Input$OncallRotationCreateInput<TRes> {
  _CopyWithImpl$Input$OncallRotationCreateInput(
    this._instance,
    this._then,
  );

  final Input$OncallRotationCreateInput _instance;

  final TRes Function(Input$OncallRotationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? scheduleIid = _undefined,
    Object? name = _undefined,
    Object? startsAt = _undefined,
    Object? endsAt = _undefined,
    Object? rotationLength = _undefined,
    Object? activePeriod = _undefined,
    Object? participants = _undefined,
  }) =>
      _then(Input$OncallRotationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (scheduleIid != _undefined && scheduleIid != null)
          'scheduleIid': (scheduleIid as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (startsAt != _undefined && startsAt != null)
          'startsAt': (startsAt as Input$OncallRotationDateInputType),
        if (endsAt != _undefined)
          'endsAt': (endsAt as Input$OncallRotationDateInputType?),
        if (rotationLength != _undefined && rotationLength != null)
          'rotationLength':
              (rotationLength as Input$OncallRotationLengthInputType),
        if (activePeriod != _undefined)
          'activePeriod':
              (activePeriod as Input$OncallRotationActivePeriodInputType?),
        if (participants != _undefined && participants != null)
          'participants': (participants as List<Input$OncallUserInputType>),
      }));
  CopyWith$Input$OncallRotationDateInputType<TRes> get startsAt {
    final local$startsAt = _instance.startsAt;
    return CopyWith$Input$OncallRotationDateInputType(
        local$startsAt, (e) => call(startsAt: e));
  }

  CopyWith$Input$OncallRotationDateInputType<TRes> get endsAt {
    final local$endsAt = _instance.endsAt;
    return local$endsAt == null
        ? CopyWith$Input$OncallRotationDateInputType.stub(_then(_instance))
        : CopyWith$Input$OncallRotationDateInputType(
            local$endsAt, (e) => call(endsAt: e));
  }

  CopyWith$Input$OncallRotationLengthInputType<TRes> get rotationLength {
    final local$rotationLength = _instance.rotationLength;
    return CopyWith$Input$OncallRotationLengthInputType(
        local$rotationLength, (e) => call(rotationLength: e));
  }

  CopyWith$Input$OncallRotationActivePeriodInputType<TRes> get activePeriod {
    final local$activePeriod = _instance.activePeriod;
    return local$activePeriod == null
        ? CopyWith$Input$OncallRotationActivePeriodInputType.stub(
            _then(_instance))
        : CopyWith$Input$OncallRotationActivePeriodInputType(
            local$activePeriod, (e) => call(activePeriod: e));
  }

  TRes participants(
          Iterable<Input$OncallUserInputType> Function(
                  Iterable<
                      CopyWith$Input$OncallUserInputType<
                          Input$OncallUserInputType>>)
              _fn) =>
      call(
          participants: _fn(_instance.participants
              .map((e) => CopyWith$Input$OncallUserInputType(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$OncallRotationCreateInput<TRes>
    implements CopyWith$Input$OncallRotationCreateInput<TRes> {
  _CopyWithStubImpl$Input$OncallRotationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? scheduleIid,
    String? name,
    Input$OncallRotationDateInputType? startsAt,
    Input$OncallRotationDateInputType? endsAt,
    Input$OncallRotationLengthInputType? rotationLength,
    Input$OncallRotationActivePeriodInputType? activePeriod,
    List<Input$OncallUserInputType>? participants,
  }) =>
      _res;
  CopyWith$Input$OncallRotationDateInputType<TRes> get startsAt =>
      CopyWith$Input$OncallRotationDateInputType.stub(_res);
  CopyWith$Input$OncallRotationDateInputType<TRes> get endsAt =>
      CopyWith$Input$OncallRotationDateInputType.stub(_res);
  CopyWith$Input$OncallRotationLengthInputType<TRes> get rotationLength =>
      CopyWith$Input$OncallRotationLengthInputType.stub(_res);
  CopyWith$Input$OncallRotationActivePeriodInputType<TRes> get activePeriod =>
      CopyWith$Input$OncallRotationActivePeriodInputType.stub(_res);
  participants(_fn) => _res;
}

class Input$OncallRotationDateInputType {
  factory Input$OncallRotationDateInputType({
    required String date,
    required String time,
  }) =>
      Input$OncallRotationDateInputType._({
        r'date': date,
        r'time': time,
      });

  Input$OncallRotationDateInputType._(this._$data);

  factory Input$OncallRotationDateInputType.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$time = data['time'];
    result$data['time'] = (l$time as String);
    return Input$OncallRotationDateInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  String get date => (_$data['date'] as String);
  String get time => (_$data['time'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$date = date;
    result$data['date'] = l$date;
    final l$time = time;
    result$data['time'] = l$time;
    return result$data;
  }

  CopyWith$Input$OncallRotationDateInputType<Input$OncallRotationDateInputType>
      get copyWith => CopyWith$Input$OncallRotationDateInputType(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallRotationDateInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$time = time;
    final lOther$time = other.time;
    if (l$time != lOther$time) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$date = date;
    final l$time = time;
    return Object.hashAll([
      l$date,
      l$time,
    ]);
  }
}

abstract class CopyWith$Input$OncallRotationDateInputType<TRes> {
  factory CopyWith$Input$OncallRotationDateInputType(
    Input$OncallRotationDateInputType instance,
    TRes Function(Input$OncallRotationDateInputType) then,
  ) = _CopyWithImpl$Input$OncallRotationDateInputType;

  factory CopyWith$Input$OncallRotationDateInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallRotationDateInputType;

  TRes call({
    String? date,
    String? time,
  });
}

class _CopyWithImpl$Input$OncallRotationDateInputType<TRes>
    implements CopyWith$Input$OncallRotationDateInputType<TRes> {
  _CopyWithImpl$Input$OncallRotationDateInputType(
    this._instance,
    this._then,
  );

  final Input$OncallRotationDateInputType _instance;

  final TRes Function(Input$OncallRotationDateInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? date = _undefined,
    Object? time = _undefined,
  }) =>
      _then(Input$OncallRotationDateInputType._({
        ..._instance._$data,
        if (date != _undefined && date != null) 'date': (date as String),
        if (time != _undefined && time != null) 'time': (time as String),
      }));
}

class _CopyWithStubImpl$Input$OncallRotationDateInputType<TRes>
    implements CopyWith$Input$OncallRotationDateInputType<TRes> {
  _CopyWithStubImpl$Input$OncallRotationDateInputType(this._res);

  TRes _res;

  call({
    String? date,
    String? time,
  }) =>
      _res;
}

class Input$OncallRotationDestroyInput {
  factory Input$OncallRotationDestroyInput({
    String? clientMutationId,
    required String projectPath,
    required String scheduleIid,
    required String id,
  }) =>
      Input$OncallRotationDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'scheduleIid': scheduleIid,
        r'id': id,
      });

  Input$OncallRotationDestroyInput._(this._$data);

  factory Input$OncallRotationDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$scheduleIid = data['scheduleIid'];
    result$data['scheduleIid'] = (l$scheduleIid as String);
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$OncallRotationDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get scheduleIid => (_$data['scheduleIid'] as String);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$scheduleIid = scheduleIid;
    result$data['scheduleIid'] = l$scheduleIid;
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$OncallRotationDestroyInput<Input$OncallRotationDestroyInput>
      get copyWith => CopyWith$Input$OncallRotationDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallRotationDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$scheduleIid = scheduleIid;
    final lOther$scheduleIid = other.scheduleIid;
    if (l$scheduleIid != lOther$scheduleIid) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$scheduleIid = scheduleIid;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$scheduleIid,
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$OncallRotationDestroyInput<TRes> {
  factory CopyWith$Input$OncallRotationDestroyInput(
    Input$OncallRotationDestroyInput instance,
    TRes Function(Input$OncallRotationDestroyInput) then,
  ) = _CopyWithImpl$Input$OncallRotationDestroyInput;

  factory CopyWith$Input$OncallRotationDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallRotationDestroyInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? scheduleIid,
    String? id,
  });
}

class _CopyWithImpl$Input$OncallRotationDestroyInput<TRes>
    implements CopyWith$Input$OncallRotationDestroyInput<TRes> {
  _CopyWithImpl$Input$OncallRotationDestroyInput(
    this._instance,
    this._then,
  );

  final Input$OncallRotationDestroyInput _instance;

  final TRes Function(Input$OncallRotationDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? scheduleIid = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$OncallRotationDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (scheduleIid != _undefined && scheduleIid != null)
          'scheduleIid': (scheduleIid as String),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$OncallRotationDestroyInput<TRes>
    implements CopyWith$Input$OncallRotationDestroyInput<TRes> {
  _CopyWithStubImpl$Input$OncallRotationDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? scheduleIid,
    String? id,
  }) =>
      _res;
}

class Input$OncallRotationLengthInputType {
  factory Input$OncallRotationLengthInputType({
    required int length,
    required Enum$OncallRotationUnitEnum unit,
  }) =>
      Input$OncallRotationLengthInputType._({
        r'length': length,
        r'unit': unit,
      });

  Input$OncallRotationLengthInputType._(this._$data);

  factory Input$OncallRotationLengthInputType.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$length = data['length'];
    result$data['length'] = (l$length as int);
    final l$unit = data['unit'];
    result$data['unit'] =
        fromJson$Enum$OncallRotationUnitEnum((l$unit as String));
    return Input$OncallRotationLengthInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  int get length => (_$data['length'] as int);
  Enum$OncallRotationUnitEnum get unit =>
      (_$data['unit'] as Enum$OncallRotationUnitEnum);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$length = length;
    result$data['length'] = l$length;
    final l$unit = unit;
    result$data['unit'] = toJson$Enum$OncallRotationUnitEnum(l$unit);
    return result$data;
  }

  CopyWith$Input$OncallRotationLengthInputType<
          Input$OncallRotationLengthInputType>
      get copyWith => CopyWith$Input$OncallRotationLengthInputType(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallRotationLengthInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$length = length;
    final lOther$length = other.length;
    if (l$length != lOther$length) {
      return false;
    }
    final l$unit = unit;
    final lOther$unit = other.unit;
    if (l$unit != lOther$unit) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$length = length;
    final l$unit = unit;
    return Object.hashAll([
      l$length,
      l$unit,
    ]);
  }
}

abstract class CopyWith$Input$OncallRotationLengthInputType<TRes> {
  factory CopyWith$Input$OncallRotationLengthInputType(
    Input$OncallRotationLengthInputType instance,
    TRes Function(Input$OncallRotationLengthInputType) then,
  ) = _CopyWithImpl$Input$OncallRotationLengthInputType;

  factory CopyWith$Input$OncallRotationLengthInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallRotationLengthInputType;

  TRes call({
    int? length,
    Enum$OncallRotationUnitEnum? unit,
  });
}

class _CopyWithImpl$Input$OncallRotationLengthInputType<TRes>
    implements CopyWith$Input$OncallRotationLengthInputType<TRes> {
  _CopyWithImpl$Input$OncallRotationLengthInputType(
    this._instance,
    this._then,
  );

  final Input$OncallRotationLengthInputType _instance;

  final TRes Function(Input$OncallRotationLengthInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? length = _undefined,
    Object? unit = _undefined,
  }) =>
      _then(Input$OncallRotationLengthInputType._({
        ..._instance._$data,
        if (length != _undefined && length != null) 'length': (length as int),
        if (unit != _undefined && unit != null)
          'unit': (unit as Enum$OncallRotationUnitEnum),
      }));
}

class _CopyWithStubImpl$Input$OncallRotationLengthInputType<TRes>
    implements CopyWith$Input$OncallRotationLengthInputType<TRes> {
  _CopyWithStubImpl$Input$OncallRotationLengthInputType(this._res);

  TRes _res;

  call({
    int? length,
    Enum$OncallRotationUnitEnum? unit,
  }) =>
      _res;
}

class Input$OncallRotationUpdateInput {
  factory Input$OncallRotationUpdateInput({
    String? clientMutationId,
    required String id,
    String? name,
    Input$OncallRotationDateInputType? startsAt,
    Input$OncallRotationDateInputType? endsAt,
    Input$OncallRotationLengthInputType? rotationLength,
    Input$OncallRotationActivePeriodInputType? activePeriod,
    List<Input$OncallUserInputType>? participants,
  }) =>
      Input$OncallRotationUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (name != null) r'name': name,
        if (startsAt != null) r'startsAt': startsAt,
        if (endsAt != null) r'endsAt': endsAt,
        if (rotationLength != null) r'rotationLength': rotationLength,
        if (activePeriod != null) r'activePeriod': activePeriod,
        if (participants != null) r'participants': participants,
      });

  Input$OncallRotationUpdateInput._(this._$data);

  factory Input$OncallRotationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('startsAt')) {
      final l$startsAt = data['startsAt'];
      result$data['startsAt'] = l$startsAt == null
          ? null
          : Input$OncallRotationDateInputType.fromJson(
              (l$startsAt as Map<String, dynamic>));
    }
    if (data.containsKey('endsAt')) {
      final l$endsAt = data['endsAt'];
      result$data['endsAt'] = l$endsAt == null
          ? null
          : Input$OncallRotationDateInputType.fromJson(
              (l$endsAt as Map<String, dynamic>));
    }
    if (data.containsKey('rotationLength')) {
      final l$rotationLength = data['rotationLength'];
      result$data['rotationLength'] = l$rotationLength == null
          ? null
          : Input$OncallRotationLengthInputType.fromJson(
              (l$rotationLength as Map<String, dynamic>));
    }
    if (data.containsKey('activePeriod')) {
      final l$activePeriod = data['activePeriod'];
      result$data['activePeriod'] = l$activePeriod == null
          ? null
          : Input$OncallRotationActivePeriodInputType.fromJson(
              (l$activePeriod as Map<String, dynamic>));
    }
    if (data.containsKey('participants')) {
      final l$participants = data['participants'];
      result$data['participants'] = (l$participants as List<dynamic>?)
          ?.map((e) =>
              Input$OncallUserInputType.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OncallRotationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get name => (_$data['name'] as String?);
  Input$OncallRotationDateInputType? get startsAt =>
      (_$data['startsAt'] as Input$OncallRotationDateInputType?);
  Input$OncallRotationDateInputType? get endsAt =>
      (_$data['endsAt'] as Input$OncallRotationDateInputType?);
  Input$OncallRotationLengthInputType? get rotationLength =>
      (_$data['rotationLength'] as Input$OncallRotationLengthInputType?);
  Input$OncallRotationActivePeriodInputType? get activePeriod =>
      (_$data['activePeriod'] as Input$OncallRotationActivePeriodInputType?);
  List<Input$OncallUserInputType>? get participants =>
      (_$data['participants'] as List<Input$OncallUserInputType>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('startsAt')) {
      final l$startsAt = startsAt;
      result$data['startsAt'] = l$startsAt?.toJson();
    }
    if (_$data.containsKey('endsAt')) {
      final l$endsAt = endsAt;
      result$data['endsAt'] = l$endsAt?.toJson();
    }
    if (_$data.containsKey('rotationLength')) {
      final l$rotationLength = rotationLength;
      result$data['rotationLength'] = l$rotationLength?.toJson();
    }
    if (_$data.containsKey('activePeriod')) {
      final l$activePeriod = activePeriod;
      result$data['activePeriod'] = l$activePeriod?.toJson();
    }
    if (_$data.containsKey('participants')) {
      final l$participants = participants;
      result$data['participants'] =
          l$participants?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OncallRotationUpdateInput<Input$OncallRotationUpdateInput>
      get copyWith => CopyWith$Input$OncallRotationUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallRotationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$startsAt = startsAt;
    final lOther$startsAt = other.startsAt;
    if (_$data.containsKey('startsAt') !=
        other._$data.containsKey('startsAt')) {
      return false;
    }
    if (l$startsAt != lOther$startsAt) {
      return false;
    }
    final l$endsAt = endsAt;
    final lOther$endsAt = other.endsAt;
    if (_$data.containsKey('endsAt') != other._$data.containsKey('endsAt')) {
      return false;
    }
    if (l$endsAt != lOther$endsAt) {
      return false;
    }
    final l$rotationLength = rotationLength;
    final lOther$rotationLength = other.rotationLength;
    if (_$data.containsKey('rotationLength') !=
        other._$data.containsKey('rotationLength')) {
      return false;
    }
    if (l$rotationLength != lOther$rotationLength) {
      return false;
    }
    final l$activePeriod = activePeriod;
    final lOther$activePeriod = other.activePeriod;
    if (_$data.containsKey('activePeriod') !=
        other._$data.containsKey('activePeriod')) {
      return false;
    }
    if (l$activePeriod != lOther$activePeriod) {
      return false;
    }
    final l$participants = participants;
    final lOther$participants = other.participants;
    if (_$data.containsKey('participants') !=
        other._$data.containsKey('participants')) {
      return false;
    }
    if (l$participants != null && lOther$participants != null) {
      if (l$participants.length != lOther$participants.length) {
        return false;
      }
      for (int i = 0; i < l$participants.length; i++) {
        final l$participants$entry = l$participants[i];
        final lOther$participants$entry = lOther$participants[i];
        if (l$participants$entry != lOther$participants$entry) {
          return false;
        }
      }
    } else if (l$participants != lOther$participants) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$name = name;
    final l$startsAt = startsAt;
    final l$endsAt = endsAt;
    final l$rotationLength = rotationLength;
    final l$activePeriod = activePeriod;
    final l$participants = participants;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('startsAt') ? l$startsAt : const {},
      _$data.containsKey('endsAt') ? l$endsAt : const {},
      _$data.containsKey('rotationLength') ? l$rotationLength : const {},
      _$data.containsKey('activePeriod') ? l$activePeriod : const {},
      _$data.containsKey('participants')
          ? l$participants == null
              ? null
              : Object.hashAll(l$participants.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OncallRotationUpdateInput<TRes> {
  factory CopyWith$Input$OncallRotationUpdateInput(
    Input$OncallRotationUpdateInput instance,
    TRes Function(Input$OncallRotationUpdateInput) then,
  ) = _CopyWithImpl$Input$OncallRotationUpdateInput;

  factory CopyWith$Input$OncallRotationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallRotationUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? name,
    Input$OncallRotationDateInputType? startsAt,
    Input$OncallRotationDateInputType? endsAt,
    Input$OncallRotationLengthInputType? rotationLength,
    Input$OncallRotationActivePeriodInputType? activePeriod,
    List<Input$OncallUserInputType>? participants,
  });
  CopyWith$Input$OncallRotationDateInputType<TRes> get startsAt;
  CopyWith$Input$OncallRotationDateInputType<TRes> get endsAt;
  CopyWith$Input$OncallRotationLengthInputType<TRes> get rotationLength;
  CopyWith$Input$OncallRotationActivePeriodInputType<TRes> get activePeriod;
  TRes participants(
      Iterable<Input$OncallUserInputType>? Function(
              Iterable<
                  CopyWith$Input$OncallUserInputType<
                      Input$OncallUserInputType>>?)
          _fn);
}

class _CopyWithImpl$Input$OncallRotationUpdateInput<TRes>
    implements CopyWith$Input$OncallRotationUpdateInput<TRes> {
  _CopyWithImpl$Input$OncallRotationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OncallRotationUpdateInput _instance;

  final TRes Function(Input$OncallRotationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? startsAt = _undefined,
    Object? endsAt = _undefined,
    Object? rotationLength = _undefined,
    Object? activePeriod = _undefined,
    Object? participants = _undefined,
  }) =>
      _then(Input$OncallRotationUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined) 'name': (name as String?),
        if (startsAt != _undefined)
          'startsAt': (startsAt as Input$OncallRotationDateInputType?),
        if (endsAt != _undefined)
          'endsAt': (endsAt as Input$OncallRotationDateInputType?),
        if (rotationLength != _undefined)
          'rotationLength':
              (rotationLength as Input$OncallRotationLengthInputType?),
        if (activePeriod != _undefined)
          'activePeriod':
              (activePeriod as Input$OncallRotationActivePeriodInputType?),
        if (participants != _undefined)
          'participants': (participants as List<Input$OncallUserInputType>?),
      }));
  CopyWith$Input$OncallRotationDateInputType<TRes> get startsAt {
    final local$startsAt = _instance.startsAt;
    return local$startsAt == null
        ? CopyWith$Input$OncallRotationDateInputType.stub(_then(_instance))
        : CopyWith$Input$OncallRotationDateInputType(
            local$startsAt, (e) => call(startsAt: e));
  }

  CopyWith$Input$OncallRotationDateInputType<TRes> get endsAt {
    final local$endsAt = _instance.endsAt;
    return local$endsAt == null
        ? CopyWith$Input$OncallRotationDateInputType.stub(_then(_instance))
        : CopyWith$Input$OncallRotationDateInputType(
            local$endsAt, (e) => call(endsAt: e));
  }

  CopyWith$Input$OncallRotationLengthInputType<TRes> get rotationLength {
    final local$rotationLength = _instance.rotationLength;
    return local$rotationLength == null
        ? CopyWith$Input$OncallRotationLengthInputType.stub(_then(_instance))
        : CopyWith$Input$OncallRotationLengthInputType(
            local$rotationLength, (e) => call(rotationLength: e));
  }

  CopyWith$Input$OncallRotationActivePeriodInputType<TRes> get activePeriod {
    final local$activePeriod = _instance.activePeriod;
    return local$activePeriod == null
        ? CopyWith$Input$OncallRotationActivePeriodInputType.stub(
            _then(_instance))
        : CopyWith$Input$OncallRotationActivePeriodInputType(
            local$activePeriod, (e) => call(activePeriod: e));
  }

  TRes participants(
          Iterable<Input$OncallUserInputType>? Function(
                  Iterable<
                      CopyWith$Input$OncallUserInputType<
                          Input$OncallUserInputType>>?)
              _fn) =>
      call(
          participants: _fn(_instance.participants
              ?.map((e) => CopyWith$Input$OncallUserInputType(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OncallRotationUpdateInput<TRes>
    implements CopyWith$Input$OncallRotationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OncallRotationUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? name,
    Input$OncallRotationDateInputType? startsAt,
    Input$OncallRotationDateInputType? endsAt,
    Input$OncallRotationLengthInputType? rotationLength,
    Input$OncallRotationActivePeriodInputType? activePeriod,
    List<Input$OncallUserInputType>? participants,
  }) =>
      _res;
  CopyWith$Input$OncallRotationDateInputType<TRes> get startsAt =>
      CopyWith$Input$OncallRotationDateInputType.stub(_res);
  CopyWith$Input$OncallRotationDateInputType<TRes> get endsAt =>
      CopyWith$Input$OncallRotationDateInputType.stub(_res);
  CopyWith$Input$OncallRotationLengthInputType<TRes> get rotationLength =>
      CopyWith$Input$OncallRotationLengthInputType.stub(_res);
  CopyWith$Input$OncallRotationActivePeriodInputType<TRes> get activePeriod =>
      CopyWith$Input$OncallRotationActivePeriodInputType.stub(_res);
  participants(_fn) => _res;
}

class Input$OncallScheduleCreateInput {
  factory Input$OncallScheduleCreateInput({
    String? clientMutationId,
    required String projectPath,
    required String name,
    String? description,
    required String timezone,
  }) =>
      Input$OncallScheduleCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'name': name,
        if (description != null) r'description': description,
        r'timezone': timezone,
      });

  Input$OncallScheduleCreateInput._(this._$data);

  factory Input$OncallScheduleCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$timezone = data['timezone'];
    result$data['timezone'] = (l$timezone as String);
    return Input$OncallScheduleCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get name => (_$data['name'] as String);
  String? get description => (_$data['description'] as String?);
  String get timezone => (_$data['timezone'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$timezone = timezone;
    result$data['timezone'] = l$timezone;
    return result$data;
  }

  CopyWith$Input$OncallScheduleCreateInput<Input$OncallScheduleCreateInput>
      get copyWith => CopyWith$Input$OncallScheduleCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallScheduleCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$name = name;
    final l$description = description;
    final l$timezone = timezone;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      l$timezone,
    ]);
  }
}

abstract class CopyWith$Input$OncallScheduleCreateInput<TRes> {
  factory CopyWith$Input$OncallScheduleCreateInput(
    Input$OncallScheduleCreateInput instance,
    TRes Function(Input$OncallScheduleCreateInput) then,
  ) = _CopyWithImpl$Input$OncallScheduleCreateInput;

  factory CopyWith$Input$OncallScheduleCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallScheduleCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    String? description,
    String? timezone,
  });
}

class _CopyWithImpl$Input$OncallScheduleCreateInput<TRes>
    implements CopyWith$Input$OncallScheduleCreateInput<TRes> {
  _CopyWithImpl$Input$OncallScheduleCreateInput(
    this._instance,
    this._then,
  );

  final Input$OncallScheduleCreateInput _instance;

  final TRes Function(Input$OncallScheduleCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$OncallScheduleCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined) 'description': (description as String?),
        if (timezone != _undefined && timezone != null)
          'timezone': (timezone as String),
      }));
}

class _CopyWithStubImpl$Input$OncallScheduleCreateInput<TRes>
    implements CopyWith$Input$OncallScheduleCreateInput<TRes> {
  _CopyWithStubImpl$Input$OncallScheduleCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? name,
    String? description,
    String? timezone,
  }) =>
      _res;
}

class Input$OncallScheduleDestroyInput {
  factory Input$OncallScheduleDestroyInput({
    String? clientMutationId,
    required String projectPath,
    required String iid,
  }) =>
      Input$OncallScheduleDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'iid': iid,
      });

  Input$OncallScheduleDestroyInput._(this._$data);

  factory Input$OncallScheduleDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    return Input$OncallScheduleDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    return result$data;
  }

  CopyWith$Input$OncallScheduleDestroyInput<Input$OncallScheduleDestroyInput>
      get copyWith => CopyWith$Input$OncallScheduleDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallScheduleDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$iid = iid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$iid,
    ]);
  }
}

abstract class CopyWith$Input$OncallScheduleDestroyInput<TRes> {
  factory CopyWith$Input$OncallScheduleDestroyInput(
    Input$OncallScheduleDestroyInput instance,
    TRes Function(Input$OncallScheduleDestroyInput) then,
  ) = _CopyWithImpl$Input$OncallScheduleDestroyInput;

  factory CopyWith$Input$OncallScheduleDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallScheduleDestroyInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? iid,
  });
}

class _CopyWithImpl$Input$OncallScheduleDestroyInput<TRes>
    implements CopyWith$Input$OncallScheduleDestroyInput<TRes> {
  _CopyWithImpl$Input$OncallScheduleDestroyInput(
    this._instance,
    this._then,
  );

  final Input$OncallScheduleDestroyInput _instance;

  final TRes Function(Input$OncallScheduleDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? iid = _undefined,
  }) =>
      _then(Input$OncallScheduleDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
      }));
}

class _CopyWithStubImpl$Input$OncallScheduleDestroyInput<TRes>
    implements CopyWith$Input$OncallScheduleDestroyInput<TRes> {
  _CopyWithStubImpl$Input$OncallScheduleDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? iid,
  }) =>
      _res;
}

class Input$OncallScheduleUpdateInput {
  factory Input$OncallScheduleUpdateInput({
    String? clientMutationId,
    required String projectPath,
    required String iid,
    String? name,
    String? description,
    String? timezone,
  }) =>
      Input$OncallScheduleUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'iid': iid,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (timezone != null) r'timezone': timezone,
      });

  Input$OncallScheduleUpdateInput._(this._$data);

  factory Input$OncallScheduleUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$OncallScheduleUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get timezone => (_$data['timezone'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$OncallScheduleUpdateInput<Input$OncallScheduleUpdateInput>
      get copyWith => CopyWith$Input$OncallScheduleUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallScheduleUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$name = name;
    final l$description = description;
    final l$timezone = timezone;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$iid,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$OncallScheduleUpdateInput<TRes> {
  factory CopyWith$Input$OncallScheduleUpdateInput(
    Input$OncallScheduleUpdateInput instance,
    TRes Function(Input$OncallScheduleUpdateInput) then,
  ) = _CopyWithImpl$Input$OncallScheduleUpdateInput;

  factory CopyWith$Input$OncallScheduleUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallScheduleUpdateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? iid,
    String? name,
    String? description,
    String? timezone,
  });
}

class _CopyWithImpl$Input$OncallScheduleUpdateInput<TRes>
    implements CopyWith$Input$OncallScheduleUpdateInput<TRes> {
  _CopyWithImpl$Input$OncallScheduleUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OncallScheduleUpdateInput _instance;

  final TRes Function(Input$OncallScheduleUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$OncallScheduleUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$OncallScheduleUpdateInput<TRes>
    implements CopyWith$Input$OncallScheduleUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OncallScheduleUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? iid,
    String? name,
    String? description,
    String? timezone,
  }) =>
      _res;
}

class Input$OncallUserInputType {
  factory Input$OncallUserInputType({
    required String username,
    Enum$DataVisualizationColorEnum? colorPalette,
    Enum$DataVisualizationWeightEnum? colorWeight,
  }) =>
      Input$OncallUserInputType._({
        r'username': username,
        if (colorPalette != null) r'colorPalette': colorPalette,
        if (colorWeight != null) r'colorWeight': colorWeight,
      });

  Input$OncallUserInputType._(this._$data);

  factory Input$OncallUserInputType.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$username = data['username'];
    result$data['username'] = (l$username as String);
    if (data.containsKey('colorPalette')) {
      final l$colorPalette = data['colorPalette'];
      result$data['colorPalette'] = l$colorPalette == null
          ? null
          : fromJson$Enum$DataVisualizationColorEnum(
              (l$colorPalette as String));
    }
    if (data.containsKey('colorWeight')) {
      final l$colorWeight = data['colorWeight'];
      result$data['colorWeight'] = l$colorWeight == null
          ? null
          : fromJson$Enum$DataVisualizationWeightEnum(
              (l$colorWeight as String));
    }
    return Input$OncallUserInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  String get username => (_$data['username'] as String);
  Enum$DataVisualizationColorEnum? get colorPalette =>
      (_$data['colorPalette'] as Enum$DataVisualizationColorEnum?);
  Enum$DataVisualizationWeightEnum? get colorWeight =>
      (_$data['colorWeight'] as Enum$DataVisualizationWeightEnum?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$username = username;
    result$data['username'] = l$username;
    if (_$data.containsKey('colorPalette')) {
      final l$colorPalette = colorPalette;
      result$data['colorPalette'] = l$colorPalette == null
          ? null
          : toJson$Enum$DataVisualizationColorEnum(l$colorPalette);
    }
    if (_$data.containsKey('colorWeight')) {
      final l$colorWeight = colorWeight;
      result$data['colorWeight'] = l$colorWeight == null
          ? null
          : toJson$Enum$DataVisualizationWeightEnum(l$colorWeight);
    }
    return result$data;
  }

  CopyWith$Input$OncallUserInputType<Input$OncallUserInputType> get copyWith =>
      CopyWith$Input$OncallUserInputType(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OncallUserInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$username = username;
    final lOther$username = other.username;
    if (l$username != lOther$username) {
      return false;
    }
    final l$colorPalette = colorPalette;
    final lOther$colorPalette = other.colorPalette;
    if (_$data.containsKey('colorPalette') !=
        other._$data.containsKey('colorPalette')) {
      return false;
    }
    if (l$colorPalette != lOther$colorPalette) {
      return false;
    }
    final l$colorWeight = colorWeight;
    final lOther$colorWeight = other.colorWeight;
    if (_$data.containsKey('colorWeight') !=
        other._$data.containsKey('colorWeight')) {
      return false;
    }
    if (l$colorWeight != lOther$colorWeight) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$username = username;
    final l$colorPalette = colorPalette;
    final l$colorWeight = colorWeight;
    return Object.hashAll([
      l$username,
      _$data.containsKey('colorPalette') ? l$colorPalette : const {},
      _$data.containsKey('colorWeight') ? l$colorWeight : const {},
    ]);
  }
}

abstract class CopyWith$Input$OncallUserInputType<TRes> {
  factory CopyWith$Input$OncallUserInputType(
    Input$OncallUserInputType instance,
    TRes Function(Input$OncallUserInputType) then,
  ) = _CopyWithImpl$Input$OncallUserInputType;

  factory CopyWith$Input$OncallUserInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$OncallUserInputType;

  TRes call({
    String? username,
    Enum$DataVisualizationColorEnum? colorPalette,
    Enum$DataVisualizationWeightEnum? colorWeight,
  });
}

class _CopyWithImpl$Input$OncallUserInputType<TRes>
    implements CopyWith$Input$OncallUserInputType<TRes> {
  _CopyWithImpl$Input$OncallUserInputType(
    this._instance,
    this._then,
  );

  final Input$OncallUserInputType _instance;

  final TRes Function(Input$OncallUserInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? username = _undefined,
    Object? colorPalette = _undefined,
    Object? colorWeight = _undefined,
  }) =>
      _then(Input$OncallUserInputType._({
        ..._instance._$data,
        if (username != _undefined && username != null)
          'username': (username as String),
        if (colorPalette != _undefined)
          'colorPalette': (colorPalette as Enum$DataVisualizationColorEnum?),
        if (colorWeight != _undefined)
          'colorWeight': (colorWeight as Enum$DataVisualizationWeightEnum?),
      }));
}

class _CopyWithStubImpl$Input$OncallUserInputType<TRes>
    implements CopyWith$Input$OncallUserInputType<TRes> {
  _CopyWithStubImpl$Input$OncallUserInputType(this._res);

  TRes _res;

  call({
    String? username,
    Enum$DataVisualizationColorEnum? colorPalette,
    Enum$DataVisualizationWeightEnum? colorWeight,
  }) =>
      _res;
}

class Input$PagesMarkOnboardingCompleteInput {
  factory Input$PagesMarkOnboardingCompleteInput({
    required String projectPath,
    String? clientMutationId,
  }) =>
      Input$PagesMarkOnboardingCompleteInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$PagesMarkOnboardingCompleteInput._(this._$data);

  factory Input$PagesMarkOnboardingCompleteInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$PagesMarkOnboardingCompleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$PagesMarkOnboardingCompleteInput<
          Input$PagesMarkOnboardingCompleteInput>
      get copyWith => CopyWith$Input$PagesMarkOnboardingCompleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PagesMarkOnboardingCompleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PagesMarkOnboardingCompleteInput<TRes> {
  factory CopyWith$Input$PagesMarkOnboardingCompleteInput(
    Input$PagesMarkOnboardingCompleteInput instance,
    TRes Function(Input$PagesMarkOnboardingCompleteInput) then,
  ) = _CopyWithImpl$Input$PagesMarkOnboardingCompleteInput;

  factory CopyWith$Input$PagesMarkOnboardingCompleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PagesMarkOnboardingCompleteInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$PagesMarkOnboardingCompleteInput<TRes>
    implements CopyWith$Input$PagesMarkOnboardingCompleteInput<TRes> {
  _CopyWithImpl$Input$PagesMarkOnboardingCompleteInput(
    this._instance,
    this._then,
  );

  final Input$PagesMarkOnboardingCompleteInput _instance;

  final TRes Function(Input$PagesMarkOnboardingCompleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$PagesMarkOnboardingCompleteInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$PagesMarkOnboardingCompleteInput<TRes>
    implements CopyWith$Input$PagesMarkOnboardingCompleteInput<TRes> {
  _CopyWithStubImpl$Input$PagesMarkOnboardingCompleteInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$PipelineCancelInput {
  factory Input$PipelineCancelInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$PipelineCancelInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$PipelineCancelInput._(this._$data);

  factory Input$PipelineCancelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$PipelineCancelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$PipelineCancelInput<Input$PipelineCancelInput> get copyWith =>
      CopyWith$Input$PipelineCancelInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PipelineCancelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PipelineCancelInput<TRes> {
  factory CopyWith$Input$PipelineCancelInput(
    Input$PipelineCancelInput instance,
    TRes Function(Input$PipelineCancelInput) then,
  ) = _CopyWithImpl$Input$PipelineCancelInput;

  factory CopyWith$Input$PipelineCancelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PipelineCancelInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$PipelineCancelInput<TRes>
    implements CopyWith$Input$PipelineCancelInput<TRes> {
  _CopyWithImpl$Input$PipelineCancelInput(
    this._instance,
    this._then,
  );

  final Input$PipelineCancelInput _instance;

  final TRes Function(Input$PipelineCancelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$PipelineCancelInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$PipelineCancelInput<TRes>
    implements CopyWith$Input$PipelineCancelInput<TRes> {
  _CopyWithStubImpl$Input$PipelineCancelInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$PipelineDestroyInput {
  factory Input$PipelineDestroyInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$PipelineDestroyInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$PipelineDestroyInput._(this._$data);

  factory Input$PipelineDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$PipelineDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$PipelineDestroyInput<Input$PipelineDestroyInput>
      get copyWith => CopyWith$Input$PipelineDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PipelineDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PipelineDestroyInput<TRes> {
  factory CopyWith$Input$PipelineDestroyInput(
    Input$PipelineDestroyInput instance,
    TRes Function(Input$PipelineDestroyInput) then,
  ) = _CopyWithImpl$Input$PipelineDestroyInput;

  factory CopyWith$Input$PipelineDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PipelineDestroyInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$PipelineDestroyInput<TRes>
    implements CopyWith$Input$PipelineDestroyInput<TRes> {
  _CopyWithImpl$Input$PipelineDestroyInput(
    this._instance,
    this._then,
  );

  final Input$PipelineDestroyInput _instance;

  final TRes Function(Input$PipelineDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$PipelineDestroyInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$PipelineDestroyInput<TRes>
    implements CopyWith$Input$PipelineDestroyInput<TRes> {
  _CopyWithStubImpl$Input$PipelineDestroyInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$PipelineRetryInput {
  factory Input$PipelineRetryInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$PipelineRetryInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$PipelineRetryInput._(this._$data);

  factory Input$PipelineRetryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$PipelineRetryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$PipelineRetryInput<Input$PipelineRetryInput> get copyWith =>
      CopyWith$Input$PipelineRetryInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PipelineRetryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PipelineRetryInput<TRes> {
  factory CopyWith$Input$PipelineRetryInput(
    Input$PipelineRetryInput instance,
    TRes Function(Input$PipelineRetryInput) then,
  ) = _CopyWithImpl$Input$PipelineRetryInput;

  factory CopyWith$Input$PipelineRetryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PipelineRetryInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$PipelineRetryInput<TRes>
    implements CopyWith$Input$PipelineRetryInput<TRes> {
  _CopyWithImpl$Input$PipelineRetryInput(
    this._instance,
    this._then,
  );

  final Input$PipelineRetryInput _instance;

  final TRes Function(Input$PipelineRetryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$PipelineRetryInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$PipelineRetryInput<TRes>
    implements CopyWith$Input$PipelineRetryInput<TRes> {
  _CopyWithStubImpl$Input$PipelineRetryInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ProjectCiCdSettingsUpdateInput {
  factory Input$ProjectCiCdSettingsUpdateInput({
    String? clientMutationId,
    required String fullPath,
    bool? keepLatestArtifact,
    bool? jobTokenScopeEnabled,
    bool? mergePipelinesEnabled,
    bool? mergeTrainsEnabled,
  }) =>
      Input$ProjectCiCdSettingsUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fullPath': fullPath,
        if (keepLatestArtifact != null)
          r'keepLatestArtifact': keepLatestArtifact,
        if (jobTokenScopeEnabled != null)
          r'jobTokenScopeEnabled': jobTokenScopeEnabled,
        if (mergePipelinesEnabled != null)
          r'mergePipelinesEnabled': mergePipelinesEnabled,
        if (mergeTrainsEnabled != null)
          r'mergeTrainsEnabled': mergeTrainsEnabled,
      });

  Input$ProjectCiCdSettingsUpdateInput._(this._$data);

  factory Input$ProjectCiCdSettingsUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fullPath = data['fullPath'];
    result$data['fullPath'] = (l$fullPath as String);
    if (data.containsKey('keepLatestArtifact')) {
      final l$keepLatestArtifact = data['keepLatestArtifact'];
      result$data['keepLatestArtifact'] = (l$keepLatestArtifact as bool?);
    }
    if (data.containsKey('jobTokenScopeEnabled')) {
      final l$jobTokenScopeEnabled = data['jobTokenScopeEnabled'];
      result$data['jobTokenScopeEnabled'] = (l$jobTokenScopeEnabled as bool?);
    }
    if (data.containsKey('mergePipelinesEnabled')) {
      final l$mergePipelinesEnabled = data['mergePipelinesEnabled'];
      result$data['mergePipelinesEnabled'] = (l$mergePipelinesEnabled as bool?);
    }
    if (data.containsKey('mergeTrainsEnabled')) {
      final l$mergeTrainsEnabled = data['mergeTrainsEnabled'];
      result$data['mergeTrainsEnabled'] = (l$mergeTrainsEnabled as bool?);
    }
    return Input$ProjectCiCdSettingsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fullPath => (_$data['fullPath'] as String);
  bool? get keepLatestArtifact => (_$data['keepLatestArtifact'] as bool?);
  bool? get jobTokenScopeEnabled => (_$data['jobTokenScopeEnabled'] as bool?);
  bool? get mergePipelinesEnabled => (_$data['mergePipelinesEnabled'] as bool?);
  bool? get mergeTrainsEnabled => (_$data['mergeTrainsEnabled'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fullPath = fullPath;
    result$data['fullPath'] = l$fullPath;
    if (_$data.containsKey('keepLatestArtifact')) {
      final l$keepLatestArtifact = keepLatestArtifact;
      result$data['keepLatestArtifact'] = l$keepLatestArtifact;
    }
    if (_$data.containsKey('jobTokenScopeEnabled')) {
      final l$jobTokenScopeEnabled = jobTokenScopeEnabled;
      result$data['jobTokenScopeEnabled'] = l$jobTokenScopeEnabled;
    }
    if (_$data.containsKey('mergePipelinesEnabled')) {
      final l$mergePipelinesEnabled = mergePipelinesEnabled;
      result$data['mergePipelinesEnabled'] = l$mergePipelinesEnabled;
    }
    if (_$data.containsKey('mergeTrainsEnabled')) {
      final l$mergeTrainsEnabled = mergeTrainsEnabled;
      result$data['mergeTrainsEnabled'] = l$mergeTrainsEnabled;
    }
    return result$data;
  }

  CopyWith$Input$ProjectCiCdSettingsUpdateInput<
          Input$ProjectCiCdSettingsUpdateInput>
      get copyWith => CopyWith$Input$ProjectCiCdSettingsUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectCiCdSettingsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$keepLatestArtifact = keepLatestArtifact;
    final lOther$keepLatestArtifact = other.keepLatestArtifact;
    if (_$data.containsKey('keepLatestArtifact') !=
        other._$data.containsKey('keepLatestArtifact')) {
      return false;
    }
    if (l$keepLatestArtifact != lOther$keepLatestArtifact) {
      return false;
    }
    final l$jobTokenScopeEnabled = jobTokenScopeEnabled;
    final lOther$jobTokenScopeEnabled = other.jobTokenScopeEnabled;
    if (_$data.containsKey('jobTokenScopeEnabled') !=
        other._$data.containsKey('jobTokenScopeEnabled')) {
      return false;
    }
    if (l$jobTokenScopeEnabled != lOther$jobTokenScopeEnabled) {
      return false;
    }
    final l$mergePipelinesEnabled = mergePipelinesEnabled;
    final lOther$mergePipelinesEnabled = other.mergePipelinesEnabled;
    if (_$data.containsKey('mergePipelinesEnabled') !=
        other._$data.containsKey('mergePipelinesEnabled')) {
      return false;
    }
    if (l$mergePipelinesEnabled != lOther$mergePipelinesEnabled) {
      return false;
    }
    final l$mergeTrainsEnabled = mergeTrainsEnabled;
    final lOther$mergeTrainsEnabled = other.mergeTrainsEnabled;
    if (_$data.containsKey('mergeTrainsEnabled') !=
        other._$data.containsKey('mergeTrainsEnabled')) {
      return false;
    }
    if (l$mergeTrainsEnabled != lOther$mergeTrainsEnabled) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$keepLatestArtifact = keepLatestArtifact;
    final l$jobTokenScopeEnabled = jobTokenScopeEnabled;
    final l$mergePipelinesEnabled = mergePipelinesEnabled;
    final l$mergeTrainsEnabled = mergeTrainsEnabled;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fullPath,
      _$data.containsKey('keepLatestArtifact')
          ? l$keepLatestArtifact
          : const {},
      _$data.containsKey('jobTokenScopeEnabled')
          ? l$jobTokenScopeEnabled
          : const {},
      _$data.containsKey('mergePipelinesEnabled')
          ? l$mergePipelinesEnabled
          : const {},
      _$data.containsKey('mergeTrainsEnabled')
          ? l$mergeTrainsEnabled
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProjectCiCdSettingsUpdateInput<TRes> {
  factory CopyWith$Input$ProjectCiCdSettingsUpdateInput(
    Input$ProjectCiCdSettingsUpdateInput instance,
    TRes Function(Input$ProjectCiCdSettingsUpdateInput) then,
  ) = _CopyWithImpl$Input$ProjectCiCdSettingsUpdateInput;

  factory CopyWith$Input$ProjectCiCdSettingsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectCiCdSettingsUpdateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    bool? keepLatestArtifact,
    bool? jobTokenScopeEnabled,
    bool? mergePipelinesEnabled,
    bool? mergeTrainsEnabled,
  });
}

class _CopyWithImpl$Input$ProjectCiCdSettingsUpdateInput<TRes>
    implements CopyWith$Input$ProjectCiCdSettingsUpdateInput<TRes> {
  _CopyWithImpl$Input$ProjectCiCdSettingsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProjectCiCdSettingsUpdateInput _instance;

  final TRes Function(Input$ProjectCiCdSettingsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? keepLatestArtifact = _undefined,
    Object? jobTokenScopeEnabled = _undefined,
    Object? mergePipelinesEnabled = _undefined,
    Object? mergeTrainsEnabled = _undefined,
  }) =>
      _then(Input$ProjectCiCdSettingsUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined && fullPath != null)
          'fullPath': (fullPath as String),
        if (keepLatestArtifact != _undefined)
          'keepLatestArtifact': (keepLatestArtifact as bool?),
        if (jobTokenScopeEnabled != _undefined)
          'jobTokenScopeEnabled': (jobTokenScopeEnabled as bool?),
        if (mergePipelinesEnabled != _undefined)
          'mergePipelinesEnabled': (mergePipelinesEnabled as bool?),
        if (mergeTrainsEnabled != _undefined)
          'mergeTrainsEnabled': (mergeTrainsEnabled as bool?),
      }));
}

class _CopyWithStubImpl$Input$ProjectCiCdSettingsUpdateInput<TRes>
    implements CopyWith$Input$ProjectCiCdSettingsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProjectCiCdSettingsUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    bool? keepLatestArtifact,
    bool? jobTokenScopeEnabled,
    bool? mergePipelinesEnabled,
    bool? mergeTrainsEnabled,
  }) =>
      _res;
}

class Input$ProjectSetComplianceFrameworkInput {
  factory Input$ProjectSetComplianceFrameworkInput({
    String? clientMutationId,
    required String projectId,
    String? complianceFrameworkId,
  }) =>
      Input$ProjectSetComplianceFrameworkInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        if (complianceFrameworkId != null)
          r'complianceFrameworkId': complianceFrameworkId,
      });

  Input$ProjectSetComplianceFrameworkInput._(this._$data);

  factory Input$ProjectSetComplianceFrameworkInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('complianceFrameworkId')) {
      final l$complianceFrameworkId = data['complianceFrameworkId'];
      result$data['complianceFrameworkId'] =
          (l$complianceFrameworkId as String?);
    }
    return Input$ProjectSetComplianceFrameworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String? get complianceFrameworkId =>
      (_$data['complianceFrameworkId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('complianceFrameworkId')) {
      final l$complianceFrameworkId = complianceFrameworkId;
      result$data['complianceFrameworkId'] = l$complianceFrameworkId;
    }
    return result$data;
  }

  CopyWith$Input$ProjectSetComplianceFrameworkInput<
          Input$ProjectSetComplianceFrameworkInput>
      get copyWith => CopyWith$Input$ProjectSetComplianceFrameworkInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectSetComplianceFrameworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$complianceFrameworkId = complianceFrameworkId;
    final lOther$complianceFrameworkId = other.complianceFrameworkId;
    if (_$data.containsKey('complianceFrameworkId') !=
        other._$data.containsKey('complianceFrameworkId')) {
      return false;
    }
    if (l$complianceFrameworkId != lOther$complianceFrameworkId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$complianceFrameworkId = complianceFrameworkId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      _$data.containsKey('complianceFrameworkId')
          ? l$complianceFrameworkId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProjectSetComplianceFrameworkInput<TRes> {
  factory CopyWith$Input$ProjectSetComplianceFrameworkInput(
    Input$ProjectSetComplianceFrameworkInput instance,
    TRes Function(Input$ProjectSetComplianceFrameworkInput) then,
  ) = _CopyWithImpl$Input$ProjectSetComplianceFrameworkInput;

  factory CopyWith$Input$ProjectSetComplianceFrameworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectSetComplianceFrameworkInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? complianceFrameworkId,
  });
}

class _CopyWithImpl$Input$ProjectSetComplianceFrameworkInput<TRes>
    implements CopyWith$Input$ProjectSetComplianceFrameworkInput<TRes> {
  _CopyWithImpl$Input$ProjectSetComplianceFrameworkInput(
    this._instance,
    this._then,
  );

  final Input$ProjectSetComplianceFrameworkInput _instance;

  final TRes Function(Input$ProjectSetComplianceFrameworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? complianceFrameworkId = _undefined,
  }) =>
      _then(Input$ProjectSetComplianceFrameworkInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (complianceFrameworkId != _undefined)
          'complianceFrameworkId': (complianceFrameworkId as String?),
      }));
}

class _CopyWithStubImpl$Input$ProjectSetComplianceFrameworkInput<TRes>
    implements CopyWith$Input$ProjectSetComplianceFrameworkInput<TRes> {
  _CopyWithStubImpl$Input$ProjectSetComplianceFrameworkInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? complianceFrameworkId,
  }) =>
      _res;
}

class Input$ProjectSetLockedInput {
  factory Input$ProjectSetLockedInput({
    String? clientMutationId,
    required String projectPath,
    required String filePath,
    required bool lock,
  }) =>
      Input$ProjectSetLockedInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'filePath': filePath,
        r'lock': lock,
      });

  Input$ProjectSetLockedInput._(this._$data);

  factory Input$ProjectSetLockedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$filePath = data['filePath'];
    result$data['filePath'] = (l$filePath as String);
    final l$lock = data['lock'];
    result$data['lock'] = (l$lock as bool);
    return Input$ProjectSetLockedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get filePath => (_$data['filePath'] as String);
  bool get lock => (_$data['lock'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$filePath = filePath;
    result$data['filePath'] = l$filePath;
    final l$lock = lock;
    result$data['lock'] = l$lock;
    return result$data;
  }

  CopyWith$Input$ProjectSetLockedInput<Input$ProjectSetLockedInput>
      get copyWith => CopyWith$Input$ProjectSetLockedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectSetLockedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$filePath = filePath;
    final lOther$filePath = other.filePath;
    if (l$filePath != lOther$filePath) {
      return false;
    }
    final l$lock = lock;
    final lOther$lock = other.lock;
    if (l$lock != lOther$lock) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$filePath = filePath;
    final l$lock = lock;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$filePath,
      l$lock,
    ]);
  }
}

abstract class CopyWith$Input$ProjectSetLockedInput<TRes> {
  factory CopyWith$Input$ProjectSetLockedInput(
    Input$ProjectSetLockedInput instance,
    TRes Function(Input$ProjectSetLockedInput) then,
  ) = _CopyWithImpl$Input$ProjectSetLockedInput;

  factory CopyWith$Input$ProjectSetLockedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectSetLockedInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? filePath,
    bool? lock,
  });
}

class _CopyWithImpl$Input$ProjectSetLockedInput<TRes>
    implements CopyWith$Input$ProjectSetLockedInput<TRes> {
  _CopyWithImpl$Input$ProjectSetLockedInput(
    this._instance,
    this._then,
  );

  final Input$ProjectSetLockedInput _instance;

  final TRes Function(Input$ProjectSetLockedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? filePath = _undefined,
    Object? lock = _undefined,
  }) =>
      _then(Input$ProjectSetLockedInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (filePath != _undefined && filePath != null)
          'filePath': (filePath as String),
        if (lock != _undefined && lock != null) 'lock': (lock as bool),
      }));
}

class _CopyWithStubImpl$Input$ProjectSetLockedInput<TRes>
    implements CopyWith$Input$ProjectSetLockedInput<TRes> {
  _CopyWithStubImpl$Input$ProjectSetLockedInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? filePath,
    bool? lock,
  }) =>
      _res;
}

class Input$PrometheusIntegrationCreateInput {
  factory Input$PrometheusIntegrationCreateInput({
    String? clientMutationId,
    required String projectPath,
    required bool active,
    required String apiUrl,
  }) =>
      Input$PrometheusIntegrationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'active': active,
        r'apiUrl': apiUrl,
      });

  Input$PrometheusIntegrationCreateInput._(this._$data);

  factory Input$PrometheusIntegrationCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$active = data['active'];
    result$data['active'] = (l$active as bool);
    final l$apiUrl = data['apiUrl'];
    result$data['apiUrl'] = (l$apiUrl as String);
    return Input$PrometheusIntegrationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  bool get active => (_$data['active'] as bool);
  String get apiUrl => (_$data['apiUrl'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$active = active;
    result$data['active'] = l$active;
    final l$apiUrl = apiUrl;
    result$data['apiUrl'] = l$apiUrl;
    return result$data;
  }

  CopyWith$Input$PrometheusIntegrationCreateInput<
          Input$PrometheusIntegrationCreateInput>
      get copyWith => CopyWith$Input$PrometheusIntegrationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PrometheusIntegrationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (l$active != lOther$active) {
      return false;
    }
    final l$apiUrl = apiUrl;
    final lOther$apiUrl = other.apiUrl;
    if (l$apiUrl != lOther$apiUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$active = active;
    final l$apiUrl = apiUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$active,
      l$apiUrl,
    ]);
  }
}

abstract class CopyWith$Input$PrometheusIntegrationCreateInput<TRes> {
  factory CopyWith$Input$PrometheusIntegrationCreateInput(
    Input$PrometheusIntegrationCreateInput instance,
    TRes Function(Input$PrometheusIntegrationCreateInput) then,
  ) = _CopyWithImpl$Input$PrometheusIntegrationCreateInput;

  factory CopyWith$Input$PrometheusIntegrationCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PrometheusIntegrationCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    bool? active,
    String? apiUrl,
  });
}

class _CopyWithImpl$Input$PrometheusIntegrationCreateInput<TRes>
    implements CopyWith$Input$PrometheusIntegrationCreateInput<TRes> {
  _CopyWithImpl$Input$PrometheusIntegrationCreateInput(
    this._instance,
    this._then,
  );

  final Input$PrometheusIntegrationCreateInput _instance;

  final TRes Function(Input$PrometheusIntegrationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? active = _undefined,
    Object? apiUrl = _undefined,
  }) =>
      _then(Input$PrometheusIntegrationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (active != _undefined && active != null) 'active': (active as bool),
        if (apiUrl != _undefined && apiUrl != null)
          'apiUrl': (apiUrl as String),
      }));
}

class _CopyWithStubImpl$Input$PrometheusIntegrationCreateInput<TRes>
    implements CopyWith$Input$PrometheusIntegrationCreateInput<TRes> {
  _CopyWithStubImpl$Input$PrometheusIntegrationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    bool? active,
    String? apiUrl,
  }) =>
      _res;
}

class Input$PrometheusIntegrationResetTokenInput {
  factory Input$PrometheusIntegrationResetTokenInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$PrometheusIntegrationResetTokenInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$PrometheusIntegrationResetTokenInput._(this._$data);

  factory Input$PrometheusIntegrationResetTokenInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$PrometheusIntegrationResetTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$PrometheusIntegrationResetTokenInput<
          Input$PrometheusIntegrationResetTokenInput>
      get copyWith => CopyWith$Input$PrometheusIntegrationResetTokenInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PrometheusIntegrationResetTokenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$PrometheusIntegrationResetTokenInput<TRes> {
  factory CopyWith$Input$PrometheusIntegrationResetTokenInput(
    Input$PrometheusIntegrationResetTokenInput instance,
    TRes Function(Input$PrometheusIntegrationResetTokenInput) then,
  ) = _CopyWithImpl$Input$PrometheusIntegrationResetTokenInput;

  factory CopyWith$Input$PrometheusIntegrationResetTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PrometheusIntegrationResetTokenInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$PrometheusIntegrationResetTokenInput<TRes>
    implements CopyWith$Input$PrometheusIntegrationResetTokenInput<TRes> {
  _CopyWithImpl$Input$PrometheusIntegrationResetTokenInput(
    this._instance,
    this._then,
  );

  final Input$PrometheusIntegrationResetTokenInput _instance;

  final TRes Function(Input$PrometheusIntegrationResetTokenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$PrometheusIntegrationResetTokenInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$PrometheusIntegrationResetTokenInput<TRes>
    implements CopyWith$Input$PrometheusIntegrationResetTokenInput<TRes> {
  _CopyWithStubImpl$Input$PrometheusIntegrationResetTokenInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$PrometheusIntegrationUpdateInput {
  factory Input$PrometheusIntegrationUpdateInput({
    String? clientMutationId,
    required String id,
    bool? active,
    String? apiUrl,
  }) =>
      Input$PrometheusIntegrationUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (active != null) r'active': active,
        if (apiUrl != null) r'apiUrl': apiUrl,
      });

  Input$PrometheusIntegrationUpdateInput._(this._$data);

  factory Input$PrometheusIntegrationUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    if (data.containsKey('apiUrl')) {
      final l$apiUrl = data['apiUrl'];
      result$data['apiUrl'] = (l$apiUrl as String?);
    }
    return Input$PrometheusIntegrationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  bool? get active => (_$data['active'] as bool?);
  String? get apiUrl => (_$data['apiUrl'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    if (_$data.containsKey('apiUrl')) {
      final l$apiUrl = apiUrl;
      result$data['apiUrl'] = l$apiUrl;
    }
    return result$data;
  }

  CopyWith$Input$PrometheusIntegrationUpdateInput<
          Input$PrometheusIntegrationUpdateInput>
      get copyWith => CopyWith$Input$PrometheusIntegrationUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PrometheusIntegrationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$apiUrl = apiUrl;
    final lOther$apiUrl = other.apiUrl;
    if (_$data.containsKey('apiUrl') != other._$data.containsKey('apiUrl')) {
      return false;
    }
    if (l$apiUrl != lOther$apiUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$active = active;
    final l$apiUrl = apiUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('apiUrl') ? l$apiUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$PrometheusIntegrationUpdateInput<TRes> {
  factory CopyWith$Input$PrometheusIntegrationUpdateInput(
    Input$PrometheusIntegrationUpdateInput instance,
    TRes Function(Input$PrometheusIntegrationUpdateInput) then,
  ) = _CopyWithImpl$Input$PrometheusIntegrationUpdateInput;

  factory CopyWith$Input$PrometheusIntegrationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PrometheusIntegrationUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    bool? active,
    String? apiUrl,
  });
}

class _CopyWithImpl$Input$PrometheusIntegrationUpdateInput<TRes>
    implements CopyWith$Input$PrometheusIntegrationUpdateInput<TRes> {
  _CopyWithImpl$Input$PrometheusIntegrationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PrometheusIntegrationUpdateInput _instance;

  final TRes Function(Input$PrometheusIntegrationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? active = _undefined,
    Object? apiUrl = _undefined,
  }) =>
      _then(Input$PrometheusIntegrationUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (active != _undefined) 'active': (active as bool?),
        if (apiUrl != _undefined) 'apiUrl': (apiUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$PrometheusIntegrationUpdateInput<TRes>
    implements CopyWith$Input$PrometheusIntegrationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PrometheusIntegrationUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    bool? active,
    String? apiUrl,
  }) =>
      _res;
}

class Input$PromoteToEpicInput {
  factory Input$PromoteToEpicInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? groupPath,
  }) =>
      Input$PromoteToEpicInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (groupPath != null) r'groupPath': groupPath,
      });

  Input$PromoteToEpicInput._(this._$data);

  factory Input$PromoteToEpicInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    return Input$PromoteToEpicInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get groupPath => (_$data['groupPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    return result$data;
  }

  CopyWith$Input$PromoteToEpicInput<Input$PromoteToEpicInput> get copyWith =>
      CopyWith$Input$PromoteToEpicInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromoteToEpicInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromoteToEpicInput<TRes> {
  factory CopyWith$Input$PromoteToEpicInput(
    Input$PromoteToEpicInput instance,
    TRes Function(Input$PromoteToEpicInput) then,
  ) = _CopyWithImpl$Input$PromoteToEpicInput;

  factory CopyWith$Input$PromoteToEpicInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromoteToEpicInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? groupPath,
  });
}

class _CopyWithImpl$Input$PromoteToEpicInput<TRes>
    implements CopyWith$Input$PromoteToEpicInput<TRes> {
  _CopyWithImpl$Input$PromoteToEpicInput(
    this._instance,
    this._then,
  );

  final Input$PromoteToEpicInput _instance;

  final TRes Function(Input$PromoteToEpicInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
  }) =>
      _then(Input$PromoteToEpicInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
      }));
}

class _CopyWithStubImpl$Input$PromoteToEpicInput<TRes>
    implements CopyWith$Input$PromoteToEpicInput<TRes> {
  _CopyWithStubImpl$Input$PromoteToEpicInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? groupPath,
  }) =>
      _res;
}

class Input$ReleaseAssetLinkCreateInput {
  factory Input$ReleaseAssetLinkCreateInput({
    String? clientMutationId,
    required String name,
    required String url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
    required String projectPath,
    required String tagName,
  }) =>
      Input$ReleaseAssetLinkCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'url': url,
        if (directAssetPath != null) r'directAssetPath': directAssetPath,
        if (linkType != null) r'linkType': linkType,
        r'projectPath': projectPath,
        r'tagName': tagName,
      });

  Input$ReleaseAssetLinkCreateInput._(this._$data);

  factory Input$ReleaseAssetLinkCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    if (data.containsKey('directAssetPath')) {
      final l$directAssetPath = data['directAssetPath'];
      result$data['directAssetPath'] = (l$directAssetPath as String?);
    }
    if (data.containsKey('linkType')) {
      final l$linkType = data['linkType'];
      result$data['linkType'] = l$linkType == null
          ? null
          : fromJson$Enum$ReleaseAssetLinkType((l$linkType as String));
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$tagName = data['tagName'];
    result$data['tagName'] = (l$tagName as String);
    return Input$ReleaseAssetLinkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get url => (_$data['url'] as String);
  String? get directAssetPath => (_$data['directAssetPath'] as String?);
  Enum$ReleaseAssetLinkType? get linkType =>
      (_$data['linkType'] as Enum$ReleaseAssetLinkType?);
  String get projectPath => (_$data['projectPath'] as String);
  String get tagName => (_$data['tagName'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$url = url;
    result$data['url'] = l$url;
    if (_$data.containsKey('directAssetPath')) {
      final l$directAssetPath = directAssetPath;
      result$data['directAssetPath'] = l$directAssetPath;
    }
    if (_$data.containsKey('linkType')) {
      final l$linkType = linkType;
      result$data['linkType'] = l$linkType == null
          ? null
          : toJson$Enum$ReleaseAssetLinkType(l$linkType);
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$tagName = tagName;
    result$data['tagName'] = l$tagName;
    return result$data;
  }

  CopyWith$Input$ReleaseAssetLinkCreateInput<Input$ReleaseAssetLinkCreateInput>
      get copyWith => CopyWith$Input$ReleaseAssetLinkCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseAssetLinkCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    final l$directAssetPath = directAssetPath;
    final lOther$directAssetPath = other.directAssetPath;
    if (_$data.containsKey('directAssetPath') !=
        other._$data.containsKey('directAssetPath')) {
      return false;
    }
    if (l$directAssetPath != lOther$directAssetPath) {
      return false;
    }
    final l$linkType = linkType;
    final lOther$linkType = other.linkType;
    if (_$data.containsKey('linkType') !=
        other._$data.containsKey('linkType')) {
      return false;
    }
    if (l$linkType != lOther$linkType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$tagName = tagName;
    final lOther$tagName = other.tagName;
    if (l$tagName != lOther$tagName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$url = url;
    final l$directAssetPath = directAssetPath;
    final l$linkType = linkType;
    final l$projectPath = projectPath;
    final l$tagName = tagName;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$url,
      _$data.containsKey('directAssetPath') ? l$directAssetPath : const {},
      _$data.containsKey('linkType') ? l$linkType : const {},
      l$projectPath,
      l$tagName,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseAssetLinkCreateInput<TRes> {
  factory CopyWith$Input$ReleaseAssetLinkCreateInput(
    Input$ReleaseAssetLinkCreateInput instance,
    TRes Function(Input$ReleaseAssetLinkCreateInput) then,
  ) = _CopyWithImpl$Input$ReleaseAssetLinkCreateInput;

  factory CopyWith$Input$ReleaseAssetLinkCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseAssetLinkCreateInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
    String? projectPath,
    String? tagName,
  });
}

class _CopyWithImpl$Input$ReleaseAssetLinkCreateInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkCreateInput<TRes> {
  _CopyWithImpl$Input$ReleaseAssetLinkCreateInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseAssetLinkCreateInput _instance;

  final TRes Function(Input$ReleaseAssetLinkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? url = _undefined,
    Object? directAssetPath = _undefined,
    Object? linkType = _undefined,
    Object? projectPath = _undefined,
    Object? tagName = _undefined,
  }) =>
      _then(Input$ReleaseAssetLinkCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined && url != null) 'url': (url as String),
        if (directAssetPath != _undefined)
          'directAssetPath': (directAssetPath as String?),
        if (linkType != _undefined)
          'linkType': (linkType as Enum$ReleaseAssetLinkType?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (tagName != _undefined && tagName != null)
          'tagName': (tagName as String),
      }));
}

class _CopyWithStubImpl$Input$ReleaseAssetLinkCreateInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkCreateInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseAssetLinkCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
    String? projectPath,
    String? tagName,
  }) =>
      _res;
}

class Input$ReleaseAssetLinkDeleteInput {
  factory Input$ReleaseAssetLinkDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$ReleaseAssetLinkDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$ReleaseAssetLinkDeleteInput._(this._$data);

  factory Input$ReleaseAssetLinkDeleteInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ReleaseAssetLinkDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ReleaseAssetLinkDeleteInput<Input$ReleaseAssetLinkDeleteInput>
      get copyWith => CopyWith$Input$ReleaseAssetLinkDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseAssetLinkDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseAssetLinkDeleteInput<TRes> {
  factory CopyWith$Input$ReleaseAssetLinkDeleteInput(
    Input$ReleaseAssetLinkDeleteInput instance,
    TRes Function(Input$ReleaseAssetLinkDeleteInput) then,
  ) = _CopyWithImpl$Input$ReleaseAssetLinkDeleteInput;

  factory CopyWith$Input$ReleaseAssetLinkDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseAssetLinkDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$ReleaseAssetLinkDeleteInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkDeleteInput<TRes> {
  _CopyWithImpl$Input$ReleaseAssetLinkDeleteInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseAssetLinkDeleteInput _instance;

  final TRes Function(Input$ReleaseAssetLinkDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ReleaseAssetLinkDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$ReleaseAssetLinkDeleteInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkDeleteInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseAssetLinkDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$ReleaseAssetLinkInput {
  factory Input$ReleaseAssetLinkInput({
    required String name,
    required String url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
  }) =>
      Input$ReleaseAssetLinkInput._({
        r'name': name,
        r'url': url,
        if (directAssetPath != null) r'directAssetPath': directAssetPath,
        if (linkType != null) r'linkType': linkType,
      });

  Input$ReleaseAssetLinkInput._(this._$data);

  factory Input$ReleaseAssetLinkInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    if (data.containsKey('directAssetPath')) {
      final l$directAssetPath = data['directAssetPath'];
      result$data['directAssetPath'] = (l$directAssetPath as String?);
    }
    if (data.containsKey('linkType')) {
      final l$linkType = data['linkType'];
      result$data['linkType'] = l$linkType == null
          ? null
          : fromJson$Enum$ReleaseAssetLinkType((l$linkType as String));
    }
    return Input$ReleaseAssetLinkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get url => (_$data['url'] as String);
  String? get directAssetPath => (_$data['directAssetPath'] as String?);
  Enum$ReleaseAssetLinkType? get linkType =>
      (_$data['linkType'] as Enum$ReleaseAssetLinkType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$url = url;
    result$data['url'] = l$url;
    if (_$data.containsKey('directAssetPath')) {
      final l$directAssetPath = directAssetPath;
      result$data['directAssetPath'] = l$directAssetPath;
    }
    if (_$data.containsKey('linkType')) {
      final l$linkType = linkType;
      result$data['linkType'] = l$linkType == null
          ? null
          : toJson$Enum$ReleaseAssetLinkType(l$linkType);
    }
    return result$data;
  }

  CopyWith$Input$ReleaseAssetLinkInput<Input$ReleaseAssetLinkInput>
      get copyWith => CopyWith$Input$ReleaseAssetLinkInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseAssetLinkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    final l$directAssetPath = directAssetPath;
    final lOther$directAssetPath = other.directAssetPath;
    if (_$data.containsKey('directAssetPath') !=
        other._$data.containsKey('directAssetPath')) {
      return false;
    }
    if (l$directAssetPath != lOther$directAssetPath) {
      return false;
    }
    final l$linkType = linkType;
    final lOther$linkType = other.linkType;
    if (_$data.containsKey('linkType') !=
        other._$data.containsKey('linkType')) {
      return false;
    }
    if (l$linkType != lOther$linkType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$url = url;
    final l$directAssetPath = directAssetPath;
    final l$linkType = linkType;
    return Object.hashAll([
      l$name,
      l$url,
      _$data.containsKey('directAssetPath') ? l$directAssetPath : const {},
      _$data.containsKey('linkType') ? l$linkType : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseAssetLinkInput<TRes> {
  factory CopyWith$Input$ReleaseAssetLinkInput(
    Input$ReleaseAssetLinkInput instance,
    TRes Function(Input$ReleaseAssetLinkInput) then,
  ) = _CopyWithImpl$Input$ReleaseAssetLinkInput;

  factory CopyWith$Input$ReleaseAssetLinkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseAssetLinkInput;

  TRes call({
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
  });
}

class _CopyWithImpl$Input$ReleaseAssetLinkInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkInput<TRes> {
  _CopyWithImpl$Input$ReleaseAssetLinkInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseAssetLinkInput _instance;

  final TRes Function(Input$ReleaseAssetLinkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? url = _undefined,
    Object? directAssetPath = _undefined,
    Object? linkType = _undefined,
  }) =>
      _then(Input$ReleaseAssetLinkInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined && url != null) 'url': (url as String),
        if (directAssetPath != _undefined)
          'directAssetPath': (directAssetPath as String?),
        if (linkType != _undefined)
          'linkType': (linkType as Enum$ReleaseAssetLinkType?),
      }));
}

class _CopyWithStubImpl$Input$ReleaseAssetLinkInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseAssetLinkInput(this._res);

  TRes _res;

  call({
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
  }) =>
      _res;
}

class Input$ReleaseAssetLinkUpdateInput {
  factory Input$ReleaseAssetLinkUpdateInput({
    String? clientMutationId,
    required String id,
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
  }) =>
      Input$ReleaseAssetLinkUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (name != null) r'name': name,
        if (url != null) r'url': url,
        if (directAssetPath != null) r'directAssetPath': directAssetPath,
        if (linkType != null) r'linkType': linkType,
      });

  Input$ReleaseAssetLinkUpdateInput._(this._$data);

  factory Input$ReleaseAssetLinkUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('directAssetPath')) {
      final l$directAssetPath = data['directAssetPath'];
      result$data['directAssetPath'] = (l$directAssetPath as String?);
    }
    if (data.containsKey('linkType')) {
      final l$linkType = data['linkType'];
      result$data['linkType'] = l$linkType == null
          ? null
          : fromJson$Enum$ReleaseAssetLinkType((l$linkType as String));
    }
    return Input$ReleaseAssetLinkUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get name => (_$data['name'] as String?);
  String? get url => (_$data['url'] as String?);
  String? get directAssetPath => (_$data['directAssetPath'] as String?);
  Enum$ReleaseAssetLinkType? get linkType =>
      (_$data['linkType'] as Enum$ReleaseAssetLinkType?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('directAssetPath')) {
      final l$directAssetPath = directAssetPath;
      result$data['directAssetPath'] = l$directAssetPath;
    }
    if (_$data.containsKey('linkType')) {
      final l$linkType = linkType;
      result$data['linkType'] = l$linkType == null
          ? null
          : toJson$Enum$ReleaseAssetLinkType(l$linkType);
    }
    return result$data;
  }

  CopyWith$Input$ReleaseAssetLinkUpdateInput<Input$ReleaseAssetLinkUpdateInput>
      get copyWith => CopyWith$Input$ReleaseAssetLinkUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseAssetLinkUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$directAssetPath = directAssetPath;
    final lOther$directAssetPath = other.directAssetPath;
    if (_$data.containsKey('directAssetPath') !=
        other._$data.containsKey('directAssetPath')) {
      return false;
    }
    if (l$directAssetPath != lOther$directAssetPath) {
      return false;
    }
    final l$linkType = linkType;
    final lOther$linkType = other.linkType;
    if (_$data.containsKey('linkType') !=
        other._$data.containsKey('linkType')) {
      return false;
    }
    if (l$linkType != lOther$linkType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$directAssetPath = directAssetPath;
    final l$linkType = linkType;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('directAssetPath') ? l$directAssetPath : const {},
      _$data.containsKey('linkType') ? l$linkType : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseAssetLinkUpdateInput<TRes> {
  factory CopyWith$Input$ReleaseAssetLinkUpdateInput(
    Input$ReleaseAssetLinkUpdateInput instance,
    TRes Function(Input$ReleaseAssetLinkUpdateInput) then,
  ) = _CopyWithImpl$Input$ReleaseAssetLinkUpdateInput;

  factory CopyWith$Input$ReleaseAssetLinkUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseAssetLinkUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
  });
}

class _CopyWithImpl$Input$ReleaseAssetLinkUpdateInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkUpdateInput<TRes> {
  _CopyWithImpl$Input$ReleaseAssetLinkUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseAssetLinkUpdateInput _instance;

  final TRes Function(Input$ReleaseAssetLinkUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? url = _undefined,
    Object? directAssetPath = _undefined,
    Object? linkType = _undefined,
  }) =>
      _then(Input$ReleaseAssetLinkUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined) 'name': (name as String?),
        if (url != _undefined) 'url': (url as String?),
        if (directAssetPath != _undefined)
          'directAssetPath': (directAssetPath as String?),
        if (linkType != _undefined)
          'linkType': (linkType as Enum$ReleaseAssetLinkType?),
      }));
}

class _CopyWithStubImpl$Input$ReleaseAssetLinkUpdateInput<TRes>
    implements CopyWith$Input$ReleaseAssetLinkUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseAssetLinkUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? name,
    String? url,
    String? directAssetPath,
    Enum$ReleaseAssetLinkType? linkType,
  }) =>
      _res;
}

class Input$ReleaseAssetsInput {
  factory Input$ReleaseAssetsInput(
          {List<Input$ReleaseAssetLinkInput>? links}) =>
      Input$ReleaseAssetsInput._({
        if (links != null) r'links': links,
      });

  Input$ReleaseAssetsInput._(this._$data);

  factory Input$ReleaseAssetsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('links')) {
      final l$links = data['links'];
      result$data['links'] = (l$links as List<dynamic>?)
          ?.map((e) =>
              Input$ReleaseAssetLinkInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ReleaseAssetsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ReleaseAssetLinkInput>? get links =>
      (_$data['links'] as List<Input$ReleaseAssetLinkInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('links')) {
      final l$links = links;
      result$data['links'] = l$links?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ReleaseAssetsInput<Input$ReleaseAssetsInput> get copyWith =>
      CopyWith$Input$ReleaseAssetsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseAssetsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$links = links;
    final lOther$links = other.links;
    if (_$data.containsKey('links') != other._$data.containsKey('links')) {
      return false;
    }
    if (l$links != null && lOther$links != null) {
      if (l$links.length != lOther$links.length) {
        return false;
      }
      for (int i = 0; i < l$links.length; i++) {
        final l$links$entry = l$links[i];
        final lOther$links$entry = lOther$links[i];
        if (l$links$entry != lOther$links$entry) {
          return false;
        }
      }
    } else if (l$links != lOther$links) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$links = links;
    return Object.hashAll([
      _$data.containsKey('links')
          ? l$links == null
              ? null
              : Object.hashAll(l$links.map((v) => v))
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$ReleaseAssetsInput<TRes> {
  factory CopyWith$Input$ReleaseAssetsInput(
    Input$ReleaseAssetsInput instance,
    TRes Function(Input$ReleaseAssetsInput) then,
  ) = _CopyWithImpl$Input$ReleaseAssetsInput;

  factory CopyWith$Input$ReleaseAssetsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseAssetsInput;

  TRes call({List<Input$ReleaseAssetLinkInput>? links});
  TRes links(
      Iterable<Input$ReleaseAssetLinkInput>? Function(
              Iterable<
                  CopyWith$Input$ReleaseAssetLinkInput<
                      Input$ReleaseAssetLinkInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ReleaseAssetsInput<TRes>
    implements CopyWith$Input$ReleaseAssetsInput<TRes> {
  _CopyWithImpl$Input$ReleaseAssetsInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseAssetsInput _instance;

  final TRes Function(Input$ReleaseAssetsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? links = _undefined}) => _then(Input$ReleaseAssetsInput._({
        ..._instance._$data,
        if (links != _undefined)
          'links': (links as List<Input$ReleaseAssetLinkInput>?),
      }));
  TRes links(
          Iterable<Input$ReleaseAssetLinkInput>? Function(
                  Iterable<
                      CopyWith$Input$ReleaseAssetLinkInput<
                          Input$ReleaseAssetLinkInput>>?)
              _fn) =>
      call(
          links: _fn(
              _instance.links?.map((e) => CopyWith$Input$ReleaseAssetLinkInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ReleaseAssetsInput<TRes>
    implements CopyWith$Input$ReleaseAssetsInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseAssetsInput(this._res);

  TRes _res;

  call({List<Input$ReleaseAssetLinkInput>? links}) => _res;
  links(_fn) => _res;
}

class Input$ReleaseCreateInput {
  factory Input$ReleaseCreateInput({
    required String projectPath,
    String? clientMutationId,
    required String tagName,
    String? tagMessage,
    String? ref,
    String? name,
    String? description,
    String? releasedAt,
    List<String>? milestones,
    Input$ReleaseAssetsInput? assets,
  }) =>
      Input$ReleaseCreateInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tagName': tagName,
        if (tagMessage != null) r'tagMessage': tagMessage,
        if (ref != null) r'ref': ref,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (releasedAt != null) r'releasedAt': releasedAt,
        if (milestones != null) r'milestones': milestones,
        if (assets != null) r'assets': assets,
      });

  Input$ReleaseCreateInput._(this._$data);

  factory Input$ReleaseCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tagName = data['tagName'];
    result$data['tagName'] = (l$tagName as String);
    if (data.containsKey('tagMessage')) {
      final l$tagMessage = data['tagMessage'];
      result$data['tagMessage'] = (l$tagMessage as String?);
    }
    if (data.containsKey('ref')) {
      final l$ref = data['ref'];
      result$data['ref'] = (l$ref as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('releasedAt')) {
      final l$releasedAt = data['releasedAt'];
      result$data['releasedAt'] = (l$releasedAt as String?);
    }
    if (data.containsKey('milestones')) {
      final l$milestones = data['milestones'];
      result$data['milestones'] =
          (l$milestones as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('assets')) {
      final l$assets = data['assets'];
      result$data['assets'] = l$assets == null
          ? null
          : Input$ReleaseAssetsInput.fromJson(
              (l$assets as Map<String, dynamic>));
    }
    return Input$ReleaseCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get tagName => (_$data['tagName'] as String);
  String? get tagMessage => (_$data['tagMessage'] as String?);
  String? get ref => (_$data['ref'] as String?);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get releasedAt => (_$data['releasedAt'] as String?);
  List<String>? get milestones => (_$data['milestones'] as List<String>?);
  Input$ReleaseAssetsInput? get assets =>
      (_$data['assets'] as Input$ReleaseAssetsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tagName = tagName;
    result$data['tagName'] = l$tagName;
    if (_$data.containsKey('tagMessage')) {
      final l$tagMessage = tagMessage;
      result$data['tagMessage'] = l$tagMessage;
    }
    if (_$data.containsKey('ref')) {
      final l$ref = ref;
      result$data['ref'] = l$ref;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('releasedAt')) {
      final l$releasedAt = releasedAt;
      result$data['releasedAt'] = l$releasedAt;
    }
    if (_$data.containsKey('milestones')) {
      final l$milestones = milestones;
      result$data['milestones'] = l$milestones?.map((e) => e).toList();
    }
    if (_$data.containsKey('assets')) {
      final l$assets = assets;
      result$data['assets'] = l$assets?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ReleaseCreateInput<Input$ReleaseCreateInput> get copyWith =>
      CopyWith$Input$ReleaseCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tagName = tagName;
    final lOther$tagName = other.tagName;
    if (l$tagName != lOther$tagName) {
      return false;
    }
    final l$tagMessage = tagMessage;
    final lOther$tagMessage = other.tagMessage;
    if (_$data.containsKey('tagMessage') !=
        other._$data.containsKey('tagMessage')) {
      return false;
    }
    if (l$tagMessage != lOther$tagMessage) {
      return false;
    }
    final l$ref = ref;
    final lOther$ref = other.ref;
    if (_$data.containsKey('ref') != other._$data.containsKey('ref')) {
      return false;
    }
    if (l$ref != lOther$ref) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$releasedAt = releasedAt;
    final lOther$releasedAt = other.releasedAt;
    if (_$data.containsKey('releasedAt') !=
        other._$data.containsKey('releasedAt')) {
      return false;
    }
    if (l$releasedAt != lOther$releasedAt) {
      return false;
    }
    final l$milestones = milestones;
    final lOther$milestones = other.milestones;
    if (_$data.containsKey('milestones') !=
        other._$data.containsKey('milestones')) {
      return false;
    }
    if (l$milestones != null && lOther$milestones != null) {
      if (l$milestones.length != lOther$milestones.length) {
        return false;
      }
      for (int i = 0; i < l$milestones.length; i++) {
        final l$milestones$entry = l$milestones[i];
        final lOther$milestones$entry = lOther$milestones[i];
        if (l$milestones$entry != lOther$milestones$entry) {
          return false;
        }
      }
    } else if (l$milestones != lOther$milestones) {
      return false;
    }
    final l$assets = assets;
    final lOther$assets = other.assets;
    if (_$data.containsKey('assets') != other._$data.containsKey('assets')) {
      return false;
    }
    if (l$assets != lOther$assets) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    final l$tagName = tagName;
    final l$tagMessage = tagMessage;
    final l$ref = ref;
    final l$name = name;
    final l$description = description;
    final l$releasedAt = releasedAt;
    final l$milestones = milestones;
    final l$assets = assets;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tagName,
      _$data.containsKey('tagMessage') ? l$tagMessage : const {},
      _$data.containsKey('ref') ? l$ref : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('releasedAt') ? l$releasedAt : const {},
      _$data.containsKey('milestones')
          ? l$milestones == null
              ? null
              : Object.hashAll(l$milestones.map((v) => v))
          : const {},
      _$data.containsKey('assets') ? l$assets : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseCreateInput<TRes> {
  factory CopyWith$Input$ReleaseCreateInput(
    Input$ReleaseCreateInput instance,
    TRes Function(Input$ReleaseCreateInput) then,
  ) = _CopyWithImpl$Input$ReleaseCreateInput;

  factory CopyWith$Input$ReleaseCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseCreateInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
    String? tagName,
    String? tagMessage,
    String? ref,
    String? name,
    String? description,
    String? releasedAt,
    List<String>? milestones,
    Input$ReleaseAssetsInput? assets,
  });
  CopyWith$Input$ReleaseAssetsInput<TRes> get assets;
}

class _CopyWithImpl$Input$ReleaseCreateInput<TRes>
    implements CopyWith$Input$ReleaseCreateInput<TRes> {
  _CopyWithImpl$Input$ReleaseCreateInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseCreateInput _instance;

  final TRes Function(Input$ReleaseCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? tagName = _undefined,
    Object? tagMessage = _undefined,
    Object? ref = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? releasedAt = _undefined,
    Object? milestones = _undefined,
    Object? assets = _undefined,
  }) =>
      _then(Input$ReleaseCreateInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tagName != _undefined && tagName != null)
          'tagName': (tagName as String),
        if (tagMessage != _undefined) 'tagMessage': (tagMessage as String?),
        if (ref != _undefined) 'ref': (ref as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (releasedAt != _undefined) 'releasedAt': (releasedAt as String?),
        if (milestones != _undefined)
          'milestones': (milestones as List<String>?),
        if (assets != _undefined)
          'assets': (assets as Input$ReleaseAssetsInput?),
      }));
  CopyWith$Input$ReleaseAssetsInput<TRes> get assets {
    final local$assets = _instance.assets;
    return local$assets == null
        ? CopyWith$Input$ReleaseAssetsInput.stub(_then(_instance))
        : CopyWith$Input$ReleaseAssetsInput(
            local$assets, (e) => call(assets: e));
  }
}

class _CopyWithStubImpl$Input$ReleaseCreateInput<TRes>
    implements CopyWith$Input$ReleaseCreateInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseCreateInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
    String? tagName,
    String? tagMessage,
    String? ref,
    String? name,
    String? description,
    String? releasedAt,
    List<String>? milestones,
    Input$ReleaseAssetsInput? assets,
  }) =>
      _res;
  CopyWith$Input$ReleaseAssetsInput<TRes> get assets =>
      CopyWith$Input$ReleaseAssetsInput.stub(_res);
}

class Input$ReleaseDeleteInput {
  factory Input$ReleaseDeleteInput({
    required String projectPath,
    String? clientMutationId,
    required String tagName,
  }) =>
      Input$ReleaseDeleteInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tagName': tagName,
      });

  Input$ReleaseDeleteInput._(this._$data);

  factory Input$ReleaseDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tagName = data['tagName'];
    result$data['tagName'] = (l$tagName as String);
    return Input$ReleaseDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get tagName => (_$data['tagName'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tagName = tagName;
    result$data['tagName'] = l$tagName;
    return result$data;
  }

  CopyWith$Input$ReleaseDeleteInput<Input$ReleaseDeleteInput> get copyWith =>
      CopyWith$Input$ReleaseDeleteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tagName = tagName;
    final lOther$tagName = other.tagName;
    if (l$tagName != lOther$tagName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    final l$tagName = tagName;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tagName,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseDeleteInput<TRes> {
  factory CopyWith$Input$ReleaseDeleteInput(
    Input$ReleaseDeleteInput instance,
    TRes Function(Input$ReleaseDeleteInput) then,
  ) = _CopyWithImpl$Input$ReleaseDeleteInput;

  factory CopyWith$Input$ReleaseDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseDeleteInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
    String? tagName,
  });
}

class _CopyWithImpl$Input$ReleaseDeleteInput<TRes>
    implements CopyWith$Input$ReleaseDeleteInput<TRes> {
  _CopyWithImpl$Input$ReleaseDeleteInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseDeleteInput _instance;

  final TRes Function(Input$ReleaseDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? tagName = _undefined,
  }) =>
      _then(Input$ReleaseDeleteInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tagName != _undefined && tagName != null)
          'tagName': (tagName as String),
      }));
}

class _CopyWithStubImpl$Input$ReleaseDeleteInput<TRes>
    implements CopyWith$Input$ReleaseDeleteInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseDeleteInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
    String? tagName,
  }) =>
      _res;
}

class Input$ReleaseUpdateInput {
  factory Input$ReleaseUpdateInput({
    required String projectPath,
    String? clientMutationId,
    required String tagName,
    String? name,
    String? description,
    String? releasedAt,
    List<String>? milestones,
  }) =>
      Input$ReleaseUpdateInput._({
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tagName': tagName,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (releasedAt != null) r'releasedAt': releasedAt,
        if (milestones != null) r'milestones': milestones,
      });

  Input$ReleaseUpdateInput._(this._$data);

  factory Input$ReleaseUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tagName = data['tagName'];
    result$data['tagName'] = (l$tagName as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('releasedAt')) {
      final l$releasedAt = data['releasedAt'];
      result$data['releasedAt'] = (l$releasedAt as String?);
    }
    if (data.containsKey('milestones')) {
      final l$milestones = data['milestones'];
      result$data['milestones'] =
          (l$milestones as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$ReleaseUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get tagName => (_$data['tagName'] as String);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get releasedAt => (_$data['releasedAt'] as String?);
  List<String>? get milestones => (_$data['milestones'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tagName = tagName;
    result$data['tagName'] = l$tagName;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('releasedAt')) {
      final l$releasedAt = releasedAt;
      result$data['releasedAt'] = l$releasedAt;
    }
    if (_$data.containsKey('milestones')) {
      final l$milestones = milestones;
      result$data['milestones'] = l$milestones?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ReleaseUpdateInput<Input$ReleaseUpdateInput> get copyWith =>
      CopyWith$Input$ReleaseUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tagName = tagName;
    final lOther$tagName = other.tagName;
    if (l$tagName != lOther$tagName) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$releasedAt = releasedAt;
    final lOther$releasedAt = other.releasedAt;
    if (_$data.containsKey('releasedAt') !=
        other._$data.containsKey('releasedAt')) {
      return false;
    }
    if (l$releasedAt != lOther$releasedAt) {
      return false;
    }
    final l$milestones = milestones;
    final lOther$milestones = other.milestones;
    if (_$data.containsKey('milestones') !=
        other._$data.containsKey('milestones')) {
      return false;
    }
    if (l$milestones != null && lOther$milestones != null) {
      if (l$milestones.length != lOther$milestones.length) {
        return false;
      }
      for (int i = 0; i < l$milestones.length; i++) {
        final l$milestones$entry = l$milestones[i];
        final lOther$milestones$entry = lOther$milestones[i];
        if (l$milestones$entry != lOther$milestones$entry) {
          return false;
        }
      }
    } else if (l$milestones != lOther$milestones) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    final l$tagName = tagName;
    final l$name = name;
    final l$description = description;
    final l$releasedAt = releasedAt;
    final l$milestones = milestones;
    return Object.hashAll([
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tagName,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('releasedAt') ? l$releasedAt : const {},
      _$data.containsKey('milestones')
          ? l$milestones == null
              ? null
              : Object.hashAll(l$milestones.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseUpdateInput<TRes> {
  factory CopyWith$Input$ReleaseUpdateInput(
    Input$ReleaseUpdateInput instance,
    TRes Function(Input$ReleaseUpdateInput) then,
  ) = _CopyWithImpl$Input$ReleaseUpdateInput;

  factory CopyWith$Input$ReleaseUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseUpdateInput;

  TRes call({
    String? projectPath,
    String? clientMutationId,
    String? tagName,
    String? name,
    String? description,
    String? releasedAt,
    List<String>? milestones,
  });
}

class _CopyWithImpl$Input$ReleaseUpdateInput<TRes>
    implements CopyWith$Input$ReleaseUpdateInput<TRes> {
  _CopyWithImpl$Input$ReleaseUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseUpdateInput _instance;

  final TRes Function(Input$ReleaseUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? tagName = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? releasedAt = _undefined,
    Object? milestones = _undefined,
  }) =>
      _then(Input$ReleaseUpdateInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tagName != _undefined && tagName != null)
          'tagName': (tagName as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (releasedAt != _undefined) 'releasedAt': (releasedAt as String?),
        if (milestones != _undefined)
          'milestones': (milestones as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$ReleaseUpdateInput<TRes>
    implements CopyWith$Input$ReleaseUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseUpdateInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? clientMutationId,
    String? tagName,
    String? name,
    String? description,
    String? releasedAt,
    List<String>? milestones,
  }) =>
      _res;
}

class Input$RemoveProjectFromSecurityDashboardInput {
  factory Input$RemoveProjectFromSecurityDashboardInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$RemoveProjectFromSecurityDashboardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$RemoveProjectFromSecurityDashboardInput._(this._$data);

  factory Input$RemoveProjectFromSecurityDashboardInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$RemoveProjectFromSecurityDashboardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$RemoveProjectFromSecurityDashboardInput<
          Input$RemoveProjectFromSecurityDashboardInput>
      get copyWith => CopyWith$Input$RemoveProjectFromSecurityDashboardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveProjectFromSecurityDashboardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$RemoveProjectFromSecurityDashboardInput<TRes> {
  factory CopyWith$Input$RemoveProjectFromSecurityDashboardInput(
    Input$RemoveProjectFromSecurityDashboardInput instance,
    TRes Function(Input$RemoveProjectFromSecurityDashboardInput) then,
  ) = _CopyWithImpl$Input$RemoveProjectFromSecurityDashboardInput;

  factory CopyWith$Input$RemoveProjectFromSecurityDashboardInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RemoveProjectFromSecurityDashboardInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$RemoveProjectFromSecurityDashboardInput<TRes>
    implements CopyWith$Input$RemoveProjectFromSecurityDashboardInput<TRes> {
  _CopyWithImpl$Input$RemoveProjectFromSecurityDashboardInput(
    this._instance,
    this._then,
  );

  final Input$RemoveProjectFromSecurityDashboardInput _instance;

  final TRes Function(Input$RemoveProjectFromSecurityDashboardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$RemoveProjectFromSecurityDashboardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveProjectFromSecurityDashboardInput<TRes>
    implements CopyWith$Input$RemoveProjectFromSecurityDashboardInput<TRes> {
  _CopyWithStubImpl$Input$RemoveProjectFromSecurityDashboardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$RepositionImageDiffNoteInput {
  factory Input$RepositionImageDiffNoteInput({
    String? clientMutationId,
    required String id,
    required Input$UpdateDiffImagePositionInput position,
  }) =>
      Input$RepositionImageDiffNoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'position': position,
      });

  Input$RepositionImageDiffNoteInput._(this._$data);

  factory Input$RepositionImageDiffNoteInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$position = data['position'];
    result$data['position'] = Input$UpdateDiffImagePositionInput.fromJson(
        (l$position as Map<String, dynamic>));
    return Input$RepositionImageDiffNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Input$UpdateDiffImagePositionInput get position =>
      (_$data['position'] as Input$UpdateDiffImagePositionInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$position = position;
    result$data['position'] = l$position.toJson();
    return result$data;
  }

  CopyWith$Input$RepositionImageDiffNoteInput<
          Input$RepositionImageDiffNoteInput>
      get copyWith => CopyWith$Input$RepositionImageDiffNoteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositionImageDiffNoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$position = position;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$position,
    ]);
  }
}

abstract class CopyWith$Input$RepositionImageDiffNoteInput<TRes> {
  factory CopyWith$Input$RepositionImageDiffNoteInput(
    Input$RepositionImageDiffNoteInput instance,
    TRes Function(Input$RepositionImageDiffNoteInput) then,
  ) = _CopyWithImpl$Input$RepositionImageDiffNoteInput;

  factory CopyWith$Input$RepositionImageDiffNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositionImageDiffNoteInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Input$UpdateDiffImagePositionInput? position,
  });
  CopyWith$Input$UpdateDiffImagePositionInput<TRes> get position;
}

class _CopyWithImpl$Input$RepositionImageDiffNoteInput<TRes>
    implements CopyWith$Input$RepositionImageDiffNoteInput<TRes> {
  _CopyWithImpl$Input$RepositionImageDiffNoteInput(
    this._instance,
    this._then,
  );

  final Input$RepositionImageDiffNoteInput _instance;

  final TRes Function(Input$RepositionImageDiffNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$RepositionImageDiffNoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (position != _undefined && position != null)
          'position': (position as Input$UpdateDiffImagePositionInput),
      }));
  CopyWith$Input$UpdateDiffImagePositionInput<TRes> get position {
    final local$position = _instance.position;
    return CopyWith$Input$UpdateDiffImagePositionInput(
        local$position, (e) => call(position: e));
  }
}

class _CopyWithStubImpl$Input$RepositionImageDiffNoteInput<TRes>
    implements CopyWith$Input$RepositionImageDiffNoteInput<TRes> {
  _CopyWithStubImpl$Input$RepositionImageDiffNoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Input$UpdateDiffImagePositionInput? position,
  }) =>
      _res;
  CopyWith$Input$UpdateDiffImagePositionInput<TRes> get position =>
      CopyWith$Input$UpdateDiffImagePositionInput.stub(_res);
}

class Input$RunnerDeleteInput {
  factory Input$RunnerDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$RunnerDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$RunnerDeleteInput._(this._$data);

  factory Input$RunnerDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$RunnerDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$RunnerDeleteInput<Input$RunnerDeleteInput> get copyWith =>
      CopyWith$Input$RunnerDeleteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RunnerDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$RunnerDeleteInput<TRes> {
  factory CopyWith$Input$RunnerDeleteInput(
    Input$RunnerDeleteInput instance,
    TRes Function(Input$RunnerDeleteInput) then,
  ) = _CopyWithImpl$Input$RunnerDeleteInput;

  factory CopyWith$Input$RunnerDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RunnerDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$RunnerDeleteInput<TRes>
    implements CopyWith$Input$RunnerDeleteInput<TRes> {
  _CopyWithImpl$Input$RunnerDeleteInput(
    this._instance,
    this._then,
  );

  final Input$RunnerDeleteInput _instance;

  final TRes Function(Input$RunnerDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$RunnerDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$RunnerDeleteInput<TRes>
    implements CopyWith$Input$RunnerDeleteInput<TRes> {
  _CopyWithStubImpl$Input$RunnerDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$RunnerUpdateInput {
  factory Input$RunnerUpdateInput({
    String? clientMutationId,
    required String id,
    String? description,
    String? maintenanceNote,
    int? maximumTimeout,
    Enum$CiRunnerAccessLevel? accessLevel,
    bool? paused,
    bool? locked,
    bool? runUntagged,
    List<String>? tagList,
    double? publicProjectsMinutesCostFactor,
    double? privateProjectsMinutesCostFactor,
  }) =>
      Input$RunnerUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (description != null) r'description': description,
        if (maintenanceNote != null) r'maintenanceNote': maintenanceNote,
        if (maximumTimeout != null) r'maximumTimeout': maximumTimeout,
        if (accessLevel != null) r'accessLevel': accessLevel,
        if (paused != null) r'paused': paused,
        if (locked != null) r'locked': locked,
        if (runUntagged != null) r'runUntagged': runUntagged,
        if (tagList != null) r'tagList': tagList,
        if (publicProjectsMinutesCostFactor != null)
          r'publicProjectsMinutesCostFactor': publicProjectsMinutesCostFactor,
        if (privateProjectsMinutesCostFactor != null)
          r'privateProjectsMinutesCostFactor': privateProjectsMinutesCostFactor,
      });

  Input$RunnerUpdateInput._(this._$data);

  factory Input$RunnerUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('maintenanceNote')) {
      final l$maintenanceNote = data['maintenanceNote'];
      result$data['maintenanceNote'] = (l$maintenanceNote as String?);
    }
    if (data.containsKey('maximumTimeout')) {
      final l$maximumTimeout = data['maximumTimeout'];
      result$data['maximumTimeout'] = (l$maximumTimeout as int?);
    }
    if (data.containsKey('accessLevel')) {
      final l$accessLevel = data['accessLevel'];
      result$data['accessLevel'] = l$accessLevel == null
          ? null
          : fromJson$Enum$CiRunnerAccessLevel((l$accessLevel as String));
    }
    if (data.containsKey('paused')) {
      final l$paused = data['paused'];
      result$data['paused'] = (l$paused as bool?);
    }
    if (data.containsKey('locked')) {
      final l$locked = data['locked'];
      result$data['locked'] = (l$locked as bool?);
    }
    if (data.containsKey('runUntagged')) {
      final l$runUntagged = data['runUntagged'];
      result$data['runUntagged'] = (l$runUntagged as bool?);
    }
    if (data.containsKey('tagList')) {
      final l$tagList = data['tagList'];
      result$data['tagList'] =
          (l$tagList as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('publicProjectsMinutesCostFactor')) {
      final l$publicProjectsMinutesCostFactor =
          data['publicProjectsMinutesCostFactor'];
      result$data['publicProjectsMinutesCostFactor'] =
          (l$publicProjectsMinutesCostFactor as num?)?.toDouble();
    }
    if (data.containsKey('privateProjectsMinutesCostFactor')) {
      final l$privateProjectsMinutesCostFactor =
          data['privateProjectsMinutesCostFactor'];
      result$data['privateProjectsMinutesCostFactor'] =
          (l$privateProjectsMinutesCostFactor as num?)?.toDouble();
    }
    return Input$RunnerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get description => (_$data['description'] as String?);
  String? get maintenanceNote => (_$data['maintenanceNote'] as String?);
  int? get maximumTimeout => (_$data['maximumTimeout'] as int?);
  Enum$CiRunnerAccessLevel? get accessLevel =>
      (_$data['accessLevel'] as Enum$CiRunnerAccessLevel?);
  bool? get paused => (_$data['paused'] as bool?);
  bool? get locked => (_$data['locked'] as bool?);
  bool? get runUntagged => (_$data['runUntagged'] as bool?);
  List<String>? get tagList => (_$data['tagList'] as List<String>?);
  double? get publicProjectsMinutesCostFactor =>
      (_$data['publicProjectsMinutesCostFactor'] as double?);
  double? get privateProjectsMinutesCostFactor =>
      (_$data['privateProjectsMinutesCostFactor'] as double?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('maintenanceNote')) {
      final l$maintenanceNote = maintenanceNote;
      result$data['maintenanceNote'] = l$maintenanceNote;
    }
    if (_$data.containsKey('maximumTimeout')) {
      final l$maximumTimeout = maximumTimeout;
      result$data['maximumTimeout'] = l$maximumTimeout;
    }
    if (_$data.containsKey('accessLevel')) {
      final l$accessLevel = accessLevel;
      result$data['accessLevel'] = l$accessLevel == null
          ? null
          : toJson$Enum$CiRunnerAccessLevel(l$accessLevel);
    }
    if (_$data.containsKey('paused')) {
      final l$paused = paused;
      result$data['paused'] = l$paused;
    }
    if (_$data.containsKey('locked')) {
      final l$locked = locked;
      result$data['locked'] = l$locked;
    }
    if (_$data.containsKey('runUntagged')) {
      final l$runUntagged = runUntagged;
      result$data['runUntagged'] = l$runUntagged;
    }
    if (_$data.containsKey('tagList')) {
      final l$tagList = tagList;
      result$data['tagList'] = l$tagList?.map((e) => e).toList();
    }
    if (_$data.containsKey('publicProjectsMinutesCostFactor')) {
      final l$publicProjectsMinutesCostFactor = publicProjectsMinutesCostFactor;
      result$data['publicProjectsMinutesCostFactor'] =
          l$publicProjectsMinutesCostFactor;
    }
    if (_$data.containsKey('privateProjectsMinutesCostFactor')) {
      final l$privateProjectsMinutesCostFactor =
          privateProjectsMinutesCostFactor;
      result$data['privateProjectsMinutesCostFactor'] =
          l$privateProjectsMinutesCostFactor;
    }
    return result$data;
  }

  CopyWith$Input$RunnerUpdateInput<Input$RunnerUpdateInput> get copyWith =>
      CopyWith$Input$RunnerUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RunnerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$maintenanceNote = maintenanceNote;
    final lOther$maintenanceNote = other.maintenanceNote;
    if (_$data.containsKey('maintenanceNote') !=
        other._$data.containsKey('maintenanceNote')) {
      return false;
    }
    if (l$maintenanceNote != lOther$maintenanceNote) {
      return false;
    }
    final l$maximumTimeout = maximumTimeout;
    final lOther$maximumTimeout = other.maximumTimeout;
    if (_$data.containsKey('maximumTimeout') !=
        other._$data.containsKey('maximumTimeout')) {
      return false;
    }
    if (l$maximumTimeout != lOther$maximumTimeout) {
      return false;
    }
    final l$accessLevel = accessLevel;
    final lOther$accessLevel = other.accessLevel;
    if (_$data.containsKey('accessLevel') !=
        other._$data.containsKey('accessLevel')) {
      return false;
    }
    if (l$accessLevel != lOther$accessLevel) {
      return false;
    }
    final l$paused = paused;
    final lOther$paused = other.paused;
    if (_$data.containsKey('paused') != other._$data.containsKey('paused')) {
      return false;
    }
    if (l$paused != lOther$paused) {
      return false;
    }
    final l$locked = locked;
    final lOther$locked = other.locked;
    if (_$data.containsKey('locked') != other._$data.containsKey('locked')) {
      return false;
    }
    if (l$locked != lOther$locked) {
      return false;
    }
    final l$runUntagged = runUntagged;
    final lOther$runUntagged = other.runUntagged;
    if (_$data.containsKey('runUntagged') !=
        other._$data.containsKey('runUntagged')) {
      return false;
    }
    if (l$runUntagged != lOther$runUntagged) {
      return false;
    }
    final l$tagList = tagList;
    final lOther$tagList = other.tagList;
    if (_$data.containsKey('tagList') != other._$data.containsKey('tagList')) {
      return false;
    }
    if (l$tagList != null && lOther$tagList != null) {
      if (l$tagList.length != lOther$tagList.length) {
        return false;
      }
      for (int i = 0; i < l$tagList.length; i++) {
        final l$tagList$entry = l$tagList[i];
        final lOther$tagList$entry = lOther$tagList[i];
        if (l$tagList$entry != lOther$tagList$entry) {
          return false;
        }
      }
    } else if (l$tagList != lOther$tagList) {
      return false;
    }
    final l$publicProjectsMinutesCostFactor = publicProjectsMinutesCostFactor;
    final lOther$publicProjectsMinutesCostFactor =
        other.publicProjectsMinutesCostFactor;
    if (_$data.containsKey('publicProjectsMinutesCostFactor') !=
        other._$data.containsKey('publicProjectsMinutesCostFactor')) {
      return false;
    }
    if (l$publicProjectsMinutesCostFactor !=
        lOther$publicProjectsMinutesCostFactor) {
      return false;
    }
    final l$privateProjectsMinutesCostFactor = privateProjectsMinutesCostFactor;
    final lOther$privateProjectsMinutesCostFactor =
        other.privateProjectsMinutesCostFactor;
    if (_$data.containsKey('privateProjectsMinutesCostFactor') !=
        other._$data.containsKey('privateProjectsMinutesCostFactor')) {
      return false;
    }
    if (l$privateProjectsMinutesCostFactor !=
        lOther$privateProjectsMinutesCostFactor) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$description = description;
    final l$maintenanceNote = maintenanceNote;
    final l$maximumTimeout = maximumTimeout;
    final l$accessLevel = accessLevel;
    final l$paused = paused;
    final l$locked = locked;
    final l$runUntagged = runUntagged;
    final l$tagList = tagList;
    final l$publicProjectsMinutesCostFactor = publicProjectsMinutesCostFactor;
    final l$privateProjectsMinutesCostFactor = privateProjectsMinutesCostFactor;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('maintenanceNote') ? l$maintenanceNote : const {},
      _$data.containsKey('maximumTimeout') ? l$maximumTimeout : const {},
      _$data.containsKey('accessLevel') ? l$accessLevel : const {},
      _$data.containsKey('paused') ? l$paused : const {},
      _$data.containsKey('locked') ? l$locked : const {},
      _$data.containsKey('runUntagged') ? l$runUntagged : const {},
      _$data.containsKey('tagList')
          ? l$tagList == null
              ? null
              : Object.hashAll(l$tagList.map((v) => v))
          : const {},
      _$data.containsKey('publicProjectsMinutesCostFactor')
          ? l$publicProjectsMinutesCostFactor
          : const {},
      _$data.containsKey('privateProjectsMinutesCostFactor')
          ? l$privateProjectsMinutesCostFactor
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RunnerUpdateInput<TRes> {
  factory CopyWith$Input$RunnerUpdateInput(
    Input$RunnerUpdateInput instance,
    TRes Function(Input$RunnerUpdateInput) then,
  ) = _CopyWithImpl$Input$RunnerUpdateInput;

  factory CopyWith$Input$RunnerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RunnerUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? description,
    String? maintenanceNote,
    int? maximumTimeout,
    Enum$CiRunnerAccessLevel? accessLevel,
    bool? paused,
    bool? locked,
    bool? runUntagged,
    List<String>? tagList,
    double? publicProjectsMinutesCostFactor,
    double? privateProjectsMinutesCostFactor,
  });
}

class _CopyWithImpl$Input$RunnerUpdateInput<TRes>
    implements CopyWith$Input$RunnerUpdateInput<TRes> {
  _CopyWithImpl$Input$RunnerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$RunnerUpdateInput _instance;

  final TRes Function(Input$RunnerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? description = _undefined,
    Object? maintenanceNote = _undefined,
    Object? maximumTimeout = _undefined,
    Object? accessLevel = _undefined,
    Object? paused = _undefined,
    Object? locked = _undefined,
    Object? runUntagged = _undefined,
    Object? tagList = _undefined,
    Object? publicProjectsMinutesCostFactor = _undefined,
    Object? privateProjectsMinutesCostFactor = _undefined,
  }) =>
      _then(Input$RunnerUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (description != _undefined) 'description': (description as String?),
        if (maintenanceNote != _undefined)
          'maintenanceNote': (maintenanceNote as String?),
        if (maximumTimeout != _undefined)
          'maximumTimeout': (maximumTimeout as int?),
        if (accessLevel != _undefined)
          'accessLevel': (accessLevel as Enum$CiRunnerAccessLevel?),
        if (paused != _undefined) 'paused': (paused as bool?),
        if (locked != _undefined) 'locked': (locked as bool?),
        if (runUntagged != _undefined) 'runUntagged': (runUntagged as bool?),
        if (tagList != _undefined) 'tagList': (tagList as List<String>?),
        if (publicProjectsMinutesCostFactor != _undefined)
          'publicProjectsMinutesCostFactor':
              (publicProjectsMinutesCostFactor as double?),
        if (privateProjectsMinutesCostFactor != _undefined)
          'privateProjectsMinutesCostFactor':
              (privateProjectsMinutesCostFactor as double?),
      }));
}

class _CopyWithStubImpl$Input$RunnerUpdateInput<TRes>
    implements CopyWith$Input$RunnerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$RunnerUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? description,
    String? maintenanceNote,
    int? maximumTimeout,
    Enum$CiRunnerAccessLevel? accessLevel,
    bool? paused,
    bool? locked,
    bool? runUntagged,
    List<String>? tagList,
    double? publicProjectsMinutesCostFactor,
    double? privateProjectsMinutesCostFactor,
  }) =>
      _res;
}

class Input$RunnersRegistrationTokenResetInput {
  factory Input$RunnersRegistrationTokenResetInput({
    String? clientMutationId,
    required Enum$CiRunnerType type,
    String? id,
  }) =>
      Input$RunnersRegistrationTokenResetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'type': type,
        if (id != null) r'id': id,
      });

  Input$RunnersRegistrationTokenResetInput._(this._$data);

  factory Input$RunnersRegistrationTokenResetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$CiRunnerType((l$type as String));
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    return Input$RunnersRegistrationTokenResetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$CiRunnerType get type => (_$data['type'] as Enum$CiRunnerType);
  String? get id => (_$data['id'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$type = type;
    result$data['type'] = toJson$Enum$CiRunnerType(l$type);
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$RunnersRegistrationTokenResetInput<
          Input$RunnersRegistrationTokenResetInput>
      get copyWith => CopyWith$Input$RunnersRegistrationTokenResetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RunnersRegistrationTokenResetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$type = type;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$type,
      _$data.containsKey('id') ? l$id : const {},
    ]);
  }
}

abstract class CopyWith$Input$RunnersRegistrationTokenResetInput<TRes> {
  factory CopyWith$Input$RunnersRegistrationTokenResetInput(
    Input$RunnersRegistrationTokenResetInput instance,
    TRes Function(Input$RunnersRegistrationTokenResetInput) then,
  ) = _CopyWithImpl$Input$RunnersRegistrationTokenResetInput;

  factory CopyWith$Input$RunnersRegistrationTokenResetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RunnersRegistrationTokenResetInput;

  TRes call({
    String? clientMutationId,
    Enum$CiRunnerType? type,
    String? id,
  });
}

class _CopyWithImpl$Input$RunnersRegistrationTokenResetInput<TRes>
    implements CopyWith$Input$RunnersRegistrationTokenResetInput<TRes> {
  _CopyWithImpl$Input$RunnersRegistrationTokenResetInput(
    this._instance,
    this._then,
  );

  final Input$RunnersRegistrationTokenResetInput _instance;

  final TRes Function(Input$RunnersRegistrationTokenResetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? type = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$RunnersRegistrationTokenResetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (type != _undefined && type != null)
          'type': (type as Enum$CiRunnerType),
        if (id != _undefined) 'id': (id as String?),
      }));
}

class _CopyWithStubImpl$Input$RunnersRegistrationTokenResetInput<TRes>
    implements CopyWith$Input$RunnersRegistrationTokenResetInput<TRes> {
  _CopyWithStubImpl$Input$RunnersRegistrationTokenResetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$CiRunnerType? type,
    String? id,
  }) =>
      _res;
}

class Input$SastCiConfigurationAnalyzersEntityInput {
  factory Input$SastCiConfigurationAnalyzersEntityInput({
    required String name,
    required bool enabled,
    List<Input$SastCiConfigurationEntityInput>? variables,
  }) =>
      Input$SastCiConfigurationAnalyzersEntityInput._({
        r'name': name,
        r'enabled': enabled,
        if (variables != null) r'variables': variables,
      });

  Input$SastCiConfigurationAnalyzersEntityInput._(this._$data);

  factory Input$SastCiConfigurationAnalyzersEntityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$enabled = data['enabled'];
    result$data['enabled'] = (l$enabled as bool);
    if (data.containsKey('variables')) {
      final l$variables = data['variables'];
      result$data['variables'] = (l$variables as List<dynamic>?)
          ?.map((e) => Input$SastCiConfigurationEntityInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$SastCiConfigurationAnalyzersEntityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  bool get enabled => (_$data['enabled'] as bool);
  List<Input$SastCiConfigurationEntityInput>? get variables =>
      (_$data['variables'] as List<Input$SastCiConfigurationEntityInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$enabled = enabled;
    result$data['enabled'] = l$enabled;
    if (_$data.containsKey('variables')) {
      final l$variables = variables;
      result$data['variables'] = l$variables?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$SastCiConfigurationAnalyzersEntityInput<
          Input$SastCiConfigurationAnalyzersEntityInput>
      get copyWith => CopyWith$Input$SastCiConfigurationAnalyzersEntityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SastCiConfigurationAnalyzersEntityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (l$enabled != lOther$enabled) {
      return false;
    }
    final l$variables = variables;
    final lOther$variables = other.variables;
    if (_$data.containsKey('variables') !=
        other._$data.containsKey('variables')) {
      return false;
    }
    if (l$variables != null && lOther$variables != null) {
      if (l$variables.length != lOther$variables.length) {
        return false;
      }
      for (int i = 0; i < l$variables.length; i++) {
        final l$variables$entry = l$variables[i];
        final lOther$variables$entry = lOther$variables[i];
        if (l$variables$entry != lOther$variables$entry) {
          return false;
        }
      }
    } else if (l$variables != lOther$variables) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$enabled = enabled;
    final l$variables = variables;
    return Object.hashAll([
      l$name,
      l$enabled,
      _$data.containsKey('variables')
          ? l$variables == null
              ? null
              : Object.hashAll(l$variables.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SastCiConfigurationAnalyzersEntityInput<TRes> {
  factory CopyWith$Input$SastCiConfigurationAnalyzersEntityInput(
    Input$SastCiConfigurationAnalyzersEntityInput instance,
    TRes Function(Input$SastCiConfigurationAnalyzersEntityInput) then,
  ) = _CopyWithImpl$Input$SastCiConfigurationAnalyzersEntityInput;

  factory CopyWith$Input$SastCiConfigurationAnalyzersEntityInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SastCiConfigurationAnalyzersEntityInput;

  TRes call({
    String? name,
    bool? enabled,
    List<Input$SastCiConfigurationEntityInput>? variables,
  });
  TRes variables(
      Iterable<Input$SastCiConfigurationEntityInput>? Function(
              Iterable<
                  CopyWith$Input$SastCiConfigurationEntityInput<
                      Input$SastCiConfigurationEntityInput>>?)
          _fn);
}

class _CopyWithImpl$Input$SastCiConfigurationAnalyzersEntityInput<TRes>
    implements CopyWith$Input$SastCiConfigurationAnalyzersEntityInput<TRes> {
  _CopyWithImpl$Input$SastCiConfigurationAnalyzersEntityInput(
    this._instance,
    this._then,
  );

  final Input$SastCiConfigurationAnalyzersEntityInput _instance;

  final TRes Function(Input$SastCiConfigurationAnalyzersEntityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? enabled = _undefined,
    Object? variables = _undefined,
  }) =>
      _then(Input$SastCiConfigurationAnalyzersEntityInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (enabled != _undefined && enabled != null)
          'enabled': (enabled as bool),
        if (variables != _undefined)
          'variables':
              (variables as List<Input$SastCiConfigurationEntityInput>?),
      }));
  TRes variables(
          Iterable<Input$SastCiConfigurationEntityInput>? Function(
                  Iterable<
                      CopyWith$Input$SastCiConfigurationEntityInput<
                          Input$SastCiConfigurationEntityInput>>?)
              _fn) =>
      call(
          variables: _fn(_instance.variables
              ?.map((e) => CopyWith$Input$SastCiConfigurationEntityInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$SastCiConfigurationAnalyzersEntityInput<TRes>
    implements CopyWith$Input$SastCiConfigurationAnalyzersEntityInput<TRes> {
  _CopyWithStubImpl$Input$SastCiConfigurationAnalyzersEntityInput(this._res);

  TRes _res;

  call({
    String? name,
    bool? enabled,
    List<Input$SastCiConfigurationEntityInput>? variables,
  }) =>
      _res;
  variables(_fn) => _res;
}

class Input$SastCiConfigurationEntityInput {
  factory Input$SastCiConfigurationEntityInput({
    required String field,
    required String defaultValue,
    required String value,
  }) =>
      Input$SastCiConfigurationEntityInput._({
        r'field': field,
        r'defaultValue': defaultValue,
        r'value': value,
      });

  Input$SastCiConfigurationEntityInput._(this._$data);

  factory Input$SastCiConfigurationEntityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = (l$field as String);
    final l$defaultValue = data['defaultValue'];
    result$data['defaultValue'] = (l$defaultValue as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$SastCiConfigurationEntityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get field => (_$data['field'] as String);
  String get defaultValue => (_$data['defaultValue'] as String);
  String get value => (_$data['value'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = l$field;
    final l$defaultValue = defaultValue;
    result$data['defaultValue'] = l$defaultValue;
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$SastCiConfigurationEntityInput<
          Input$SastCiConfigurationEntityInput>
      get copyWith => CopyWith$Input$SastCiConfigurationEntityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SastCiConfigurationEntityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$defaultValue = defaultValue;
    final lOther$defaultValue = other.defaultValue;
    if (l$defaultValue != lOther$defaultValue) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$defaultValue = defaultValue;
    final l$value = value;
    return Object.hashAll([
      l$field,
      l$defaultValue,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$SastCiConfigurationEntityInput<TRes> {
  factory CopyWith$Input$SastCiConfigurationEntityInput(
    Input$SastCiConfigurationEntityInput instance,
    TRes Function(Input$SastCiConfigurationEntityInput) then,
  ) = _CopyWithImpl$Input$SastCiConfigurationEntityInput;

  factory CopyWith$Input$SastCiConfigurationEntityInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SastCiConfigurationEntityInput;

  TRes call({
    String? field,
    String? defaultValue,
    String? value,
  });
}

class _CopyWithImpl$Input$SastCiConfigurationEntityInput<TRes>
    implements CopyWith$Input$SastCiConfigurationEntityInput<TRes> {
  _CopyWithImpl$Input$SastCiConfigurationEntityInput(
    this._instance,
    this._then,
  );

  final Input$SastCiConfigurationEntityInput _instance;

  final TRes Function(Input$SastCiConfigurationEntityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? defaultValue = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$SastCiConfigurationEntityInput._({
        ..._instance._$data,
        if (field != _undefined && field != null) 'field': (field as String),
        if (defaultValue != _undefined && defaultValue != null)
          'defaultValue': (defaultValue as String),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$SastCiConfigurationEntityInput<TRes>
    implements CopyWith$Input$SastCiConfigurationEntityInput<TRes> {
  _CopyWithStubImpl$Input$SastCiConfigurationEntityInput(this._res);

  TRes _res;

  call({
    String? field,
    String? defaultValue,
    String? value,
  }) =>
      _res;
}

class Input$SastCiConfigurationInput {
  factory Input$SastCiConfigurationInput({
    List<Input$SastCiConfigurationEntityInput>? global,
    List<Input$SastCiConfigurationEntityInput>? pipeline,
    List<Input$SastCiConfigurationAnalyzersEntityInput>? analyzers,
  }) =>
      Input$SastCiConfigurationInput._({
        if (global != null) r'global': global,
        if (pipeline != null) r'pipeline': pipeline,
        if (analyzers != null) r'analyzers': analyzers,
      });

  Input$SastCiConfigurationInput._(this._$data);

  factory Input$SastCiConfigurationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('global')) {
      final l$global = data['global'];
      result$data['global'] = (l$global as List<dynamic>?)
          ?.map((e) => Input$SastCiConfigurationEntityInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('pipeline')) {
      final l$pipeline = data['pipeline'];
      result$data['pipeline'] = (l$pipeline as List<dynamic>?)
          ?.map((e) => Input$SastCiConfigurationEntityInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('analyzers')) {
      final l$analyzers = data['analyzers'];
      result$data['analyzers'] = (l$analyzers as List<dynamic>?)
          ?.map((e) => Input$SastCiConfigurationAnalyzersEntityInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$SastCiConfigurationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SastCiConfigurationEntityInput>? get global =>
      (_$data['global'] as List<Input$SastCiConfigurationEntityInput>?);
  List<Input$SastCiConfigurationEntityInput>? get pipeline =>
      (_$data['pipeline'] as List<Input$SastCiConfigurationEntityInput>?);
  List<Input$SastCiConfigurationAnalyzersEntityInput>? get analyzers =>
      (_$data['analyzers']
          as List<Input$SastCiConfigurationAnalyzersEntityInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('global')) {
      final l$global = global;
      result$data['global'] = l$global?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('pipeline')) {
      final l$pipeline = pipeline;
      result$data['pipeline'] = l$pipeline?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('analyzers')) {
      final l$analyzers = analyzers;
      result$data['analyzers'] = l$analyzers?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$SastCiConfigurationInput<Input$SastCiConfigurationInput>
      get copyWith => CopyWith$Input$SastCiConfigurationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SastCiConfigurationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$global = global;
    final lOther$global = other.global;
    if (_$data.containsKey('global') != other._$data.containsKey('global')) {
      return false;
    }
    if (l$global != null && lOther$global != null) {
      if (l$global.length != lOther$global.length) {
        return false;
      }
      for (int i = 0; i < l$global.length; i++) {
        final l$global$entry = l$global[i];
        final lOther$global$entry = lOther$global[i];
        if (l$global$entry != lOther$global$entry) {
          return false;
        }
      }
    } else if (l$global != lOther$global) {
      return false;
    }
    final l$pipeline = pipeline;
    final lOther$pipeline = other.pipeline;
    if (_$data.containsKey('pipeline') !=
        other._$data.containsKey('pipeline')) {
      return false;
    }
    if (l$pipeline != null && lOther$pipeline != null) {
      if (l$pipeline.length != lOther$pipeline.length) {
        return false;
      }
      for (int i = 0; i < l$pipeline.length; i++) {
        final l$pipeline$entry = l$pipeline[i];
        final lOther$pipeline$entry = lOther$pipeline[i];
        if (l$pipeline$entry != lOther$pipeline$entry) {
          return false;
        }
      }
    } else if (l$pipeline != lOther$pipeline) {
      return false;
    }
    final l$analyzers = analyzers;
    final lOther$analyzers = other.analyzers;
    if (_$data.containsKey('analyzers') !=
        other._$data.containsKey('analyzers')) {
      return false;
    }
    if (l$analyzers != null && lOther$analyzers != null) {
      if (l$analyzers.length != lOther$analyzers.length) {
        return false;
      }
      for (int i = 0; i < l$analyzers.length; i++) {
        final l$analyzers$entry = l$analyzers[i];
        final lOther$analyzers$entry = lOther$analyzers[i];
        if (l$analyzers$entry != lOther$analyzers$entry) {
          return false;
        }
      }
    } else if (l$analyzers != lOther$analyzers) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$global = global;
    final l$pipeline = pipeline;
    final l$analyzers = analyzers;
    return Object.hashAll([
      _$data.containsKey('global')
          ? l$global == null
              ? null
              : Object.hashAll(l$global.map((v) => v))
          : const {},
      _$data.containsKey('pipeline')
          ? l$pipeline == null
              ? null
              : Object.hashAll(l$pipeline.map((v) => v))
          : const {},
      _$data.containsKey('analyzers')
          ? l$analyzers == null
              ? null
              : Object.hashAll(l$analyzers.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SastCiConfigurationInput<TRes> {
  factory CopyWith$Input$SastCiConfigurationInput(
    Input$SastCiConfigurationInput instance,
    TRes Function(Input$SastCiConfigurationInput) then,
  ) = _CopyWithImpl$Input$SastCiConfigurationInput;

  factory CopyWith$Input$SastCiConfigurationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SastCiConfigurationInput;

  TRes call({
    List<Input$SastCiConfigurationEntityInput>? global,
    List<Input$SastCiConfigurationEntityInput>? pipeline,
    List<Input$SastCiConfigurationAnalyzersEntityInput>? analyzers,
  });
  TRes global(
      Iterable<Input$SastCiConfigurationEntityInput>? Function(
              Iterable<
                  CopyWith$Input$SastCiConfigurationEntityInput<
                      Input$SastCiConfigurationEntityInput>>?)
          _fn);
  TRes pipeline(
      Iterable<Input$SastCiConfigurationEntityInput>? Function(
              Iterable<
                  CopyWith$Input$SastCiConfigurationEntityInput<
                      Input$SastCiConfigurationEntityInput>>?)
          _fn);
  TRes analyzers(
      Iterable<Input$SastCiConfigurationAnalyzersEntityInput>? Function(
              Iterable<
                  CopyWith$Input$SastCiConfigurationAnalyzersEntityInput<
                      Input$SastCiConfigurationAnalyzersEntityInput>>?)
          _fn);
}

class _CopyWithImpl$Input$SastCiConfigurationInput<TRes>
    implements CopyWith$Input$SastCiConfigurationInput<TRes> {
  _CopyWithImpl$Input$SastCiConfigurationInput(
    this._instance,
    this._then,
  );

  final Input$SastCiConfigurationInput _instance;

  final TRes Function(Input$SastCiConfigurationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? global = _undefined,
    Object? pipeline = _undefined,
    Object? analyzers = _undefined,
  }) =>
      _then(Input$SastCiConfigurationInput._({
        ..._instance._$data,
        if (global != _undefined)
          'global': (global as List<Input$SastCiConfigurationEntityInput>?),
        if (pipeline != _undefined)
          'pipeline': (pipeline as List<Input$SastCiConfigurationEntityInput>?),
        if (analyzers != _undefined)
          'analyzers': (analyzers
              as List<Input$SastCiConfigurationAnalyzersEntityInput>?),
      }));
  TRes global(
          Iterable<Input$SastCiConfigurationEntityInput>? Function(
                  Iterable<
                      CopyWith$Input$SastCiConfigurationEntityInput<
                          Input$SastCiConfigurationEntityInput>>?)
              _fn) =>
      call(
          global: _fn(_instance.global
              ?.map((e) => CopyWith$Input$SastCiConfigurationEntityInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes pipeline(
          Iterable<Input$SastCiConfigurationEntityInput>? Function(
                  Iterable<
                      CopyWith$Input$SastCiConfigurationEntityInput<
                          Input$SastCiConfigurationEntityInput>>?)
              _fn) =>
      call(
          pipeline: _fn(_instance.pipeline
              ?.map((e) => CopyWith$Input$SastCiConfigurationEntityInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes analyzers(
          Iterable<Input$SastCiConfigurationAnalyzersEntityInput>? Function(
                  Iterable<
                      CopyWith$Input$SastCiConfigurationAnalyzersEntityInput<
                          Input$SastCiConfigurationAnalyzersEntityInput>>?)
              _fn) =>
      call(
          analyzers: _fn(_instance.analyzers?.map(
              (e) => CopyWith$Input$SastCiConfigurationAnalyzersEntityInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$SastCiConfigurationInput<TRes>
    implements CopyWith$Input$SastCiConfigurationInput<TRes> {
  _CopyWithStubImpl$Input$SastCiConfigurationInput(this._res);

  TRes _res;

  call({
    List<Input$SastCiConfigurationEntityInput>? global,
    List<Input$SastCiConfigurationEntityInput>? pipeline,
    List<Input$SastCiConfigurationAnalyzersEntityInput>? analyzers,
  }) =>
      _res;
  global(_fn) => _res;
  pipeline(_fn) => _res;
  analyzers(_fn) => _res;
}

class Input$SavedReplyCreateInput {
  factory Input$SavedReplyCreateInput({
    String? clientMutationId,
    required String name,
    required String content,
  }) =>
      Input$SavedReplyCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'content': content,
      });

  Input$SavedReplyCreateInput._(this._$data);

  factory Input$SavedReplyCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    return Input$SavedReplyCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get content => (_$data['content'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$content = content;
    result$data['content'] = l$content;
    return result$data;
  }

  CopyWith$Input$SavedReplyCreateInput<Input$SavedReplyCreateInput>
      get copyWith => CopyWith$Input$SavedReplyCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SavedReplyCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$content = content;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$content,
    ]);
  }
}

abstract class CopyWith$Input$SavedReplyCreateInput<TRes> {
  factory CopyWith$Input$SavedReplyCreateInput(
    Input$SavedReplyCreateInput instance,
    TRes Function(Input$SavedReplyCreateInput) then,
  ) = _CopyWithImpl$Input$SavedReplyCreateInput;

  factory CopyWith$Input$SavedReplyCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SavedReplyCreateInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? content,
  });
}

class _CopyWithImpl$Input$SavedReplyCreateInput<TRes>
    implements CopyWith$Input$SavedReplyCreateInput<TRes> {
  _CopyWithImpl$Input$SavedReplyCreateInput(
    this._instance,
    this._then,
  );

  final Input$SavedReplyCreateInput _instance;

  final TRes Function(Input$SavedReplyCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? content = _undefined,
  }) =>
      _then(Input$SavedReplyCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (content != _undefined && content != null)
          'content': (content as String),
      }));
}

class _CopyWithStubImpl$Input$SavedReplyCreateInput<TRes>
    implements CopyWith$Input$SavedReplyCreateInput<TRes> {
  _CopyWithStubImpl$Input$SavedReplyCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? content,
  }) =>
      _res;
}

class Input$SavedReplyDestroyInput {
  factory Input$SavedReplyDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$SavedReplyDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$SavedReplyDestroyInput._(this._$data);

  factory Input$SavedReplyDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$SavedReplyDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$SavedReplyDestroyInput<Input$SavedReplyDestroyInput>
      get copyWith => CopyWith$Input$SavedReplyDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SavedReplyDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$SavedReplyDestroyInput<TRes> {
  factory CopyWith$Input$SavedReplyDestroyInput(
    Input$SavedReplyDestroyInput instance,
    TRes Function(Input$SavedReplyDestroyInput) then,
  ) = _CopyWithImpl$Input$SavedReplyDestroyInput;

  factory CopyWith$Input$SavedReplyDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SavedReplyDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$SavedReplyDestroyInput<TRes>
    implements CopyWith$Input$SavedReplyDestroyInput<TRes> {
  _CopyWithImpl$Input$SavedReplyDestroyInput(
    this._instance,
    this._then,
  );

  final Input$SavedReplyDestroyInput _instance;

  final TRes Function(Input$SavedReplyDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$SavedReplyDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$SavedReplyDestroyInput<TRes>
    implements CopyWith$Input$SavedReplyDestroyInput<TRes> {
  _CopyWithStubImpl$Input$SavedReplyDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$SavedReplyUpdateInput {
  factory Input$SavedReplyUpdateInput({
    String? clientMutationId,
    required String id,
    required String name,
    required String content,
  }) =>
      Input$SavedReplyUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'name': name,
        r'content': content,
      });

  Input$SavedReplyUpdateInput._(this._$data);

  factory Input$SavedReplyUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    return Input$SavedReplyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String get name => (_$data['name'] as String);
  String get content => (_$data['content'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$name = name;
    result$data['name'] = l$name;
    final l$content = content;
    result$data['content'] = l$content;
    return result$data;
  }

  CopyWith$Input$SavedReplyUpdateInput<Input$SavedReplyUpdateInput>
      get copyWith => CopyWith$Input$SavedReplyUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SavedReplyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$name = name;
    final l$content = content;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$name,
      l$content,
    ]);
  }
}

abstract class CopyWith$Input$SavedReplyUpdateInput<TRes> {
  factory CopyWith$Input$SavedReplyUpdateInput(
    Input$SavedReplyUpdateInput instance,
    TRes Function(Input$SavedReplyUpdateInput) then,
  ) = _CopyWithImpl$Input$SavedReplyUpdateInput;

  factory CopyWith$Input$SavedReplyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SavedReplyUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? name,
    String? content,
  });
}

class _CopyWithImpl$Input$SavedReplyUpdateInput<TRes>
    implements CopyWith$Input$SavedReplyUpdateInput<TRes> {
  _CopyWithImpl$Input$SavedReplyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SavedReplyUpdateInput _instance;

  final TRes Function(Input$SavedReplyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? content = _undefined,
  }) =>
      _then(Input$SavedReplyUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (content != _undefined && content != null)
          'content': (content as String),
      }));
}

class _CopyWithStubImpl$Input$SavedReplyUpdateInput<TRes>
    implements CopyWith$Input$SavedReplyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SavedReplyUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? name,
    String? content,
  }) =>
      _res;
}

class Input$ScanExecutionPolicyCommitInput {
  factory Input$ScanExecutionPolicyCommitInput({
    String? clientMutationId,
    String? fullPath,
    required String policyYaml,
    required Enum$MutationOperationMode operationMode,
    String? name,
  }) =>
      Input$ScanExecutionPolicyCommitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (fullPath != null) r'fullPath': fullPath,
        r'policyYaml': policyYaml,
        r'operationMode': operationMode,
        if (name != null) r'name': name,
      });

  Input$ScanExecutionPolicyCommitInput._(this._$data);

  factory Input$ScanExecutionPolicyCommitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('fullPath')) {
      final l$fullPath = data['fullPath'];
      result$data['fullPath'] = (l$fullPath as String?);
    }
    final l$policyYaml = data['policyYaml'];
    result$data['policyYaml'] = (l$policyYaml as String);
    final l$operationMode = data['operationMode'];
    result$data['operationMode'] =
        fromJson$Enum$MutationOperationMode((l$operationMode as String));
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$ScanExecutionPolicyCommitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get fullPath => (_$data['fullPath'] as String?);
  String get policyYaml => (_$data['policyYaml'] as String);
  Enum$MutationOperationMode get operationMode =>
      (_$data['operationMode'] as Enum$MutationOperationMode);
  String? get name => (_$data['name'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('fullPath')) {
      final l$fullPath = fullPath;
      result$data['fullPath'] = l$fullPath;
    }
    final l$policyYaml = policyYaml;
    result$data['policyYaml'] = l$policyYaml;
    final l$operationMode = operationMode;
    result$data['operationMode'] =
        toJson$Enum$MutationOperationMode(l$operationMode);
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$ScanExecutionPolicyCommitInput<
          Input$ScanExecutionPolicyCommitInput>
      get copyWith => CopyWith$Input$ScanExecutionPolicyCommitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ScanExecutionPolicyCommitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (_$data.containsKey('fullPath') !=
        other._$data.containsKey('fullPath')) {
      return false;
    }
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$policyYaml = policyYaml;
    final lOther$policyYaml = other.policyYaml;
    if (l$policyYaml != lOther$policyYaml) {
      return false;
    }
    final l$operationMode = operationMode;
    final lOther$operationMode = other.operationMode;
    if (l$operationMode != lOther$operationMode) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$policyYaml = policyYaml;
    final l$operationMode = operationMode;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('fullPath') ? l$fullPath : const {},
      l$policyYaml,
      l$operationMode,
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$ScanExecutionPolicyCommitInput<TRes> {
  factory CopyWith$Input$ScanExecutionPolicyCommitInput(
    Input$ScanExecutionPolicyCommitInput instance,
    TRes Function(Input$ScanExecutionPolicyCommitInput) then,
  ) = _CopyWithImpl$Input$ScanExecutionPolicyCommitInput;

  factory CopyWith$Input$ScanExecutionPolicyCommitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ScanExecutionPolicyCommitInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? policyYaml,
    Enum$MutationOperationMode? operationMode,
    String? name,
  });
}

class _CopyWithImpl$Input$ScanExecutionPolicyCommitInput<TRes>
    implements CopyWith$Input$ScanExecutionPolicyCommitInput<TRes> {
  _CopyWithImpl$Input$ScanExecutionPolicyCommitInput(
    this._instance,
    this._then,
  );

  final Input$ScanExecutionPolicyCommitInput _instance;

  final TRes Function(Input$ScanExecutionPolicyCommitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? policyYaml = _undefined,
    Object? operationMode = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ScanExecutionPolicyCommitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined) 'fullPath': (fullPath as String?),
        if (policyYaml != _undefined && policyYaml != null)
          'policyYaml': (policyYaml as String),
        if (operationMode != _undefined && operationMode != null)
          'operationMode': (operationMode as Enum$MutationOperationMode),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$ScanExecutionPolicyCommitInput<TRes>
    implements CopyWith$Input$ScanExecutionPolicyCommitInput<TRes> {
  _CopyWithStubImpl$Input$ScanExecutionPolicyCommitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? policyYaml,
    Enum$MutationOperationMode? operationMode,
    String? name,
  }) =>
      _res;
}

class Input$SecurityFindingCreateIssueInput {
  factory Input$SecurityFindingCreateIssueInput({
    String? clientMutationId,
    required String uuid,
    required String project,
  }) =>
      Input$SecurityFindingCreateIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'uuid': uuid,
        r'project': project,
      });

  Input$SecurityFindingCreateIssueInput._(this._$data);

  factory Input$SecurityFindingCreateIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$project = data['project'];
    result$data['project'] = (l$project as String);
    return Input$SecurityFindingCreateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get uuid => (_$data['uuid'] as String);
  String get project => (_$data['project'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$project = project;
    result$data['project'] = l$project;
    return result$data;
  }

  CopyWith$Input$SecurityFindingCreateIssueInput<
          Input$SecurityFindingCreateIssueInput>
      get copyWith => CopyWith$Input$SecurityFindingCreateIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityFindingCreateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$project = project;
    final lOther$project = other.project;
    if (l$project != lOther$project) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$uuid = uuid;
    final l$project = project;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$uuid,
      l$project,
    ]);
  }
}

abstract class CopyWith$Input$SecurityFindingCreateIssueInput<TRes> {
  factory CopyWith$Input$SecurityFindingCreateIssueInput(
    Input$SecurityFindingCreateIssueInput instance,
    TRes Function(Input$SecurityFindingCreateIssueInput) then,
  ) = _CopyWithImpl$Input$SecurityFindingCreateIssueInput;

  factory CopyWith$Input$SecurityFindingCreateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityFindingCreateIssueInput;

  TRes call({
    String? clientMutationId,
    String? uuid,
    String? project,
  });
}

class _CopyWithImpl$Input$SecurityFindingCreateIssueInput<TRes>
    implements CopyWith$Input$SecurityFindingCreateIssueInput<TRes> {
  _CopyWithImpl$Input$SecurityFindingCreateIssueInput(
    this._instance,
    this._then,
  );

  final Input$SecurityFindingCreateIssueInput _instance;

  final TRes Function(Input$SecurityFindingCreateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? uuid = _undefined,
    Object? project = _undefined,
  }) =>
      _then(Input$SecurityFindingCreateIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (project != _undefined && project != null)
          'project': (project as String),
      }));
}

class _CopyWithStubImpl$Input$SecurityFindingCreateIssueInput<TRes>
    implements CopyWith$Input$SecurityFindingCreateIssueInput<TRes> {
  _CopyWithStubImpl$Input$SecurityFindingCreateIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? uuid,
    String? project,
  }) =>
      _res;
}

class Input$SecurityPolicyProjectAssignInput {
  factory Input$SecurityPolicyProjectAssignInput({
    String? clientMutationId,
    String? fullPath,
    required String securityPolicyProjectId,
  }) =>
      Input$SecurityPolicyProjectAssignInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (fullPath != null) r'fullPath': fullPath,
        r'securityPolicyProjectId': securityPolicyProjectId,
      });

  Input$SecurityPolicyProjectAssignInput._(this._$data);

  factory Input$SecurityPolicyProjectAssignInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('fullPath')) {
      final l$fullPath = data['fullPath'];
      result$data['fullPath'] = (l$fullPath as String?);
    }
    final l$securityPolicyProjectId = data['securityPolicyProjectId'];
    result$data['securityPolicyProjectId'] =
        (l$securityPolicyProjectId as String);
    return Input$SecurityPolicyProjectAssignInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get fullPath => (_$data['fullPath'] as String?);
  String get securityPolicyProjectId =>
      (_$data['securityPolicyProjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('fullPath')) {
      final l$fullPath = fullPath;
      result$data['fullPath'] = l$fullPath;
    }
    final l$securityPolicyProjectId = securityPolicyProjectId;
    result$data['securityPolicyProjectId'] = l$securityPolicyProjectId;
    return result$data;
  }

  CopyWith$Input$SecurityPolicyProjectAssignInput<
          Input$SecurityPolicyProjectAssignInput>
      get copyWith => CopyWith$Input$SecurityPolicyProjectAssignInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityPolicyProjectAssignInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (_$data.containsKey('fullPath') !=
        other._$data.containsKey('fullPath')) {
      return false;
    }
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    final l$securityPolicyProjectId = securityPolicyProjectId;
    final lOther$securityPolicyProjectId = other.securityPolicyProjectId;
    if (l$securityPolicyProjectId != lOther$securityPolicyProjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    final l$securityPolicyProjectId = securityPolicyProjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('fullPath') ? l$fullPath : const {},
      l$securityPolicyProjectId,
    ]);
  }
}

abstract class CopyWith$Input$SecurityPolicyProjectAssignInput<TRes> {
  factory CopyWith$Input$SecurityPolicyProjectAssignInput(
    Input$SecurityPolicyProjectAssignInput instance,
    TRes Function(Input$SecurityPolicyProjectAssignInput) then,
  ) = _CopyWithImpl$Input$SecurityPolicyProjectAssignInput;

  factory CopyWith$Input$SecurityPolicyProjectAssignInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityPolicyProjectAssignInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
    String? securityPolicyProjectId,
  });
}

class _CopyWithImpl$Input$SecurityPolicyProjectAssignInput<TRes>
    implements CopyWith$Input$SecurityPolicyProjectAssignInput<TRes> {
  _CopyWithImpl$Input$SecurityPolicyProjectAssignInput(
    this._instance,
    this._then,
  );

  final Input$SecurityPolicyProjectAssignInput _instance;

  final TRes Function(Input$SecurityPolicyProjectAssignInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
    Object? securityPolicyProjectId = _undefined,
  }) =>
      _then(Input$SecurityPolicyProjectAssignInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined) 'fullPath': (fullPath as String?),
        if (securityPolicyProjectId != _undefined &&
            securityPolicyProjectId != null)
          'securityPolicyProjectId': (securityPolicyProjectId as String),
      }));
}

class _CopyWithStubImpl$Input$SecurityPolicyProjectAssignInput<TRes>
    implements CopyWith$Input$SecurityPolicyProjectAssignInput<TRes> {
  _CopyWithStubImpl$Input$SecurityPolicyProjectAssignInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
    String? securityPolicyProjectId,
  }) =>
      _res;
}

class Input$SecurityPolicyProjectCreateInput {
  factory Input$SecurityPolicyProjectCreateInput({
    String? clientMutationId,
    String? fullPath,
  }) =>
      Input$SecurityPolicyProjectCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (fullPath != null) r'fullPath': fullPath,
      });

  Input$SecurityPolicyProjectCreateInput._(this._$data);

  factory Input$SecurityPolicyProjectCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('fullPath')) {
      final l$fullPath = data['fullPath'];
      result$data['fullPath'] = (l$fullPath as String?);
    }
    return Input$SecurityPolicyProjectCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get fullPath => (_$data['fullPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('fullPath')) {
      final l$fullPath = fullPath;
      result$data['fullPath'] = l$fullPath;
    }
    return result$data;
  }

  CopyWith$Input$SecurityPolicyProjectCreateInput<
          Input$SecurityPolicyProjectCreateInput>
      get copyWith => CopyWith$Input$SecurityPolicyProjectCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityPolicyProjectCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (_$data.containsKey('fullPath') !=
        other._$data.containsKey('fullPath')) {
      return false;
    }
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('fullPath') ? l$fullPath : const {},
    ]);
  }
}

abstract class CopyWith$Input$SecurityPolicyProjectCreateInput<TRes> {
  factory CopyWith$Input$SecurityPolicyProjectCreateInput(
    Input$SecurityPolicyProjectCreateInput instance,
    TRes Function(Input$SecurityPolicyProjectCreateInput) then,
  ) = _CopyWithImpl$Input$SecurityPolicyProjectCreateInput;

  factory CopyWith$Input$SecurityPolicyProjectCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityPolicyProjectCreateInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
  });
}

class _CopyWithImpl$Input$SecurityPolicyProjectCreateInput<TRes>
    implements CopyWith$Input$SecurityPolicyProjectCreateInput<TRes> {
  _CopyWithImpl$Input$SecurityPolicyProjectCreateInput(
    this._instance,
    this._then,
  );

  final Input$SecurityPolicyProjectCreateInput _instance;

  final TRes Function(Input$SecurityPolicyProjectCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
  }) =>
      _then(Input$SecurityPolicyProjectCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined) 'fullPath': (fullPath as String?),
      }));
}

class _CopyWithStubImpl$Input$SecurityPolicyProjectCreateInput<TRes>
    implements CopyWith$Input$SecurityPolicyProjectCreateInput<TRes> {
  _CopyWithStubImpl$Input$SecurityPolicyProjectCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
  }) =>
      _res;
}

class Input$SecurityPolicyProjectUnassignInput {
  factory Input$SecurityPolicyProjectUnassignInput({
    String? clientMutationId,
    String? fullPath,
  }) =>
      Input$SecurityPolicyProjectUnassignInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (fullPath != null) r'fullPath': fullPath,
      });

  Input$SecurityPolicyProjectUnassignInput._(this._$data);

  factory Input$SecurityPolicyProjectUnassignInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('fullPath')) {
      final l$fullPath = data['fullPath'];
      result$data['fullPath'] = (l$fullPath as String?);
    }
    return Input$SecurityPolicyProjectUnassignInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get fullPath => (_$data['fullPath'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('fullPath')) {
      final l$fullPath = fullPath;
      result$data['fullPath'] = l$fullPath;
    }
    return result$data;
  }

  CopyWith$Input$SecurityPolicyProjectUnassignInput<
          Input$SecurityPolicyProjectUnassignInput>
      get copyWith => CopyWith$Input$SecurityPolicyProjectUnassignInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityPolicyProjectUnassignInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fullPath = fullPath;
    final lOther$fullPath = other.fullPath;
    if (_$data.containsKey('fullPath') !=
        other._$data.containsKey('fullPath')) {
      return false;
    }
    if (l$fullPath != lOther$fullPath) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fullPath = fullPath;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('fullPath') ? l$fullPath : const {},
    ]);
  }
}

abstract class CopyWith$Input$SecurityPolicyProjectUnassignInput<TRes> {
  factory CopyWith$Input$SecurityPolicyProjectUnassignInput(
    Input$SecurityPolicyProjectUnassignInput instance,
    TRes Function(Input$SecurityPolicyProjectUnassignInput) then,
  ) = _CopyWithImpl$Input$SecurityPolicyProjectUnassignInput;

  factory CopyWith$Input$SecurityPolicyProjectUnassignInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityPolicyProjectUnassignInput;

  TRes call({
    String? clientMutationId,
    String? fullPath,
  });
}

class _CopyWithImpl$Input$SecurityPolicyProjectUnassignInput<TRes>
    implements CopyWith$Input$SecurityPolicyProjectUnassignInput<TRes> {
  _CopyWithImpl$Input$SecurityPolicyProjectUnassignInput(
    this._instance,
    this._then,
  );

  final Input$SecurityPolicyProjectUnassignInput _instance;

  final TRes Function(Input$SecurityPolicyProjectUnassignInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fullPath = _undefined,
  }) =>
      _then(Input$SecurityPolicyProjectUnassignInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fullPath != _undefined) 'fullPath': (fullPath as String?),
      }));
}

class _CopyWithStubImpl$Input$SecurityPolicyProjectUnassignInput<TRes>
    implements CopyWith$Input$SecurityPolicyProjectUnassignInput<TRes> {
  _CopyWithStubImpl$Input$SecurityPolicyProjectUnassignInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fullPath,
  }) =>
      _res;
}

class Input$SecurityTrainingUpdateInput {
  factory Input$SecurityTrainingUpdateInput({
    String? clientMutationId,
    required String projectPath,
    required String providerId,
    required bool isEnabled,
    bool? isPrimary,
  }) =>
      Input$SecurityTrainingUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        r'providerId': providerId,
        r'isEnabled': isEnabled,
        if (isPrimary != null) r'isPrimary': isPrimary,
      });

  Input$SecurityTrainingUpdateInput._(this._$data);

  factory Input$SecurityTrainingUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$providerId = data['providerId'];
    result$data['providerId'] = (l$providerId as String);
    final l$isEnabled = data['isEnabled'];
    result$data['isEnabled'] = (l$isEnabled as bool);
    if (data.containsKey('isPrimary')) {
      final l$isPrimary = data['isPrimary'];
      result$data['isPrimary'] = (l$isPrimary as bool?);
    }
    return Input$SecurityTrainingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String get providerId => (_$data['providerId'] as String);
  bool get isEnabled => (_$data['isEnabled'] as bool);
  bool? get isPrimary => (_$data['isPrimary'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$providerId = providerId;
    result$data['providerId'] = l$providerId;
    final l$isEnabled = isEnabled;
    result$data['isEnabled'] = l$isEnabled;
    if (_$data.containsKey('isPrimary')) {
      final l$isPrimary = isPrimary;
      result$data['isPrimary'] = l$isPrimary;
    }
    return result$data;
  }

  CopyWith$Input$SecurityTrainingUpdateInput<Input$SecurityTrainingUpdateInput>
      get copyWith => CopyWith$Input$SecurityTrainingUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityTrainingUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$isEnabled = isEnabled;
    final lOther$isEnabled = other.isEnabled;
    if (l$isEnabled != lOther$isEnabled) {
      return false;
    }
    final l$isPrimary = isPrimary;
    final lOther$isPrimary = other.isPrimary;
    if (_$data.containsKey('isPrimary') !=
        other._$data.containsKey('isPrimary')) {
      return false;
    }
    if (l$isPrimary != lOther$isPrimary) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$providerId = providerId;
    final l$isEnabled = isEnabled;
    final l$isPrimary = isPrimary;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      l$providerId,
      l$isEnabled,
      _$data.containsKey('isPrimary') ? l$isPrimary : const {},
    ]);
  }
}

abstract class CopyWith$Input$SecurityTrainingUpdateInput<TRes> {
  factory CopyWith$Input$SecurityTrainingUpdateInput(
    Input$SecurityTrainingUpdateInput instance,
    TRes Function(Input$SecurityTrainingUpdateInput) then,
  ) = _CopyWithImpl$Input$SecurityTrainingUpdateInput;

  factory CopyWith$Input$SecurityTrainingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityTrainingUpdateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? providerId,
    bool? isEnabled,
    bool? isPrimary,
  });
}

class _CopyWithImpl$Input$SecurityTrainingUpdateInput<TRes>
    implements CopyWith$Input$SecurityTrainingUpdateInput<TRes> {
  _CopyWithImpl$Input$SecurityTrainingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SecurityTrainingUpdateInput _instance;

  final TRes Function(Input$SecurityTrainingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? providerId = _undefined,
    Object? isEnabled = _undefined,
    Object? isPrimary = _undefined,
  }) =>
      _then(Input$SecurityTrainingUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (providerId != _undefined && providerId != null)
          'providerId': (providerId as String),
        if (isEnabled != _undefined && isEnabled != null)
          'isEnabled': (isEnabled as bool),
        if (isPrimary != _undefined) 'isPrimary': (isPrimary as bool?),
      }));
}

class _CopyWithStubImpl$Input$SecurityTrainingUpdateInput<TRes>
    implements CopyWith$Input$SecurityTrainingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SecurityTrainingUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? providerId,
    bool? isEnabled,
    bool? isPrimary,
  }) =>
      _res;
}

class Input$SnippetBlobActionInputType {
  factory Input$SnippetBlobActionInputType({
    required Enum$SnippetBlobActionEnum action,
    String? previousPath,
    required String filePath,
    String? content,
  }) =>
      Input$SnippetBlobActionInputType._({
        r'action': action,
        if (previousPath != null) r'previousPath': previousPath,
        r'filePath': filePath,
        if (content != null) r'content': content,
      });

  Input$SnippetBlobActionInputType._(this._$data);

  factory Input$SnippetBlobActionInputType.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$action = data['action'];
    result$data['action'] =
        fromJson$Enum$SnippetBlobActionEnum((l$action as String));
    if (data.containsKey('previousPath')) {
      final l$previousPath = data['previousPath'];
      result$data['previousPath'] = (l$previousPath as String?);
    }
    final l$filePath = data['filePath'];
    result$data['filePath'] = (l$filePath as String);
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    return Input$SnippetBlobActionInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SnippetBlobActionEnum get action =>
      (_$data['action'] as Enum$SnippetBlobActionEnum);
  String? get previousPath => (_$data['previousPath'] as String?);
  String get filePath => (_$data['filePath'] as String);
  String? get content => (_$data['content'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$action = action;
    result$data['action'] = toJson$Enum$SnippetBlobActionEnum(l$action);
    if (_$data.containsKey('previousPath')) {
      final l$previousPath = previousPath;
      result$data['previousPath'] = l$previousPath;
    }
    final l$filePath = filePath;
    result$data['filePath'] = l$filePath;
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    return result$data;
  }

  CopyWith$Input$SnippetBlobActionInputType<Input$SnippetBlobActionInputType>
      get copyWith => CopyWith$Input$SnippetBlobActionInputType(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SnippetBlobActionInputType) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (l$action != lOther$action) {
      return false;
    }
    final l$previousPath = previousPath;
    final lOther$previousPath = other.previousPath;
    if (_$data.containsKey('previousPath') !=
        other._$data.containsKey('previousPath')) {
      return false;
    }
    if (l$previousPath != lOther$previousPath) {
      return false;
    }
    final l$filePath = filePath;
    final lOther$filePath = other.filePath;
    if (l$filePath != lOther$filePath) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$action = action;
    final l$previousPath = previousPath;
    final l$filePath = filePath;
    final l$content = content;
    return Object.hashAll([
      l$action,
      _$data.containsKey('previousPath') ? l$previousPath : const {},
      l$filePath,
      _$data.containsKey('content') ? l$content : const {},
    ]);
  }
}

abstract class CopyWith$Input$SnippetBlobActionInputType<TRes> {
  factory CopyWith$Input$SnippetBlobActionInputType(
    Input$SnippetBlobActionInputType instance,
    TRes Function(Input$SnippetBlobActionInputType) then,
  ) = _CopyWithImpl$Input$SnippetBlobActionInputType;

  factory CopyWith$Input$SnippetBlobActionInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$SnippetBlobActionInputType;

  TRes call({
    Enum$SnippetBlobActionEnum? action,
    String? previousPath,
    String? filePath,
    String? content,
  });
}

class _CopyWithImpl$Input$SnippetBlobActionInputType<TRes>
    implements CopyWith$Input$SnippetBlobActionInputType<TRes> {
  _CopyWithImpl$Input$SnippetBlobActionInputType(
    this._instance,
    this._then,
  );

  final Input$SnippetBlobActionInputType _instance;

  final TRes Function(Input$SnippetBlobActionInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? action = _undefined,
    Object? previousPath = _undefined,
    Object? filePath = _undefined,
    Object? content = _undefined,
  }) =>
      _then(Input$SnippetBlobActionInputType._({
        ..._instance._$data,
        if (action != _undefined && action != null)
          'action': (action as Enum$SnippetBlobActionEnum),
        if (previousPath != _undefined)
          'previousPath': (previousPath as String?),
        if (filePath != _undefined && filePath != null)
          'filePath': (filePath as String),
        if (content != _undefined) 'content': (content as String?),
      }));
}

class _CopyWithStubImpl$Input$SnippetBlobActionInputType<TRes>
    implements CopyWith$Input$SnippetBlobActionInputType<TRes> {
  _CopyWithStubImpl$Input$SnippetBlobActionInputType(this._res);

  TRes _res;

  call({
    Enum$SnippetBlobActionEnum? action,
    String? previousPath,
    String? filePath,
    String? content,
  }) =>
      _res;
}

class Input$TerraformStateDeleteInput {
  factory Input$TerraformStateDeleteInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$TerraformStateDeleteInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$TerraformStateDeleteInput._(this._$data);

  factory Input$TerraformStateDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$TerraformStateDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$TerraformStateDeleteInput<Input$TerraformStateDeleteInput>
      get copyWith => CopyWith$Input$TerraformStateDeleteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerraformStateDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerraformStateDeleteInput<TRes> {
  factory CopyWith$Input$TerraformStateDeleteInput(
    Input$TerraformStateDeleteInput instance,
    TRes Function(Input$TerraformStateDeleteInput) then,
  ) = _CopyWithImpl$Input$TerraformStateDeleteInput;

  factory CopyWith$Input$TerraformStateDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerraformStateDeleteInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$TerraformStateDeleteInput<TRes>
    implements CopyWith$Input$TerraformStateDeleteInput<TRes> {
  _CopyWithImpl$Input$TerraformStateDeleteInput(
    this._instance,
    this._then,
  );

  final Input$TerraformStateDeleteInput _instance;

  final TRes Function(Input$TerraformStateDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$TerraformStateDeleteInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$TerraformStateDeleteInput<TRes>
    implements CopyWith$Input$TerraformStateDeleteInput<TRes> {
  _CopyWithStubImpl$Input$TerraformStateDeleteInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$TerraformStateLockInput {
  factory Input$TerraformStateLockInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$TerraformStateLockInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$TerraformStateLockInput._(this._$data);

  factory Input$TerraformStateLockInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$TerraformStateLockInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$TerraformStateLockInput<Input$TerraformStateLockInput>
      get copyWith => CopyWith$Input$TerraformStateLockInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerraformStateLockInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerraformStateLockInput<TRes> {
  factory CopyWith$Input$TerraformStateLockInput(
    Input$TerraformStateLockInput instance,
    TRes Function(Input$TerraformStateLockInput) then,
  ) = _CopyWithImpl$Input$TerraformStateLockInput;

  factory CopyWith$Input$TerraformStateLockInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerraformStateLockInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$TerraformStateLockInput<TRes>
    implements CopyWith$Input$TerraformStateLockInput<TRes> {
  _CopyWithImpl$Input$TerraformStateLockInput(
    this._instance,
    this._then,
  );

  final Input$TerraformStateLockInput _instance;

  final TRes Function(Input$TerraformStateLockInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$TerraformStateLockInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$TerraformStateLockInput<TRes>
    implements CopyWith$Input$TerraformStateLockInput<TRes> {
  _CopyWithStubImpl$Input$TerraformStateLockInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$TerraformStateUnlockInput {
  factory Input$TerraformStateUnlockInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$TerraformStateUnlockInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$TerraformStateUnlockInput._(this._$data);

  factory Input$TerraformStateUnlockInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$TerraformStateUnlockInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$TerraformStateUnlockInput<Input$TerraformStateUnlockInput>
      get copyWith => CopyWith$Input$TerraformStateUnlockInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TerraformStateUnlockInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TerraformStateUnlockInput<TRes> {
  factory CopyWith$Input$TerraformStateUnlockInput(
    Input$TerraformStateUnlockInput instance,
    TRes Function(Input$TerraformStateUnlockInput) then,
  ) = _CopyWithImpl$Input$TerraformStateUnlockInput;

  factory CopyWith$Input$TerraformStateUnlockInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TerraformStateUnlockInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$TerraformStateUnlockInput<TRes>
    implements CopyWith$Input$TerraformStateUnlockInput<TRes> {
  _CopyWithImpl$Input$TerraformStateUnlockInput(
    this._instance,
    this._then,
  );

  final Input$TerraformStateUnlockInput _instance;

  final TRes Function(Input$TerraformStateUnlockInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$TerraformStateUnlockInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$TerraformStateUnlockInput<TRes>
    implements CopyWith$Input$TerraformStateUnlockInput<TRes> {
  _CopyWithStubImpl$Input$TerraformStateUnlockInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$Timeframe {
  factory Input$Timeframe({
    required String start,
    required String end,
  }) =>
      Input$Timeframe._({
        r'start': start,
        r'end': end,
      });

  Input$Timeframe._(this._$data);

  factory Input$Timeframe.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$start = data['start'];
    result$data['start'] = (l$start as String);
    final l$end = data['end'];
    result$data['end'] = (l$end as String);
    return Input$Timeframe._(result$data);
  }

  Map<String, dynamic> _$data;

  String get start => (_$data['start'] as String);
  String get end => (_$data['end'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$start = start;
    result$data['start'] = l$start;
    final l$end = end;
    result$data['end'] = l$end;
    return result$data;
  }

  CopyWith$Input$Timeframe<Input$Timeframe> get copyWith =>
      CopyWith$Input$Timeframe(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$Timeframe) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$start = start;
    final lOther$start = other.start;
    if (l$start != lOther$start) {
      return false;
    }
    final l$end = end;
    final lOther$end = other.end;
    if (l$end != lOther$end) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$start = start;
    final l$end = end;
    return Object.hashAll([
      l$start,
      l$end,
    ]);
  }
}

abstract class CopyWith$Input$Timeframe<TRes> {
  factory CopyWith$Input$Timeframe(
    Input$Timeframe instance,
    TRes Function(Input$Timeframe) then,
  ) = _CopyWithImpl$Input$Timeframe;

  factory CopyWith$Input$Timeframe.stub(TRes res) =
      _CopyWithStubImpl$Input$Timeframe;

  TRes call({
    String? start,
    String? end,
  });
}

class _CopyWithImpl$Input$Timeframe<TRes>
    implements CopyWith$Input$Timeframe<TRes> {
  _CopyWithImpl$Input$Timeframe(
    this._instance,
    this._then,
  );

  final Input$Timeframe _instance;

  final TRes Function(Input$Timeframe) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? start = _undefined,
    Object? end = _undefined,
  }) =>
      _then(Input$Timeframe._({
        ..._instance._$data,
        if (start != _undefined && start != null) 'start': (start as String),
        if (end != _undefined && end != null) 'end': (end as String),
      }));
}

class _CopyWithStubImpl$Input$Timeframe<TRes>
    implements CopyWith$Input$Timeframe<TRes> {
  _CopyWithStubImpl$Input$Timeframe(this._res);

  TRes _res;

  call({
    String? start,
    String? end,
  }) =>
      _res;
}

class Input$TimelineEventCreateInput {
  factory Input$TimelineEventCreateInput({
    String? clientMutationId,
    required String incidentId,
    required String note,
    required String occurredAt,
  }) =>
      Input$TimelineEventCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'incidentId': incidentId,
        r'note': note,
        r'occurredAt': occurredAt,
      });

  Input$TimelineEventCreateInput._(this._$data);

  factory Input$TimelineEventCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$incidentId = data['incidentId'];
    result$data['incidentId'] = (l$incidentId as String);
    final l$note = data['note'];
    result$data['note'] = (l$note as String);
    final l$occurredAt = data['occurredAt'];
    result$data['occurredAt'] = (l$occurredAt as String);
    return Input$TimelineEventCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get incidentId => (_$data['incidentId'] as String);
  String get note => (_$data['note'] as String);
  String get occurredAt => (_$data['occurredAt'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$incidentId = incidentId;
    result$data['incidentId'] = l$incidentId;
    final l$note = note;
    result$data['note'] = l$note;
    final l$occurredAt = occurredAt;
    result$data['occurredAt'] = l$occurredAt;
    return result$data;
  }

  CopyWith$Input$TimelineEventCreateInput<Input$TimelineEventCreateInput>
      get copyWith => CopyWith$Input$TimelineEventCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimelineEventCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$incidentId = incidentId;
    final lOther$incidentId = other.incidentId;
    if (l$incidentId != lOther$incidentId) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (l$note != lOther$note) {
      return false;
    }
    final l$occurredAt = occurredAt;
    final lOther$occurredAt = other.occurredAt;
    if (l$occurredAt != lOther$occurredAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$incidentId = incidentId;
    final l$note = note;
    final l$occurredAt = occurredAt;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$incidentId,
      l$note,
      l$occurredAt,
    ]);
  }
}

abstract class CopyWith$Input$TimelineEventCreateInput<TRes> {
  factory CopyWith$Input$TimelineEventCreateInput(
    Input$TimelineEventCreateInput instance,
    TRes Function(Input$TimelineEventCreateInput) then,
  ) = _CopyWithImpl$Input$TimelineEventCreateInput;

  factory CopyWith$Input$TimelineEventCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TimelineEventCreateInput;

  TRes call({
    String? clientMutationId,
    String? incidentId,
    String? note,
    String? occurredAt,
  });
}

class _CopyWithImpl$Input$TimelineEventCreateInput<TRes>
    implements CopyWith$Input$TimelineEventCreateInput<TRes> {
  _CopyWithImpl$Input$TimelineEventCreateInput(
    this._instance,
    this._then,
  );

  final Input$TimelineEventCreateInput _instance;

  final TRes Function(Input$TimelineEventCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? incidentId = _undefined,
    Object? note = _undefined,
    Object? occurredAt = _undefined,
  }) =>
      _then(Input$TimelineEventCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (incidentId != _undefined && incidentId != null)
          'incidentId': (incidentId as String),
        if (note != _undefined && note != null) 'note': (note as String),
        if (occurredAt != _undefined && occurredAt != null)
          'occurredAt': (occurredAt as String),
      }));
}

class _CopyWithStubImpl$Input$TimelineEventCreateInput<TRes>
    implements CopyWith$Input$TimelineEventCreateInput<TRes> {
  _CopyWithStubImpl$Input$TimelineEventCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? incidentId,
    String? note,
    String? occurredAt,
  }) =>
      _res;
}

class Input$TimelineEventDestroyInput {
  factory Input$TimelineEventDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$TimelineEventDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$TimelineEventDestroyInput._(this._$data);

  factory Input$TimelineEventDestroyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$TimelineEventDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$TimelineEventDestroyInput<Input$TimelineEventDestroyInput>
      get copyWith => CopyWith$Input$TimelineEventDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimelineEventDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$TimelineEventDestroyInput<TRes> {
  factory CopyWith$Input$TimelineEventDestroyInput(
    Input$TimelineEventDestroyInput instance,
    TRes Function(Input$TimelineEventDestroyInput) then,
  ) = _CopyWithImpl$Input$TimelineEventDestroyInput;

  factory CopyWith$Input$TimelineEventDestroyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TimelineEventDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$TimelineEventDestroyInput<TRes>
    implements CopyWith$Input$TimelineEventDestroyInput<TRes> {
  _CopyWithImpl$Input$TimelineEventDestroyInput(
    this._instance,
    this._then,
  );

  final Input$TimelineEventDestroyInput _instance;

  final TRes Function(Input$TimelineEventDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$TimelineEventDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$TimelineEventDestroyInput<TRes>
    implements CopyWith$Input$TimelineEventDestroyInput<TRes> {
  _CopyWithStubImpl$Input$TimelineEventDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$TimelineEventPromoteFromNoteInput {
  factory Input$TimelineEventPromoteFromNoteInput({
    String? clientMutationId,
    required String noteId,
  }) =>
      Input$TimelineEventPromoteFromNoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'noteId': noteId,
      });

  Input$TimelineEventPromoteFromNoteInput._(this._$data);

  factory Input$TimelineEventPromoteFromNoteInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$noteId = data['noteId'];
    result$data['noteId'] = (l$noteId as String);
    return Input$TimelineEventPromoteFromNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get noteId => (_$data['noteId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$noteId = noteId;
    result$data['noteId'] = l$noteId;
    return result$data;
  }

  CopyWith$Input$TimelineEventPromoteFromNoteInput<
          Input$TimelineEventPromoteFromNoteInput>
      get copyWith => CopyWith$Input$TimelineEventPromoteFromNoteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimelineEventPromoteFromNoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$noteId = noteId;
    final lOther$noteId = other.noteId;
    if (l$noteId != lOther$noteId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$noteId = noteId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$noteId,
    ]);
  }
}

abstract class CopyWith$Input$TimelineEventPromoteFromNoteInput<TRes> {
  factory CopyWith$Input$TimelineEventPromoteFromNoteInput(
    Input$TimelineEventPromoteFromNoteInput instance,
    TRes Function(Input$TimelineEventPromoteFromNoteInput) then,
  ) = _CopyWithImpl$Input$TimelineEventPromoteFromNoteInput;

  factory CopyWith$Input$TimelineEventPromoteFromNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TimelineEventPromoteFromNoteInput;

  TRes call({
    String? clientMutationId,
    String? noteId,
  });
}

class _CopyWithImpl$Input$TimelineEventPromoteFromNoteInput<TRes>
    implements CopyWith$Input$TimelineEventPromoteFromNoteInput<TRes> {
  _CopyWithImpl$Input$TimelineEventPromoteFromNoteInput(
    this._instance,
    this._then,
  );

  final Input$TimelineEventPromoteFromNoteInput _instance;

  final TRes Function(Input$TimelineEventPromoteFromNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? noteId = _undefined,
  }) =>
      _then(Input$TimelineEventPromoteFromNoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (noteId != _undefined && noteId != null)
          'noteId': (noteId as String),
      }));
}

class _CopyWithStubImpl$Input$TimelineEventPromoteFromNoteInput<TRes>
    implements CopyWith$Input$TimelineEventPromoteFromNoteInput<TRes> {
  _CopyWithStubImpl$Input$TimelineEventPromoteFromNoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? noteId,
  }) =>
      _res;
}

class Input$TimelineEventUpdateInput {
  factory Input$TimelineEventUpdateInput({
    String? clientMutationId,
    required String id,
    String? note,
    String? occurredAt,
  }) =>
      Input$TimelineEventUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (note != null) r'note': note,
        if (occurredAt != null) r'occurredAt': occurredAt,
      });

  Input$TimelineEventUpdateInput._(this._$data);

  factory Input$TimelineEventUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('occurredAt')) {
      final l$occurredAt = data['occurredAt'];
      result$data['occurredAt'] = (l$occurredAt as String?);
    }
    return Input$TimelineEventUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get note => (_$data['note'] as String?);
  String? get occurredAt => (_$data['occurredAt'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('occurredAt')) {
      final l$occurredAt = occurredAt;
      result$data['occurredAt'] = l$occurredAt;
    }
    return result$data;
  }

  CopyWith$Input$TimelineEventUpdateInput<Input$TimelineEventUpdateInput>
      get copyWith => CopyWith$Input$TimelineEventUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimelineEventUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$occurredAt = occurredAt;
    final lOther$occurredAt = other.occurredAt;
    if (_$data.containsKey('occurredAt') !=
        other._$data.containsKey('occurredAt')) {
      return false;
    }
    if (l$occurredAt != lOther$occurredAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$note = note;
    final l$occurredAt = occurredAt;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('occurredAt') ? l$occurredAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$TimelineEventUpdateInput<TRes> {
  factory CopyWith$Input$TimelineEventUpdateInput(
    Input$TimelineEventUpdateInput instance,
    TRes Function(Input$TimelineEventUpdateInput) then,
  ) = _CopyWithImpl$Input$TimelineEventUpdateInput;

  factory CopyWith$Input$TimelineEventUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TimelineEventUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? note,
    String? occurredAt,
  });
}

class _CopyWithImpl$Input$TimelineEventUpdateInput<TRes>
    implements CopyWith$Input$TimelineEventUpdateInput<TRes> {
  _CopyWithImpl$Input$TimelineEventUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TimelineEventUpdateInput _instance;

  final TRes Function(Input$TimelineEventUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? note = _undefined,
    Object? occurredAt = _undefined,
  }) =>
      _then(Input$TimelineEventUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (note != _undefined) 'note': (note as String?),
        if (occurredAt != _undefined) 'occurredAt': (occurredAt as String?),
      }));
}

class _CopyWithStubImpl$Input$TimelineEventUpdateInput<TRes>
    implements CopyWith$Input$TimelineEventUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TimelineEventUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? note,
    String? occurredAt,
  }) =>
      _res;
}

class Input$TimelogCreateInput {
  factory Input$TimelogCreateInput({
    String? clientMutationId,
    required String timeSpent,
    required String spentAt,
    required String summary,
    required String issuableId,
  }) =>
      Input$TimelogCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'timeSpent': timeSpent,
        r'spentAt': spentAt,
        r'summary': summary,
        r'issuableId': issuableId,
      });

  Input$TimelogCreateInput._(this._$data);

  factory Input$TimelogCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$timeSpent = data['timeSpent'];
    result$data['timeSpent'] = (l$timeSpent as String);
    final l$spentAt = data['spentAt'];
    result$data['spentAt'] = (l$spentAt as String);
    final l$summary = data['summary'];
    result$data['summary'] = (l$summary as String);
    final l$issuableId = data['issuableId'];
    result$data['issuableId'] = (l$issuableId as String);
    return Input$TimelogCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get timeSpent => (_$data['timeSpent'] as String);
  String get spentAt => (_$data['spentAt'] as String);
  String get summary => (_$data['summary'] as String);
  String get issuableId => (_$data['issuableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$timeSpent = timeSpent;
    result$data['timeSpent'] = l$timeSpent;
    final l$spentAt = spentAt;
    result$data['spentAt'] = l$spentAt;
    final l$summary = summary;
    result$data['summary'] = l$summary;
    final l$issuableId = issuableId;
    result$data['issuableId'] = l$issuableId;
    return result$data;
  }

  CopyWith$Input$TimelogCreateInput<Input$TimelogCreateInput> get copyWith =>
      CopyWith$Input$TimelogCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimelogCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$timeSpent = timeSpent;
    final lOther$timeSpent = other.timeSpent;
    if (l$timeSpent != lOther$timeSpent) {
      return false;
    }
    final l$spentAt = spentAt;
    final lOther$spentAt = other.spentAt;
    if (l$spentAt != lOther$spentAt) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$issuableId = issuableId;
    final lOther$issuableId = other.issuableId;
    if (l$issuableId != lOther$issuableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$timeSpent = timeSpent;
    final l$spentAt = spentAt;
    final l$summary = summary;
    final l$issuableId = issuableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$timeSpent,
      l$spentAt,
      l$summary,
      l$issuableId,
    ]);
  }
}

abstract class CopyWith$Input$TimelogCreateInput<TRes> {
  factory CopyWith$Input$TimelogCreateInput(
    Input$TimelogCreateInput instance,
    TRes Function(Input$TimelogCreateInput) then,
  ) = _CopyWithImpl$Input$TimelogCreateInput;

  factory CopyWith$Input$TimelogCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TimelogCreateInput;

  TRes call({
    String? clientMutationId,
    String? timeSpent,
    String? spentAt,
    String? summary,
    String? issuableId,
  });
}

class _CopyWithImpl$Input$TimelogCreateInput<TRes>
    implements CopyWith$Input$TimelogCreateInput<TRes> {
  _CopyWithImpl$Input$TimelogCreateInput(
    this._instance,
    this._then,
  );

  final Input$TimelogCreateInput _instance;

  final TRes Function(Input$TimelogCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? timeSpent = _undefined,
    Object? spentAt = _undefined,
    Object? summary = _undefined,
    Object? issuableId = _undefined,
  }) =>
      _then(Input$TimelogCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (timeSpent != _undefined && timeSpent != null)
          'timeSpent': (timeSpent as String),
        if (spentAt != _undefined && spentAt != null)
          'spentAt': (spentAt as String),
        if (summary != _undefined && summary != null)
          'summary': (summary as String),
        if (issuableId != _undefined && issuableId != null)
          'issuableId': (issuableId as String),
      }));
}

class _CopyWithStubImpl$Input$TimelogCreateInput<TRes>
    implements CopyWith$Input$TimelogCreateInput<TRes> {
  _CopyWithStubImpl$Input$TimelogCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? timeSpent,
    String? spentAt,
    String? summary,
    String? issuableId,
  }) =>
      _res;
}

class Input$TimelogDeleteInput {
  factory Input$TimelogDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$TimelogDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$TimelogDeleteInput._(this._$data);

  factory Input$TimelogDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$TimelogDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$TimelogDeleteInput<Input$TimelogDeleteInput> get copyWith =>
      CopyWith$Input$TimelogDeleteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimelogDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$TimelogDeleteInput<TRes> {
  factory CopyWith$Input$TimelogDeleteInput(
    Input$TimelogDeleteInput instance,
    TRes Function(Input$TimelogDeleteInput) then,
  ) = _CopyWithImpl$Input$TimelogDeleteInput;

  factory CopyWith$Input$TimelogDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TimelogDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$TimelogDeleteInput<TRes>
    implements CopyWith$Input$TimelogDeleteInput<TRes> {
  _CopyWithImpl$Input$TimelogDeleteInput(
    this._instance,
    this._then,
  );

  final Input$TimelogDeleteInput _instance;

  final TRes Function(Input$TimelogDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$TimelogDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$TimelogDeleteInput<TRes>
    implements CopyWith$Input$TimelogDeleteInput<TRes> {
  _CopyWithStubImpl$Input$TimelogDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$TodoCreateInput {
  factory Input$TodoCreateInput({
    String? clientMutationId,
    required String targetId,
  }) =>
      Input$TodoCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'targetId': targetId,
      });

  Input$TodoCreateInput._(this._$data);

  factory Input$TodoCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$targetId = data['targetId'];
    result$data['targetId'] = (l$targetId as String);
    return Input$TodoCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get targetId => (_$data['targetId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$targetId = targetId;
    result$data['targetId'] = l$targetId;
    return result$data;
  }

  CopyWith$Input$TodoCreateInput<Input$TodoCreateInput> get copyWith =>
      CopyWith$Input$TodoCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TodoCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (l$targetId != lOther$targetId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$targetId = targetId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$targetId,
    ]);
  }
}

abstract class CopyWith$Input$TodoCreateInput<TRes> {
  factory CopyWith$Input$TodoCreateInput(
    Input$TodoCreateInput instance,
    TRes Function(Input$TodoCreateInput) then,
  ) = _CopyWithImpl$Input$TodoCreateInput;

  factory CopyWith$Input$TodoCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TodoCreateInput;

  TRes call({
    String? clientMutationId,
    String? targetId,
  });
}

class _CopyWithImpl$Input$TodoCreateInput<TRes>
    implements CopyWith$Input$TodoCreateInput<TRes> {
  _CopyWithImpl$Input$TodoCreateInput(
    this._instance,
    this._then,
  );

  final Input$TodoCreateInput _instance;

  final TRes Function(Input$TodoCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? targetId = _undefined,
  }) =>
      _then(Input$TodoCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (targetId != _undefined && targetId != null)
          'targetId': (targetId as String),
      }));
}

class _CopyWithStubImpl$Input$TodoCreateInput<TRes>
    implements CopyWith$Input$TodoCreateInput<TRes> {
  _CopyWithStubImpl$Input$TodoCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? targetId,
  }) =>
      _res;
}

class Input$TodoMarkDoneInput {
  factory Input$TodoMarkDoneInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$TodoMarkDoneInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$TodoMarkDoneInput._(this._$data);

  factory Input$TodoMarkDoneInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$TodoMarkDoneInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$TodoMarkDoneInput<Input$TodoMarkDoneInput> get copyWith =>
      CopyWith$Input$TodoMarkDoneInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TodoMarkDoneInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$TodoMarkDoneInput<TRes> {
  factory CopyWith$Input$TodoMarkDoneInput(
    Input$TodoMarkDoneInput instance,
    TRes Function(Input$TodoMarkDoneInput) then,
  ) = _CopyWithImpl$Input$TodoMarkDoneInput;

  factory CopyWith$Input$TodoMarkDoneInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TodoMarkDoneInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$TodoMarkDoneInput<TRes>
    implements CopyWith$Input$TodoMarkDoneInput<TRes> {
  _CopyWithImpl$Input$TodoMarkDoneInput(
    this._instance,
    this._then,
  );

  final Input$TodoMarkDoneInput _instance;

  final TRes Function(Input$TodoMarkDoneInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$TodoMarkDoneInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$TodoMarkDoneInput<TRes>
    implements CopyWith$Input$TodoMarkDoneInput<TRes> {
  _CopyWithStubImpl$Input$TodoMarkDoneInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$TodoRestoreInput {
  factory Input$TodoRestoreInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$TodoRestoreInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$TodoRestoreInput._(this._$data);

  factory Input$TodoRestoreInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$TodoRestoreInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$TodoRestoreInput<Input$TodoRestoreInput> get copyWith =>
      CopyWith$Input$TodoRestoreInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TodoRestoreInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$TodoRestoreInput<TRes> {
  factory CopyWith$Input$TodoRestoreInput(
    Input$TodoRestoreInput instance,
    TRes Function(Input$TodoRestoreInput) then,
  ) = _CopyWithImpl$Input$TodoRestoreInput;

  factory CopyWith$Input$TodoRestoreInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TodoRestoreInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$TodoRestoreInput<TRes>
    implements CopyWith$Input$TodoRestoreInput<TRes> {
  _CopyWithImpl$Input$TodoRestoreInput(
    this._instance,
    this._then,
  );

  final Input$TodoRestoreInput _instance;

  final TRes Function(Input$TodoRestoreInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$TodoRestoreInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$TodoRestoreInput<TRes>
    implements CopyWith$Input$TodoRestoreInput<TRes> {
  _CopyWithStubImpl$Input$TodoRestoreInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$TodoRestoreManyInput {
  factory Input$TodoRestoreManyInput({
    String? clientMutationId,
    required List<String> ids,
  }) =>
      Input$TodoRestoreManyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ids': ids,
      });

  Input$TodoRestoreManyInput._(this._$data);

  factory Input$TodoRestoreManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ids = data['ids'];
    result$data['ids'] =
        (l$ids as List<dynamic>).map((e) => (e as String)).toList();
    return Input$TodoRestoreManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get ids => (_$data['ids'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ids = ids;
    result$data['ids'] = l$ids.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$TodoRestoreManyInput<Input$TodoRestoreManyInput>
      get copyWith => CopyWith$Input$TodoRestoreManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TodoRestoreManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (l$ids.length != lOther$ids.length) {
      return false;
    }
    for (int i = 0; i < l$ids.length; i++) {
      final l$ids$entry = l$ids[i];
      final lOther$ids$entry = lOther$ids[i];
      if (l$ids$entry != lOther$ids$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$ids.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$TodoRestoreManyInput<TRes> {
  factory CopyWith$Input$TodoRestoreManyInput(
    Input$TodoRestoreManyInput instance,
    TRes Function(Input$TodoRestoreManyInput) then,
  ) = _CopyWithImpl$Input$TodoRestoreManyInput;

  factory CopyWith$Input$TodoRestoreManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TodoRestoreManyInput;

  TRes call({
    String? clientMutationId,
    List<String>? ids,
  });
}

class _CopyWithImpl$Input$TodoRestoreManyInput<TRes>
    implements CopyWith$Input$TodoRestoreManyInput<TRes> {
  _CopyWithImpl$Input$TodoRestoreManyInput(
    this._instance,
    this._then,
  );

  final Input$TodoRestoreManyInput _instance;

  final TRes Function(Input$TodoRestoreManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$TodoRestoreManyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ids != _undefined && ids != null) 'ids': (ids as List<String>),
      }));
}

class _CopyWithStubImpl$Input$TodoRestoreManyInput<TRes>
    implements CopyWith$Input$TodoRestoreManyInput<TRes> {
  _CopyWithStubImpl$Input$TodoRestoreManyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? ids,
  }) =>
      _res;
}

class Input$TodosMarkAllDoneInput {
  factory Input$TodosMarkAllDoneInput({
    String? clientMutationId,
    String? targetId,
  }) =>
      Input$TodosMarkAllDoneInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (targetId != null) r'targetId': targetId,
      });

  Input$TodosMarkAllDoneInput._(this._$data);

  factory Input$TodosMarkAllDoneInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = (l$targetId as String?);
    }
    return Input$TodosMarkAllDoneInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get targetId => (_$data['targetId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId;
    }
    return result$data;
  }

  CopyWith$Input$TodosMarkAllDoneInput<Input$TodosMarkAllDoneInput>
      get copyWith => CopyWith$Input$TodosMarkAllDoneInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TodosMarkAllDoneInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$targetId = targetId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TodosMarkAllDoneInput<TRes> {
  factory CopyWith$Input$TodosMarkAllDoneInput(
    Input$TodosMarkAllDoneInput instance,
    TRes Function(Input$TodosMarkAllDoneInput) then,
  ) = _CopyWithImpl$Input$TodosMarkAllDoneInput;

  factory CopyWith$Input$TodosMarkAllDoneInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TodosMarkAllDoneInput;

  TRes call({
    String? clientMutationId,
    String? targetId,
  });
}

class _CopyWithImpl$Input$TodosMarkAllDoneInput<TRes>
    implements CopyWith$Input$TodosMarkAllDoneInput<TRes> {
  _CopyWithImpl$Input$TodosMarkAllDoneInput(
    this._instance,
    this._then,
  );

  final Input$TodosMarkAllDoneInput _instance;

  final TRes Function(Input$TodosMarkAllDoneInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? targetId = _undefined,
  }) =>
      _then(Input$TodosMarkAllDoneInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (targetId != _undefined) 'targetId': (targetId as String?),
      }));
}

class _CopyWithStubImpl$Input$TodosMarkAllDoneInput<TRes>
    implements CopyWith$Input$TodosMarkAllDoneInput<TRes> {
  _CopyWithStubImpl$Input$TodosMarkAllDoneInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? targetId,
  }) =>
      _res;
}

class Input$UpdateAlertStatusInput {
  factory Input$UpdateAlertStatusInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    required Enum$AlertManagementStatus status,
  }) =>
      Input$UpdateAlertStatusInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'status': status,
      });

  Input$UpdateAlertStatusInput._(this._$data);

  factory Input$UpdateAlertStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$status = data['status'];
    result$data['status'] =
        fromJson$Enum$AlertManagementStatus((l$status as String));
    return Input$UpdateAlertStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$AlertManagementStatus get status =>
      (_$data['status'] as Enum$AlertManagementStatus);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$status = status;
    result$data['status'] = toJson$Enum$AlertManagementStatus(l$status);
    return result$data;
  }

  CopyWith$Input$UpdateAlertStatusInput<Input$UpdateAlertStatusInput>
      get copyWith => CopyWith$Input$UpdateAlertStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateAlertStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$status = status;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateAlertStatusInput<TRes> {
  factory CopyWith$Input$UpdateAlertStatusInput(
    Input$UpdateAlertStatusInput instance,
    TRes Function(Input$UpdateAlertStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateAlertStatusInput;

  factory CopyWith$Input$UpdateAlertStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateAlertStatusInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$AlertManagementStatus? status,
  });
}

class _CopyWithImpl$Input$UpdateAlertStatusInput<TRes>
    implements CopyWith$Input$UpdateAlertStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateAlertStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateAlertStatusInput _instance;

  final TRes Function(Input$UpdateAlertStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateAlertStatusInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (status != _undefined && status != null)
          'status': (status as Enum$AlertManagementStatus),
      }));
}

class _CopyWithStubImpl$Input$UpdateAlertStatusInput<TRes>
    implements CopyWith$Input$UpdateAlertStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateAlertStatusInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    Enum$AlertManagementStatus? status,
  }) =>
      _res;
}

class Input$UpdateBoardEpicUserPreferencesInput {
  factory Input$UpdateBoardEpicUserPreferencesInput({
    String? clientMutationId,
    required String boardId,
    required String epicId,
    required bool collapsed,
  }) =>
      Input$UpdateBoardEpicUserPreferencesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'boardId': boardId,
        r'epicId': epicId,
        r'collapsed': collapsed,
      });

  Input$UpdateBoardEpicUserPreferencesInput._(this._$data);

  factory Input$UpdateBoardEpicUserPreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$boardId = data['boardId'];
    result$data['boardId'] = (l$boardId as String);
    final l$epicId = data['epicId'];
    result$data['epicId'] = (l$epicId as String);
    final l$collapsed = data['collapsed'];
    result$data['collapsed'] = (l$collapsed as bool);
    return Input$UpdateBoardEpicUserPreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get boardId => (_$data['boardId'] as String);
  String get epicId => (_$data['epicId'] as String);
  bool get collapsed => (_$data['collapsed'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$boardId = boardId;
    result$data['boardId'] = l$boardId;
    final l$epicId = epicId;
    result$data['epicId'] = l$epicId;
    final l$collapsed = collapsed;
    result$data['collapsed'] = l$collapsed;
    return result$data;
  }

  CopyWith$Input$UpdateBoardEpicUserPreferencesInput<
          Input$UpdateBoardEpicUserPreferencesInput>
      get copyWith => CopyWith$Input$UpdateBoardEpicUserPreferencesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBoardEpicUserPreferencesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$boardId = boardId;
    final lOther$boardId = other.boardId;
    if (l$boardId != lOther$boardId) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (l$epicId != lOther$epicId) {
      return false;
    }
    final l$collapsed = collapsed;
    final lOther$collapsed = other.collapsed;
    if (l$collapsed != lOther$collapsed) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$boardId = boardId;
    final l$epicId = epicId;
    final l$collapsed = collapsed;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$boardId,
      l$epicId,
      l$collapsed,
    ]);
  }
}

abstract class CopyWith$Input$UpdateBoardEpicUserPreferencesInput<TRes> {
  factory CopyWith$Input$UpdateBoardEpicUserPreferencesInput(
    Input$UpdateBoardEpicUserPreferencesInput instance,
    TRes Function(Input$UpdateBoardEpicUserPreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateBoardEpicUserPreferencesInput;

  factory CopyWith$Input$UpdateBoardEpicUserPreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBoardEpicUserPreferencesInput;

  TRes call({
    String? clientMutationId,
    String? boardId,
    String? epicId,
    bool? collapsed,
  });
}

class _CopyWithImpl$Input$UpdateBoardEpicUserPreferencesInput<TRes>
    implements CopyWith$Input$UpdateBoardEpicUserPreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateBoardEpicUserPreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBoardEpicUserPreferencesInput _instance;

  final TRes Function(Input$UpdateBoardEpicUserPreferencesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? boardId = _undefined,
    Object? epicId = _undefined,
    Object? collapsed = _undefined,
  }) =>
      _then(Input$UpdateBoardEpicUserPreferencesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (boardId != _undefined && boardId != null)
          'boardId': (boardId as String),
        if (epicId != _undefined && epicId != null)
          'epicId': (epicId as String),
        if (collapsed != _undefined && collapsed != null)
          'collapsed': (collapsed as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateBoardEpicUserPreferencesInput<TRes>
    implements CopyWith$Input$UpdateBoardEpicUserPreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBoardEpicUserPreferencesInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? boardId,
    String? epicId,
    bool? collapsed,
  }) =>
      _res;
}

class Input$UpdateBoardInput {
  factory Input$UpdateBoardInput({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    required String id,
    String? assigneeId,
    String? milestoneId,
    String? iterationId,
    String? iterationCadenceId,
    int? weight,
    List<String>? labels,
    List<String>? labelIds,
  }) =>
      Input$UpdateBoardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (name != null) r'name': name,
        if (hideBacklogList != null) r'hideBacklogList': hideBacklogList,
        if (hideClosedList != null) r'hideClosedList': hideClosedList,
        r'id': id,
        if (assigneeId != null) r'assigneeId': assigneeId,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (iterationId != null) r'iterationId': iterationId,
        if (iterationCadenceId != null)
          r'iterationCadenceId': iterationCadenceId,
        if (weight != null) r'weight': weight,
        if (labels != null) r'labels': labels,
        if (labelIds != null) r'labelIds': labelIds,
      });

  Input$UpdateBoardInput._(this._$data);

  factory Input$UpdateBoardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = data['hideBacklogList'];
      result$data['hideBacklogList'] = (l$hideBacklogList as bool?);
    }
    if (data.containsKey('hideClosedList')) {
      final l$hideClosedList = data['hideClosedList'];
      result$data['hideClosedList'] = (l$hideClosedList as bool?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('assigneeId')) {
      final l$assigneeId = data['assigneeId'];
      result$data['assigneeId'] = (l$assigneeId as String?);
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    if (data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = data['iterationCadenceId'];
      result$data['iterationCadenceId'] = (l$iterationCadenceId as String?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as int?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UpdateBoardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get name => (_$data['name'] as String?);
  bool? get hideBacklogList => (_$data['hideBacklogList'] as bool?);
  bool? get hideClosedList => (_$data['hideClosedList'] as bool?);
  String get id => (_$data['id'] as String);
  String? get assigneeId => (_$data['assigneeId'] as String?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  String? get iterationId => (_$data['iterationId'] as String?);
  String? get iterationCadenceId => (_$data['iterationCadenceId'] as String?);
  int? get weight => (_$data['weight'] as int?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('hideBacklogList')) {
      final l$hideBacklogList = hideBacklogList;
      result$data['hideBacklogList'] = l$hideBacklogList;
    }
    if (_$data.containsKey('hideClosedList')) {
      final l$hideClosedList = hideClosedList;
      result$data['hideClosedList'] = l$hideClosedList;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('assigneeId')) {
      final l$assigneeId = assigneeId;
      result$data['assigneeId'] = l$assigneeId;
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    if (_$data.containsKey('iterationCadenceId')) {
      final l$iterationCadenceId = iterationCadenceId;
      result$data['iterationCadenceId'] = l$iterationCadenceId;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateBoardInput<Input$UpdateBoardInput> get copyWith =>
      CopyWith$Input$UpdateBoardInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBoardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$hideBacklogList = hideBacklogList;
    final lOther$hideBacklogList = other.hideBacklogList;
    if (_$data.containsKey('hideBacklogList') !=
        other._$data.containsKey('hideBacklogList')) {
      return false;
    }
    if (l$hideBacklogList != lOther$hideBacklogList) {
      return false;
    }
    final l$hideClosedList = hideClosedList;
    final lOther$hideClosedList = other.hideClosedList;
    if (_$data.containsKey('hideClosedList') !=
        other._$data.containsKey('hideClosedList')) {
      return false;
    }
    if (l$hideClosedList != lOther$hideClosedList) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$assigneeId = assigneeId;
    final lOther$assigneeId = other.assigneeId;
    if (_$data.containsKey('assigneeId') !=
        other._$data.containsKey('assigneeId')) {
      return false;
    }
    if (l$assigneeId != lOther$assigneeId) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$iterationCadenceId = iterationCadenceId;
    final lOther$iterationCadenceId = other.iterationCadenceId;
    if (_$data.containsKey('iterationCadenceId') !=
        other._$data.containsKey('iterationCadenceId')) {
      return false;
    }
    if (l$iterationCadenceId != lOther$iterationCadenceId) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$hideBacklogList = hideBacklogList;
    final l$hideClosedList = hideClosedList;
    final l$id = id;
    final l$assigneeId = assigneeId;
    final l$milestoneId = milestoneId;
    final l$iterationId = iterationId;
    final l$iterationCadenceId = iterationCadenceId;
    final l$weight = weight;
    final l$labels = labels;
    final l$labelIds = labelIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('hideBacklogList') ? l$hideBacklogList : const {},
      _$data.containsKey('hideClosedList') ? l$hideClosedList : const {},
      l$id,
      _$data.containsKey('assigneeId') ? l$assigneeId : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
      _$data.containsKey('iterationCadenceId')
          ? l$iterationCadenceId
          : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateBoardInput<TRes> {
  factory CopyWith$Input$UpdateBoardInput(
    Input$UpdateBoardInput instance,
    TRes Function(Input$UpdateBoardInput) then,
  ) = _CopyWithImpl$Input$UpdateBoardInput;

  factory CopyWith$Input$UpdateBoardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBoardInput;

  TRes call({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    String? id,
    String? assigneeId,
    String? milestoneId,
    String? iterationId,
    String? iterationCadenceId,
    int? weight,
    List<String>? labels,
    List<String>? labelIds,
  });
}

class _CopyWithImpl$Input$UpdateBoardInput<TRes>
    implements CopyWith$Input$UpdateBoardInput<TRes> {
  _CopyWithImpl$Input$UpdateBoardInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBoardInput _instance;

  final TRes Function(Input$UpdateBoardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? hideBacklogList = _undefined,
    Object? hideClosedList = _undefined,
    Object? id = _undefined,
    Object? assigneeId = _undefined,
    Object? milestoneId = _undefined,
    Object? iterationId = _undefined,
    Object? iterationCadenceId = _undefined,
    Object? weight = _undefined,
    Object? labels = _undefined,
    Object? labelIds = _undefined,
  }) =>
      _then(Input$UpdateBoardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (hideBacklogList != _undefined)
          'hideBacklogList': (hideBacklogList as bool?),
        if (hideClosedList != _undefined)
          'hideClosedList': (hideClosedList as bool?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (assigneeId != _undefined) 'assigneeId': (assigneeId as String?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
        if (iterationCadenceId != _undefined)
          'iterationCadenceId': (iterationCadenceId as String?),
        if (weight != _undefined) 'weight': (weight as int?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UpdateBoardInput<TRes>
    implements CopyWith$Input$UpdateBoardInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBoardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    bool? hideBacklogList,
    bool? hideClosedList,
    String? id,
    String? assigneeId,
    String? milestoneId,
    String? iterationId,
    String? iterationCadenceId,
    int? weight,
    List<String>? labels,
    List<String>? labelIds,
  }) =>
      _res;
}

class Input$UpdateBoardListInput {
  factory Input$UpdateBoardListInput({
    int? position,
    bool? collapsed,
    String? clientMutationId,
    required String listId,
  }) =>
      Input$UpdateBoardListInput._({
        if (position != null) r'position': position,
        if (collapsed != null) r'collapsed': collapsed,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
      });

  Input$UpdateBoardListInput._(this._$data);

  factory Input$UpdateBoardListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('position')) {
      final l$position = data['position'];
      result$data['position'] = (l$position as int?);
    }
    if (data.containsKey('collapsed')) {
      final l$collapsed = data['collapsed'];
      result$data['collapsed'] = (l$collapsed as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    return Input$UpdateBoardListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get position => (_$data['position'] as int?);
  bool? get collapsed => (_$data['collapsed'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get listId => (_$data['listId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('position')) {
      final l$position = position;
      result$data['position'] = l$position;
    }
    if (_$data.containsKey('collapsed')) {
      final l$collapsed = collapsed;
      result$data['collapsed'] = l$collapsed;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    return result$data;
  }

  CopyWith$Input$UpdateBoardListInput<Input$UpdateBoardListInput>
      get copyWith => CopyWith$Input$UpdateBoardListInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBoardListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (_$data.containsKey('position') !=
        other._$data.containsKey('position')) {
      return false;
    }
    if (l$position != lOther$position) {
      return false;
    }
    final l$collapsed = collapsed;
    final lOther$collapsed = other.collapsed;
    if (_$data.containsKey('collapsed') !=
        other._$data.containsKey('collapsed')) {
      return false;
    }
    if (l$collapsed != lOther$collapsed) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$position = position;
    final l$collapsed = collapsed;
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    return Object.hashAll([
      _$data.containsKey('position') ? l$position : const {},
      _$data.containsKey('collapsed') ? l$collapsed : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateBoardListInput<TRes> {
  factory CopyWith$Input$UpdateBoardListInput(
    Input$UpdateBoardListInput instance,
    TRes Function(Input$UpdateBoardListInput) then,
  ) = _CopyWithImpl$Input$UpdateBoardListInput;

  factory CopyWith$Input$UpdateBoardListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBoardListInput;

  TRes call({
    int? position,
    bool? collapsed,
    String? clientMutationId,
    String? listId,
  });
}

class _CopyWithImpl$Input$UpdateBoardListInput<TRes>
    implements CopyWith$Input$UpdateBoardListInput<TRes> {
  _CopyWithImpl$Input$UpdateBoardListInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBoardListInput _instance;

  final TRes Function(Input$UpdateBoardListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? position = _undefined,
    Object? collapsed = _undefined,
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
  }) =>
      _then(Input$UpdateBoardListInput._({
        ..._instance._$data,
        if (position != _undefined) 'position': (position as int?),
        if (collapsed != _undefined) 'collapsed': (collapsed as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateBoardListInput<TRes>
    implements CopyWith$Input$UpdateBoardListInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBoardListInput(this._res);

  TRes _res;

  call({
    int? position,
    bool? collapsed,
    String? clientMutationId,
    String? listId,
  }) =>
      _res;
}

class Input$UpdateComplianceFrameworkInput {
  factory Input$UpdateComplianceFrameworkInput({
    String? clientMutationId,
    required String id,
    required Input$ComplianceFrameworkInput params,
  }) =>
      Input$UpdateComplianceFrameworkInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'params': params,
      });

  Input$UpdateComplianceFrameworkInput._(this._$data);

  factory Input$UpdateComplianceFrameworkInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$params = data['params'];
    result$data['params'] = Input$ComplianceFrameworkInput.fromJson(
        (l$params as Map<String, dynamic>));
    return Input$UpdateComplianceFrameworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Input$ComplianceFrameworkInput get params =>
      (_$data['params'] as Input$ComplianceFrameworkInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$params = params;
    result$data['params'] = l$params.toJson();
    return result$data;
  }

  CopyWith$Input$UpdateComplianceFrameworkInput<
          Input$UpdateComplianceFrameworkInput>
      get copyWith => CopyWith$Input$UpdateComplianceFrameworkInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateComplianceFrameworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$params = params;
    final lOther$params = other.params;
    if (l$params != lOther$params) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$params = params;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$params,
    ]);
  }
}

abstract class CopyWith$Input$UpdateComplianceFrameworkInput<TRes> {
  factory CopyWith$Input$UpdateComplianceFrameworkInput(
    Input$UpdateComplianceFrameworkInput instance,
    TRes Function(Input$UpdateComplianceFrameworkInput) then,
  ) = _CopyWithImpl$Input$UpdateComplianceFrameworkInput;

  factory CopyWith$Input$UpdateComplianceFrameworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateComplianceFrameworkInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Input$ComplianceFrameworkInput? params,
  });
  CopyWith$Input$ComplianceFrameworkInput<TRes> get params;
}

class _CopyWithImpl$Input$UpdateComplianceFrameworkInput<TRes>
    implements CopyWith$Input$UpdateComplianceFrameworkInput<TRes> {
  _CopyWithImpl$Input$UpdateComplianceFrameworkInput(
    this._instance,
    this._then,
  );

  final Input$UpdateComplianceFrameworkInput _instance;

  final TRes Function(Input$UpdateComplianceFrameworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? params = _undefined,
  }) =>
      _then(Input$UpdateComplianceFrameworkInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (params != _undefined && params != null)
          'params': (params as Input$ComplianceFrameworkInput),
      }));
  CopyWith$Input$ComplianceFrameworkInput<TRes> get params {
    final local$params = _instance.params;
    return CopyWith$Input$ComplianceFrameworkInput(
        local$params, (e) => call(params: e));
  }
}

class _CopyWithStubImpl$Input$UpdateComplianceFrameworkInput<TRes>
    implements CopyWith$Input$UpdateComplianceFrameworkInput<TRes> {
  _CopyWithStubImpl$Input$UpdateComplianceFrameworkInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Input$ComplianceFrameworkInput? params,
  }) =>
      _res;
  CopyWith$Input$ComplianceFrameworkInput<TRes> get params =>
      CopyWith$Input$ComplianceFrameworkInput.stub(_res);
}

class Input$UpdateContainerExpirationPolicyInput {
  factory Input$UpdateContainerExpirationPolicyInput({
    String? clientMutationId,
    required String projectPath,
    bool? enabled,
    Enum$ContainerExpirationPolicyCadenceEnum? cadence,
    Enum$ContainerExpirationPolicyOlderThanEnum? olderThan,
    Enum$ContainerExpirationPolicyKeepEnum? keepN,
    String? nameRegex,
    String? nameRegexKeep,
  }) =>
      Input$UpdateContainerExpirationPolicyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        if (enabled != null) r'enabled': enabled,
        if (cadence != null) r'cadence': cadence,
        if (olderThan != null) r'olderThan': olderThan,
        if (keepN != null) r'keepN': keepN,
        if (nameRegex != null) r'nameRegex': nameRegex,
        if (nameRegexKeep != null) r'nameRegexKeep': nameRegexKeep,
      });

  Input$UpdateContainerExpirationPolicyInput._(this._$data);

  factory Input$UpdateContainerExpirationPolicyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('enabled')) {
      final l$enabled = data['enabled'];
      result$data['enabled'] = (l$enabled as bool?);
    }
    if (data.containsKey('cadence')) {
      final l$cadence = data['cadence'];
      result$data['cadence'] = l$cadence == null
          ? null
          : fromJson$Enum$ContainerExpirationPolicyCadenceEnum(
              (l$cadence as String));
    }
    if (data.containsKey('olderThan')) {
      final l$olderThan = data['olderThan'];
      result$data['olderThan'] = l$olderThan == null
          ? null
          : fromJson$Enum$ContainerExpirationPolicyOlderThanEnum(
              (l$olderThan as String));
    }
    if (data.containsKey('keepN')) {
      final l$keepN = data['keepN'];
      result$data['keepN'] = l$keepN == null
          ? null
          : fromJson$Enum$ContainerExpirationPolicyKeepEnum(
              (l$keepN as String));
    }
    if (data.containsKey('nameRegex')) {
      final l$nameRegex = data['nameRegex'];
      result$data['nameRegex'] = (l$nameRegex as String?);
    }
    if (data.containsKey('nameRegexKeep')) {
      final l$nameRegexKeep = data['nameRegexKeep'];
      result$data['nameRegexKeep'] = (l$nameRegexKeep as String?);
    }
    return Input$UpdateContainerExpirationPolicyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  bool? get enabled => (_$data['enabled'] as bool?);
  Enum$ContainerExpirationPolicyCadenceEnum? get cadence =>
      (_$data['cadence'] as Enum$ContainerExpirationPolicyCadenceEnum?);
  Enum$ContainerExpirationPolicyOlderThanEnum? get olderThan =>
      (_$data['olderThan'] as Enum$ContainerExpirationPolicyOlderThanEnum?);
  Enum$ContainerExpirationPolicyKeepEnum? get keepN =>
      (_$data['keepN'] as Enum$ContainerExpirationPolicyKeepEnum?);
  String? get nameRegex => (_$data['nameRegex'] as String?);
  String? get nameRegexKeep => (_$data['nameRegexKeep'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('enabled')) {
      final l$enabled = enabled;
      result$data['enabled'] = l$enabled;
    }
    if (_$data.containsKey('cadence')) {
      final l$cadence = cadence;
      result$data['cadence'] = l$cadence == null
          ? null
          : toJson$Enum$ContainerExpirationPolicyCadenceEnum(l$cadence);
    }
    if (_$data.containsKey('olderThan')) {
      final l$olderThan = olderThan;
      result$data['olderThan'] = l$olderThan == null
          ? null
          : toJson$Enum$ContainerExpirationPolicyOlderThanEnum(l$olderThan);
    }
    if (_$data.containsKey('keepN')) {
      final l$keepN = keepN;
      result$data['keepN'] = l$keepN == null
          ? null
          : toJson$Enum$ContainerExpirationPolicyKeepEnum(l$keepN);
    }
    if (_$data.containsKey('nameRegex')) {
      final l$nameRegex = nameRegex;
      result$data['nameRegex'] = l$nameRegex;
    }
    if (_$data.containsKey('nameRegexKeep')) {
      final l$nameRegexKeep = nameRegexKeep;
      result$data['nameRegexKeep'] = l$nameRegexKeep;
    }
    return result$data;
  }

  CopyWith$Input$UpdateContainerExpirationPolicyInput<
          Input$UpdateContainerExpirationPolicyInput>
      get copyWith => CopyWith$Input$UpdateContainerExpirationPolicyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateContainerExpirationPolicyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (_$data.containsKey('enabled') != other._$data.containsKey('enabled')) {
      return false;
    }
    if (l$enabled != lOther$enabled) {
      return false;
    }
    final l$cadence = cadence;
    final lOther$cadence = other.cadence;
    if (_$data.containsKey('cadence') != other._$data.containsKey('cadence')) {
      return false;
    }
    if (l$cadence != lOther$cadence) {
      return false;
    }
    final l$olderThan = olderThan;
    final lOther$olderThan = other.olderThan;
    if (_$data.containsKey('olderThan') !=
        other._$data.containsKey('olderThan')) {
      return false;
    }
    if (l$olderThan != lOther$olderThan) {
      return false;
    }
    final l$keepN = keepN;
    final lOther$keepN = other.keepN;
    if (_$data.containsKey('keepN') != other._$data.containsKey('keepN')) {
      return false;
    }
    if (l$keepN != lOther$keepN) {
      return false;
    }
    final l$nameRegex = nameRegex;
    final lOther$nameRegex = other.nameRegex;
    if (_$data.containsKey('nameRegex') !=
        other._$data.containsKey('nameRegex')) {
      return false;
    }
    if (l$nameRegex != lOther$nameRegex) {
      return false;
    }
    final l$nameRegexKeep = nameRegexKeep;
    final lOther$nameRegexKeep = other.nameRegexKeep;
    if (_$data.containsKey('nameRegexKeep') !=
        other._$data.containsKey('nameRegexKeep')) {
      return false;
    }
    if (l$nameRegexKeep != lOther$nameRegexKeep) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$enabled = enabled;
    final l$cadence = cadence;
    final l$olderThan = olderThan;
    final l$keepN = keepN;
    final l$nameRegex = nameRegex;
    final l$nameRegexKeep = nameRegexKeep;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      _$data.containsKey('enabled') ? l$enabled : const {},
      _$data.containsKey('cadence') ? l$cadence : const {},
      _$data.containsKey('olderThan') ? l$olderThan : const {},
      _$data.containsKey('keepN') ? l$keepN : const {},
      _$data.containsKey('nameRegex') ? l$nameRegex : const {},
      _$data.containsKey('nameRegexKeep') ? l$nameRegexKeep : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateContainerExpirationPolicyInput<TRes> {
  factory CopyWith$Input$UpdateContainerExpirationPolicyInput(
    Input$UpdateContainerExpirationPolicyInput instance,
    TRes Function(Input$UpdateContainerExpirationPolicyInput) then,
  ) = _CopyWithImpl$Input$UpdateContainerExpirationPolicyInput;

  factory CopyWith$Input$UpdateContainerExpirationPolicyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateContainerExpirationPolicyInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    bool? enabled,
    Enum$ContainerExpirationPolicyCadenceEnum? cadence,
    Enum$ContainerExpirationPolicyOlderThanEnum? olderThan,
    Enum$ContainerExpirationPolicyKeepEnum? keepN,
    String? nameRegex,
    String? nameRegexKeep,
  });
}

class _CopyWithImpl$Input$UpdateContainerExpirationPolicyInput<TRes>
    implements CopyWith$Input$UpdateContainerExpirationPolicyInput<TRes> {
  _CopyWithImpl$Input$UpdateContainerExpirationPolicyInput(
    this._instance,
    this._then,
  );

  final Input$UpdateContainerExpirationPolicyInput _instance;

  final TRes Function(Input$UpdateContainerExpirationPolicyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? enabled = _undefined,
    Object? cadence = _undefined,
    Object? olderThan = _undefined,
    Object? keepN = _undefined,
    Object? nameRegex = _undefined,
    Object? nameRegexKeep = _undefined,
  }) =>
      _then(Input$UpdateContainerExpirationPolicyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (enabled != _undefined) 'enabled': (enabled as bool?),
        if (cadence != _undefined)
          'cadence': (cadence as Enum$ContainerExpirationPolicyCadenceEnum?),
        if (olderThan != _undefined)
          'olderThan':
              (olderThan as Enum$ContainerExpirationPolicyOlderThanEnum?),
        if (keepN != _undefined)
          'keepN': (keepN as Enum$ContainerExpirationPolicyKeepEnum?),
        if (nameRegex != _undefined) 'nameRegex': (nameRegex as String?),
        if (nameRegexKeep != _undefined)
          'nameRegexKeep': (nameRegexKeep as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateContainerExpirationPolicyInput<TRes>
    implements CopyWith$Input$UpdateContainerExpirationPolicyInput<TRes> {
  _CopyWithStubImpl$Input$UpdateContainerExpirationPolicyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    bool? enabled,
    Enum$ContainerExpirationPolicyCadenceEnum? cadence,
    Enum$ContainerExpirationPolicyOlderThanEnum? olderThan,
    Enum$ContainerExpirationPolicyKeepEnum? keepN,
    String? nameRegex,
    String? nameRegexKeep,
  }) =>
      _res;
}

class Input$UpdateDependencyProxyImageTtlGroupPolicyInput {
  factory Input$UpdateDependencyProxyImageTtlGroupPolicyInput({
    String? clientMutationId,
    required String groupPath,
    bool? enabled,
    int? ttl,
  }) =>
      Input$UpdateDependencyProxyImageTtlGroupPolicyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        if (enabled != null) r'enabled': enabled,
        if (ttl != null) r'ttl': ttl,
      });

  Input$UpdateDependencyProxyImageTtlGroupPolicyInput._(this._$data);

  factory Input$UpdateDependencyProxyImageTtlGroupPolicyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('enabled')) {
      final l$enabled = data['enabled'];
      result$data['enabled'] = (l$enabled as bool?);
    }
    if (data.containsKey('ttl')) {
      final l$ttl = data['ttl'];
      result$data['ttl'] = (l$ttl as int?);
    }
    return Input$UpdateDependencyProxyImageTtlGroupPolicyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  bool? get enabled => (_$data['enabled'] as bool?);
  int? get ttl => (_$data['ttl'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('enabled')) {
      final l$enabled = enabled;
      result$data['enabled'] = l$enabled;
    }
    if (_$data.containsKey('ttl')) {
      final l$ttl = ttl;
      result$data['ttl'] = l$ttl;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput<
          Input$UpdateDependencyProxyImageTtlGroupPolicyInput>
      get copyWith =>
          CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDependencyProxyImageTtlGroupPolicyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (_$data.containsKey('enabled') != other._$data.containsKey('enabled')) {
      return false;
    }
    if (l$enabled != lOther$enabled) {
      return false;
    }
    final l$ttl = ttl;
    final lOther$ttl = other.ttl;
    if (_$data.containsKey('ttl') != other._$data.containsKey('ttl')) {
      return false;
    }
    if (l$ttl != lOther$ttl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$enabled = enabled;
    final l$ttl = ttl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      _$data.containsKey('enabled') ? l$enabled : const {},
      _$data.containsKey('ttl') ? l$ttl : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput<
    TRes> {
  factory CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput(
    Input$UpdateDependencyProxyImageTtlGroupPolicyInput instance,
    TRes Function(Input$UpdateDependencyProxyImageTtlGroupPolicyInput) then,
  ) = _CopyWithImpl$Input$UpdateDependencyProxyImageTtlGroupPolicyInput;

  factory CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateDependencyProxyImageTtlGroupPolicyInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    bool? enabled,
    int? ttl,
  });
}

class _CopyWithImpl$Input$UpdateDependencyProxyImageTtlGroupPolicyInput<TRes>
    implements
        CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput<TRes> {
  _CopyWithImpl$Input$UpdateDependencyProxyImageTtlGroupPolicyInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDependencyProxyImageTtlGroupPolicyInput _instance;

  final TRes Function(Input$UpdateDependencyProxyImageTtlGroupPolicyInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? enabled = _undefined,
    Object? ttl = _undefined,
  }) =>
      _then(Input$UpdateDependencyProxyImageTtlGroupPolicyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (enabled != _undefined) 'enabled': (enabled as bool?),
        if (ttl != _undefined) 'ttl': (ttl as int?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDependencyProxyImageTtlGroupPolicyInput<
        TRes>
    implements
        CopyWith$Input$UpdateDependencyProxyImageTtlGroupPolicyInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDependencyProxyImageTtlGroupPolicyInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    bool? enabled,
    int? ttl,
  }) =>
      _res;
}

class Input$UpdateDependencyProxySettingsInput {
  factory Input$UpdateDependencyProxySettingsInput({
    String? clientMutationId,
    required String groupPath,
    bool? enabled,
  }) =>
      Input$UpdateDependencyProxySettingsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        if (enabled != null) r'enabled': enabled,
      });

  Input$UpdateDependencyProxySettingsInput._(this._$data);

  factory Input$UpdateDependencyProxySettingsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('enabled')) {
      final l$enabled = data['enabled'];
      result$data['enabled'] = (l$enabled as bool?);
    }
    return Input$UpdateDependencyProxySettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  bool? get enabled => (_$data['enabled'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('enabled')) {
      final l$enabled = enabled;
      result$data['enabled'] = l$enabled;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDependencyProxySettingsInput<
          Input$UpdateDependencyProxySettingsInput>
      get copyWith => CopyWith$Input$UpdateDependencyProxySettingsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDependencyProxySettingsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (_$data.containsKey('enabled') != other._$data.containsKey('enabled')) {
      return false;
    }
    if (l$enabled != lOther$enabled) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$enabled = enabled;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      _$data.containsKey('enabled') ? l$enabled : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDependencyProxySettingsInput<TRes> {
  factory CopyWith$Input$UpdateDependencyProxySettingsInput(
    Input$UpdateDependencyProxySettingsInput instance,
    TRes Function(Input$UpdateDependencyProxySettingsInput) then,
  ) = _CopyWithImpl$Input$UpdateDependencyProxySettingsInput;

  factory CopyWith$Input$UpdateDependencyProxySettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDependencyProxySettingsInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    bool? enabled,
  });
}

class _CopyWithImpl$Input$UpdateDependencyProxySettingsInput<TRes>
    implements CopyWith$Input$UpdateDependencyProxySettingsInput<TRes> {
  _CopyWithImpl$Input$UpdateDependencyProxySettingsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDependencyProxySettingsInput _instance;

  final TRes Function(Input$UpdateDependencyProxySettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? enabled = _undefined,
  }) =>
      _then(Input$UpdateDependencyProxySettingsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (enabled != _undefined) 'enabled': (enabled as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDependencyProxySettingsInput<TRes>
    implements CopyWith$Input$UpdateDependencyProxySettingsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDependencyProxySettingsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    bool? enabled,
  }) =>
      _res;
}

class Input$UpdateDiffImagePositionInput {
  factory Input$UpdateDiffImagePositionInput({
    int? x,
    int? y,
    int? width,
    int? height,
  }) =>
      Input$UpdateDiffImagePositionInput._({
        if (x != null) r'x': x,
        if (y != null) r'y': y,
        if (width != null) r'width': width,
        if (height != null) r'height': height,
      });

  Input$UpdateDiffImagePositionInput._(this._$data);

  factory Input$UpdateDiffImagePositionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('x')) {
      final l$x = data['x'];
      result$data['x'] = (l$x as int?);
    }
    if (data.containsKey('y')) {
      final l$y = data['y'];
      result$data['y'] = (l$y as int?);
    }
    if (data.containsKey('width')) {
      final l$width = data['width'];
      result$data['width'] = (l$width as int?);
    }
    if (data.containsKey('height')) {
      final l$height = data['height'];
      result$data['height'] = (l$height as int?);
    }
    return Input$UpdateDiffImagePositionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get x => (_$data['x'] as int?);
  int? get y => (_$data['y'] as int?);
  int? get width => (_$data['width'] as int?);
  int? get height => (_$data['height'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('x')) {
      final l$x = x;
      result$data['x'] = l$x;
    }
    if (_$data.containsKey('y')) {
      final l$y = y;
      result$data['y'] = l$y;
    }
    if (_$data.containsKey('width')) {
      final l$width = width;
      result$data['width'] = l$width;
    }
    if (_$data.containsKey('height')) {
      final l$height = height;
      result$data['height'] = l$height;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDiffImagePositionInput<
          Input$UpdateDiffImagePositionInput>
      get copyWith => CopyWith$Input$UpdateDiffImagePositionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDiffImagePositionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$x = x;
    final lOther$x = other.x;
    if (_$data.containsKey('x') != other._$data.containsKey('x')) {
      return false;
    }
    if (l$x != lOther$x) {
      return false;
    }
    final l$y = y;
    final lOther$y = other.y;
    if (_$data.containsKey('y') != other._$data.containsKey('y')) {
      return false;
    }
    if (l$y != lOther$y) {
      return false;
    }
    final l$width = width;
    final lOther$width = other.width;
    if (_$data.containsKey('width') != other._$data.containsKey('width')) {
      return false;
    }
    if (l$width != lOther$width) {
      return false;
    }
    final l$height = height;
    final lOther$height = other.height;
    if (_$data.containsKey('height') != other._$data.containsKey('height')) {
      return false;
    }
    if (l$height != lOther$height) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$x = x;
    final l$y = y;
    final l$width = width;
    final l$height = height;
    return Object.hashAll([
      _$data.containsKey('x') ? l$x : const {},
      _$data.containsKey('y') ? l$y : const {},
      _$data.containsKey('width') ? l$width : const {},
      _$data.containsKey('height') ? l$height : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiffImagePositionInput<TRes> {
  factory CopyWith$Input$UpdateDiffImagePositionInput(
    Input$UpdateDiffImagePositionInput instance,
    TRes Function(Input$UpdateDiffImagePositionInput) then,
  ) = _CopyWithImpl$Input$UpdateDiffImagePositionInput;

  factory CopyWith$Input$UpdateDiffImagePositionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiffImagePositionInput;

  TRes call({
    int? x,
    int? y,
    int? width,
    int? height,
  });
}

class _CopyWithImpl$Input$UpdateDiffImagePositionInput<TRes>
    implements CopyWith$Input$UpdateDiffImagePositionInput<TRes> {
  _CopyWithImpl$Input$UpdateDiffImagePositionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiffImagePositionInput _instance;

  final TRes Function(Input$UpdateDiffImagePositionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? x = _undefined,
    Object? y = _undefined,
    Object? width = _undefined,
    Object? height = _undefined,
  }) =>
      _then(Input$UpdateDiffImagePositionInput._({
        ..._instance._$data,
        if (x != _undefined) 'x': (x as int?),
        if (y != _undefined) 'y': (y as int?),
        if (width != _undefined) 'width': (width as int?),
        if (height != _undefined) 'height': (height as int?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiffImagePositionInput<TRes>
    implements CopyWith$Input$UpdateDiffImagePositionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiffImagePositionInput(this._res);

  TRes _res;

  call({
    int? x,
    int? y,
    int? width,
    int? height,
  }) =>
      _res;
}

class Input$UpdateEpicBoardListInput {
  factory Input$UpdateEpicBoardListInput({
    int? position,
    bool? collapsed,
    String? clientMutationId,
    required String listId,
  }) =>
      Input$UpdateEpicBoardListInput._({
        if (position != null) r'position': position,
        if (collapsed != null) r'collapsed': collapsed,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
      });

  Input$UpdateEpicBoardListInput._(this._$data);

  factory Input$UpdateEpicBoardListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('position')) {
      final l$position = data['position'];
      result$data['position'] = (l$position as int?);
    }
    if (data.containsKey('collapsed')) {
      final l$collapsed = data['collapsed'];
      result$data['collapsed'] = (l$collapsed as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    return Input$UpdateEpicBoardListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get position => (_$data['position'] as int?);
  bool? get collapsed => (_$data['collapsed'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get listId => (_$data['listId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('position')) {
      final l$position = position;
      result$data['position'] = l$position;
    }
    if (_$data.containsKey('collapsed')) {
      final l$collapsed = collapsed;
      result$data['collapsed'] = l$collapsed;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    return result$data;
  }

  CopyWith$Input$UpdateEpicBoardListInput<Input$UpdateEpicBoardListInput>
      get copyWith => CopyWith$Input$UpdateEpicBoardListInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEpicBoardListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (_$data.containsKey('position') !=
        other._$data.containsKey('position')) {
      return false;
    }
    if (l$position != lOther$position) {
      return false;
    }
    final l$collapsed = collapsed;
    final lOther$collapsed = other.collapsed;
    if (_$data.containsKey('collapsed') !=
        other._$data.containsKey('collapsed')) {
      return false;
    }
    if (l$collapsed != lOther$collapsed) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$position = position;
    final l$collapsed = collapsed;
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    return Object.hashAll([
      _$data.containsKey('position') ? l$position : const {},
      _$data.containsKey('collapsed') ? l$collapsed : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEpicBoardListInput<TRes> {
  factory CopyWith$Input$UpdateEpicBoardListInput(
    Input$UpdateEpicBoardListInput instance,
    TRes Function(Input$UpdateEpicBoardListInput) then,
  ) = _CopyWithImpl$Input$UpdateEpicBoardListInput;

  factory CopyWith$Input$UpdateEpicBoardListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEpicBoardListInput;

  TRes call({
    int? position,
    bool? collapsed,
    String? clientMutationId,
    String? listId,
  });
}

class _CopyWithImpl$Input$UpdateEpicBoardListInput<TRes>
    implements CopyWith$Input$UpdateEpicBoardListInput<TRes> {
  _CopyWithImpl$Input$UpdateEpicBoardListInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEpicBoardListInput _instance;

  final TRes Function(Input$UpdateEpicBoardListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? position = _undefined,
    Object? collapsed = _undefined,
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
  }) =>
      _then(Input$UpdateEpicBoardListInput._({
        ..._instance._$data,
        if (position != _undefined) 'position': (position as int?),
        if (collapsed != _undefined) 'collapsed': (collapsed as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateEpicBoardListInput<TRes>
    implements CopyWith$Input$UpdateEpicBoardListInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEpicBoardListInput(this._res);

  TRes _res;

  call({
    int? position,
    bool? collapsed,
    String? clientMutationId,
    String? listId,
  }) =>
      _res;
}

class Input$UpdateEpicInput {
  factory Input$UpdateEpicInput({
    required String iid,
    String? clientMutationId,
    required String groupPath,
    String? title,
    String? description,
    bool? confidential,
    String? startDateFixed,
    String? dueDateFixed,
    bool? startDateIsFixed,
    bool? dueDateIsFixed,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? addLabels,
    String? color,
    Enum$EpicStateEvent? stateEvent,
    List<String>? removeLabels,
  }) =>
      Input$UpdateEpicInput._({
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (confidential != null) r'confidential': confidential,
        if (startDateFixed != null) r'startDateFixed': startDateFixed,
        if (dueDateFixed != null) r'dueDateFixed': dueDateFixed,
        if (startDateIsFixed != null) r'startDateIsFixed': startDateIsFixed,
        if (dueDateIsFixed != null) r'dueDateIsFixed': dueDateIsFixed,
        if (addLabelIds != null) r'addLabelIds': addLabelIds,
        if (removeLabelIds != null) r'removeLabelIds': removeLabelIds,
        if (addLabels != null) r'addLabels': addLabels,
        if (color != null) r'color': color,
        if (stateEvent != null) r'stateEvent': stateEvent,
        if (removeLabels != null) r'removeLabels': removeLabels,
      });

  Input$UpdateEpicInput._(this._$data);

  factory Input$UpdateEpicInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('startDateFixed')) {
      final l$startDateFixed = data['startDateFixed'];
      result$data['startDateFixed'] = (l$startDateFixed as String?);
    }
    if (data.containsKey('dueDateFixed')) {
      final l$dueDateFixed = data['dueDateFixed'];
      result$data['dueDateFixed'] = (l$dueDateFixed as String?);
    }
    if (data.containsKey('startDateIsFixed')) {
      final l$startDateIsFixed = data['startDateIsFixed'];
      result$data['startDateIsFixed'] = (l$startDateIsFixed as bool?);
    }
    if (data.containsKey('dueDateIsFixed')) {
      final l$dueDateIsFixed = data['dueDateIsFixed'];
      result$data['dueDateIsFixed'] = (l$dueDateIsFixed as bool?);
    }
    if (data.containsKey('addLabelIds')) {
      final l$addLabelIds = data['addLabelIds'];
      result$data['addLabelIds'] =
          (l$addLabelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeLabelIds')) {
      final l$removeLabelIds = data['removeLabelIds'];
      result$data['removeLabelIds'] = (l$removeLabelIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addLabels')) {
      final l$addLabels = data['addLabels'];
      result$data['addLabels'] =
          (l$addLabels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = (l$color as String?);
    }
    if (data.containsKey('stateEvent')) {
      final l$stateEvent = data['stateEvent'];
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : fromJson$Enum$EpicStateEvent((l$stateEvent as String));
    }
    if (data.containsKey('removeLabels')) {
      final l$removeLabels = data['removeLabels'];
      result$data['removeLabels'] = (l$removeLabels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$UpdateEpicInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  String? get startDateFixed => (_$data['startDateFixed'] as String?);
  String? get dueDateFixed => (_$data['dueDateFixed'] as String?);
  bool? get startDateIsFixed => (_$data['startDateIsFixed'] as bool?);
  bool? get dueDateIsFixed => (_$data['dueDateIsFixed'] as bool?);
  List<String>? get addLabelIds => (_$data['addLabelIds'] as List<String>?);
  List<String>? get removeLabelIds =>
      (_$data['removeLabelIds'] as List<String>?);
  List<String>? get addLabels => (_$data['addLabels'] as List<String>?);
  String? get color => (_$data['color'] as String?);
  Enum$EpicStateEvent? get stateEvent =>
      (_$data['stateEvent'] as Enum$EpicStateEvent?);
  List<String>? get removeLabels => (_$data['removeLabels'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('startDateFixed')) {
      final l$startDateFixed = startDateFixed;
      result$data['startDateFixed'] = l$startDateFixed;
    }
    if (_$data.containsKey('dueDateFixed')) {
      final l$dueDateFixed = dueDateFixed;
      result$data['dueDateFixed'] = l$dueDateFixed;
    }
    if (_$data.containsKey('startDateIsFixed')) {
      final l$startDateIsFixed = startDateIsFixed;
      result$data['startDateIsFixed'] = l$startDateIsFixed;
    }
    if (_$data.containsKey('dueDateIsFixed')) {
      final l$dueDateIsFixed = dueDateIsFixed;
      result$data['dueDateIsFixed'] = l$dueDateIsFixed;
    }
    if (_$data.containsKey('addLabelIds')) {
      final l$addLabelIds = addLabelIds;
      result$data['addLabelIds'] = l$addLabelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeLabelIds')) {
      final l$removeLabelIds = removeLabelIds;
      result$data['removeLabelIds'] = l$removeLabelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('addLabels')) {
      final l$addLabels = addLabels;
      result$data['addLabels'] = l$addLabels?.map((e) => e).toList();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color;
    }
    if (_$data.containsKey('stateEvent')) {
      final l$stateEvent = stateEvent;
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : toJson$Enum$EpicStateEvent(l$stateEvent);
    }
    if (_$data.containsKey('removeLabels')) {
      final l$removeLabels = removeLabels;
      result$data['removeLabels'] = l$removeLabels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateEpicInput<Input$UpdateEpicInput> get copyWith =>
      CopyWith$Input$UpdateEpicInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEpicInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$startDateFixed = startDateFixed;
    final lOther$startDateFixed = other.startDateFixed;
    if (_$data.containsKey('startDateFixed') !=
        other._$data.containsKey('startDateFixed')) {
      return false;
    }
    if (l$startDateFixed != lOther$startDateFixed) {
      return false;
    }
    final l$dueDateFixed = dueDateFixed;
    final lOther$dueDateFixed = other.dueDateFixed;
    if (_$data.containsKey('dueDateFixed') !=
        other._$data.containsKey('dueDateFixed')) {
      return false;
    }
    if (l$dueDateFixed != lOther$dueDateFixed) {
      return false;
    }
    final l$startDateIsFixed = startDateIsFixed;
    final lOther$startDateIsFixed = other.startDateIsFixed;
    if (_$data.containsKey('startDateIsFixed') !=
        other._$data.containsKey('startDateIsFixed')) {
      return false;
    }
    if (l$startDateIsFixed != lOther$startDateIsFixed) {
      return false;
    }
    final l$dueDateIsFixed = dueDateIsFixed;
    final lOther$dueDateIsFixed = other.dueDateIsFixed;
    if (_$data.containsKey('dueDateIsFixed') !=
        other._$data.containsKey('dueDateIsFixed')) {
      return false;
    }
    if (l$dueDateIsFixed != lOther$dueDateIsFixed) {
      return false;
    }
    final l$addLabelIds = addLabelIds;
    final lOther$addLabelIds = other.addLabelIds;
    if (_$data.containsKey('addLabelIds') !=
        other._$data.containsKey('addLabelIds')) {
      return false;
    }
    if (l$addLabelIds != null && lOther$addLabelIds != null) {
      if (l$addLabelIds.length != lOther$addLabelIds.length) {
        return false;
      }
      for (int i = 0; i < l$addLabelIds.length; i++) {
        final l$addLabelIds$entry = l$addLabelIds[i];
        final lOther$addLabelIds$entry = lOther$addLabelIds[i];
        if (l$addLabelIds$entry != lOther$addLabelIds$entry) {
          return false;
        }
      }
    } else if (l$addLabelIds != lOther$addLabelIds) {
      return false;
    }
    final l$removeLabelIds = removeLabelIds;
    final lOther$removeLabelIds = other.removeLabelIds;
    if (_$data.containsKey('removeLabelIds') !=
        other._$data.containsKey('removeLabelIds')) {
      return false;
    }
    if (l$removeLabelIds != null && lOther$removeLabelIds != null) {
      if (l$removeLabelIds.length != lOther$removeLabelIds.length) {
        return false;
      }
      for (int i = 0; i < l$removeLabelIds.length; i++) {
        final l$removeLabelIds$entry = l$removeLabelIds[i];
        final lOther$removeLabelIds$entry = lOther$removeLabelIds[i];
        if (l$removeLabelIds$entry != lOther$removeLabelIds$entry) {
          return false;
        }
      }
    } else if (l$removeLabelIds != lOther$removeLabelIds) {
      return false;
    }
    final l$addLabels = addLabels;
    final lOther$addLabels = other.addLabels;
    if (_$data.containsKey('addLabels') !=
        other._$data.containsKey('addLabels')) {
      return false;
    }
    if (l$addLabels != null && lOther$addLabels != null) {
      if (l$addLabels.length != lOther$addLabels.length) {
        return false;
      }
      for (int i = 0; i < l$addLabels.length; i++) {
        final l$addLabels$entry = l$addLabels[i];
        final lOther$addLabels$entry = lOther$addLabels[i];
        if (l$addLabels$entry != lOther$addLabels$entry) {
          return false;
        }
      }
    } else if (l$addLabels != lOther$addLabels) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$stateEvent = stateEvent;
    final lOther$stateEvent = other.stateEvent;
    if (_$data.containsKey('stateEvent') !=
        other._$data.containsKey('stateEvent')) {
      return false;
    }
    if (l$stateEvent != lOther$stateEvent) {
      return false;
    }
    final l$removeLabels = removeLabels;
    final lOther$removeLabels = other.removeLabels;
    if (_$data.containsKey('removeLabels') !=
        other._$data.containsKey('removeLabels')) {
      return false;
    }
    if (l$removeLabels != null && lOther$removeLabels != null) {
      if (l$removeLabels.length != lOther$removeLabels.length) {
        return false;
      }
      for (int i = 0; i < l$removeLabels.length; i++) {
        final l$removeLabels$entry = l$removeLabels[i];
        final lOther$removeLabels$entry = lOther$removeLabels[i];
        if (l$removeLabels$entry != lOther$removeLabels$entry) {
          return false;
        }
      }
    } else if (l$removeLabels != lOther$removeLabels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$title = title;
    final l$description = description;
    final l$confidential = confidential;
    final l$startDateFixed = startDateFixed;
    final l$dueDateFixed = dueDateFixed;
    final l$startDateIsFixed = startDateIsFixed;
    final l$dueDateIsFixed = dueDateIsFixed;
    final l$addLabelIds = addLabelIds;
    final l$removeLabelIds = removeLabelIds;
    final l$addLabels = addLabels;
    final l$color = color;
    final l$stateEvent = stateEvent;
    final l$removeLabels = removeLabels;
    return Object.hashAll([
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('startDateFixed') ? l$startDateFixed : const {},
      _$data.containsKey('dueDateFixed') ? l$dueDateFixed : const {},
      _$data.containsKey('startDateIsFixed') ? l$startDateIsFixed : const {},
      _$data.containsKey('dueDateIsFixed') ? l$dueDateIsFixed : const {},
      _$data.containsKey('addLabelIds')
          ? l$addLabelIds == null
              ? null
              : Object.hashAll(l$addLabelIds.map((v) => v))
          : const {},
      _$data.containsKey('removeLabelIds')
          ? l$removeLabelIds == null
              ? null
              : Object.hashAll(l$removeLabelIds.map((v) => v))
          : const {},
      _$data.containsKey('addLabels')
          ? l$addLabels == null
              ? null
              : Object.hashAll(l$addLabels.map((v) => v))
          : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('stateEvent') ? l$stateEvent : const {},
      _$data.containsKey('removeLabels')
          ? l$removeLabels == null
              ? null
              : Object.hashAll(l$removeLabels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEpicInput<TRes> {
  factory CopyWith$Input$UpdateEpicInput(
    Input$UpdateEpicInput instance,
    TRes Function(Input$UpdateEpicInput) then,
  ) = _CopyWithImpl$Input$UpdateEpicInput;

  factory CopyWith$Input$UpdateEpicInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEpicInput;

  TRes call({
    String? iid,
    String? clientMutationId,
    String? groupPath,
    String? title,
    String? description,
    bool? confidential,
    String? startDateFixed,
    String? dueDateFixed,
    bool? startDateIsFixed,
    bool? dueDateIsFixed,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? addLabels,
    String? color,
    Enum$EpicStateEvent? stateEvent,
    List<String>? removeLabels,
  });
}

class _CopyWithImpl$Input$UpdateEpicInput<TRes>
    implements CopyWith$Input$UpdateEpicInput<TRes> {
  _CopyWithImpl$Input$UpdateEpicInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEpicInput _instance;

  final TRes Function(Input$UpdateEpicInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? confidential = _undefined,
    Object? startDateFixed = _undefined,
    Object? dueDateFixed = _undefined,
    Object? startDateIsFixed = _undefined,
    Object? dueDateIsFixed = _undefined,
    Object? addLabelIds = _undefined,
    Object? removeLabelIds = _undefined,
    Object? addLabels = _undefined,
    Object? color = _undefined,
    Object? stateEvent = _undefined,
    Object? removeLabels = _undefined,
  }) =>
      _then(Input$UpdateEpicInput._({
        ..._instance._$data,
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (startDateFixed != _undefined)
          'startDateFixed': (startDateFixed as String?),
        if (dueDateFixed != _undefined)
          'dueDateFixed': (dueDateFixed as String?),
        if (startDateIsFixed != _undefined)
          'startDateIsFixed': (startDateIsFixed as bool?),
        if (dueDateIsFixed != _undefined)
          'dueDateIsFixed': (dueDateIsFixed as bool?),
        if (addLabelIds != _undefined)
          'addLabelIds': (addLabelIds as List<String>?),
        if (removeLabelIds != _undefined)
          'removeLabelIds': (removeLabelIds as List<String>?),
        if (addLabels != _undefined) 'addLabels': (addLabels as List<String>?),
        if (color != _undefined) 'color': (color as String?),
        if (stateEvent != _undefined)
          'stateEvent': (stateEvent as Enum$EpicStateEvent?),
        if (removeLabels != _undefined)
          'removeLabels': (removeLabels as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEpicInput<TRes>
    implements CopyWith$Input$UpdateEpicInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEpicInput(this._res);

  TRes _res;

  call({
    String? iid,
    String? clientMutationId,
    String? groupPath,
    String? title,
    String? description,
    bool? confidential,
    String? startDateFixed,
    String? dueDateFixed,
    bool? startDateIsFixed,
    bool? dueDateIsFixed,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? addLabels,
    String? color,
    Enum$EpicStateEvent? stateEvent,
    List<String>? removeLabels,
  }) =>
      _res;
}

class Input$UpdateImageDiffNoteInput {
  factory Input$UpdateImageDiffNoteInput({
    required String id,
    String? clientMutationId,
    String? body,
    Input$UpdateDiffImagePositionInput? position,
  }) =>
      Input$UpdateImageDiffNoteInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (body != null) r'body': body,
        if (position != null) r'position': position,
      });

  Input$UpdateImageDiffNoteInput._(this._$data);

  factory Input$UpdateImageDiffNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('position')) {
      final l$position = data['position'];
      result$data['position'] = l$position == null
          ? null
          : Input$UpdateDiffImagePositionInput.fromJson(
              (l$position as Map<String, dynamic>));
    }
    return Input$UpdateImageDiffNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get body => (_$data['body'] as String?);
  Input$UpdateDiffImagePositionInput? get position =>
      (_$data['position'] as Input$UpdateDiffImagePositionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('position')) {
      final l$position = position;
      result$data['position'] = l$position?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UpdateImageDiffNoteInput<Input$UpdateImageDiffNoteInput>
      get copyWith => CopyWith$Input$UpdateImageDiffNoteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateImageDiffNoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (_$data.containsKey('position') !=
        other._$data.containsKey('position')) {
      return false;
    }
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    final l$body = body;
    final l$position = position;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('position') ? l$position : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateImageDiffNoteInput<TRes> {
  factory CopyWith$Input$UpdateImageDiffNoteInput(
    Input$UpdateImageDiffNoteInput instance,
    TRes Function(Input$UpdateImageDiffNoteInput) then,
  ) = _CopyWithImpl$Input$UpdateImageDiffNoteInput;

  factory CopyWith$Input$UpdateImageDiffNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateImageDiffNoteInput;

  TRes call({
    String? id,
    String? clientMutationId,
    String? body,
    Input$UpdateDiffImagePositionInput? position,
  });
  CopyWith$Input$UpdateDiffImagePositionInput<TRes> get position;
}

class _CopyWithImpl$Input$UpdateImageDiffNoteInput<TRes>
    implements CopyWith$Input$UpdateImageDiffNoteInput<TRes> {
  _CopyWithImpl$Input$UpdateImageDiffNoteInput(
    this._instance,
    this._then,
  );

  final Input$UpdateImageDiffNoteInput _instance;

  final TRes Function(Input$UpdateImageDiffNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
    Object? body = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$UpdateImageDiffNoteInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (body != _undefined) 'body': (body as String?),
        if (position != _undefined)
          'position': (position as Input$UpdateDiffImagePositionInput?),
      }));
  CopyWith$Input$UpdateDiffImagePositionInput<TRes> get position {
    final local$position = _instance.position;
    return local$position == null
        ? CopyWith$Input$UpdateDiffImagePositionInput.stub(_then(_instance))
        : CopyWith$Input$UpdateDiffImagePositionInput(
            local$position, (e) => call(position: e));
  }
}

class _CopyWithStubImpl$Input$UpdateImageDiffNoteInput<TRes>
    implements CopyWith$Input$UpdateImageDiffNoteInput<TRes> {
  _CopyWithStubImpl$Input$UpdateImageDiffNoteInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
    String? body,
    Input$UpdateDiffImagePositionInput? position,
  }) =>
      _res;
  CopyWith$Input$UpdateDiffImagePositionInput<TRes> get position =>
      CopyWith$Input$UpdateDiffImagePositionInput.stub(_res);
}

class Input$UpdateIssueInput {
  factory Input$UpdateIssueInput({
    required String projectPath,
    required String iid,
    String? clientMutationId,
    String? description,
    String? dueDate,
    bool? confidential,
    bool? locked,
    Enum$IssueType? type,
    String? title,
    String? milestoneId,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? labelIds,
    Enum$IssueStateEvent? stateEvent,
    Enum$HealthStatus? healthStatus,
    int? weight,
    String? epicId,
  }) =>
      Input$UpdateIssueInput._({
        r'projectPath': projectPath,
        r'iid': iid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        if (dueDate != null) r'dueDate': dueDate,
        if (confidential != null) r'confidential': confidential,
        if (locked != null) r'locked': locked,
        if (type != null) r'type': type,
        if (title != null) r'title': title,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (addLabelIds != null) r'addLabelIds': addLabelIds,
        if (removeLabelIds != null) r'removeLabelIds': removeLabelIds,
        if (labelIds != null) r'labelIds': labelIds,
        if (stateEvent != null) r'stateEvent': stateEvent,
        if (healthStatus != null) r'healthStatus': healthStatus,
        if (weight != null) r'weight': weight,
        if (epicId != null) r'epicId': epicId,
      });

  Input$UpdateIssueInput._(this._$data);

  factory Input$UpdateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('locked')) {
      final l$locked = data['locked'];
      result$data['locked'] = (l$locked as bool?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          l$type == null ? null : fromJson$Enum$IssueType((l$type as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('addLabelIds')) {
      final l$addLabelIds = data['addLabelIds'];
      result$data['addLabelIds'] =
          (l$addLabelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeLabelIds')) {
      final l$removeLabelIds = data['removeLabelIds'];
      result$data['removeLabelIds'] = (l$removeLabelIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('stateEvent')) {
      final l$stateEvent = data['stateEvent'];
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : fromJson$Enum$IssueStateEvent((l$stateEvent as String));
    }
    if (data.containsKey('healthStatus')) {
      final l$healthStatus = data['healthStatus'];
      result$data['healthStatus'] = l$healthStatus == null
          ? null
          : fromJson$Enum$HealthStatus((l$healthStatus as String));
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as int?);
    }
    if (data.containsKey('epicId')) {
      final l$epicId = data['epicId'];
      result$data['epicId'] = (l$epicId as String?);
    }
    return Input$UpdateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectPath => (_$data['projectPath'] as String);
  String get iid => (_$data['iid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get dueDate => (_$data['dueDate'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  bool? get locked => (_$data['locked'] as bool?);
  Enum$IssueType? get type => (_$data['type'] as Enum$IssueType?);
  String? get title => (_$data['title'] as String?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get addLabelIds => (_$data['addLabelIds'] as List<String>?);
  List<String>? get removeLabelIds =>
      (_$data['removeLabelIds'] as List<String>?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  Enum$IssueStateEvent? get stateEvent =>
      (_$data['stateEvent'] as Enum$IssueStateEvent?);
  Enum$HealthStatus? get healthStatus =>
      (_$data['healthStatus'] as Enum$HealthStatus?);
  int? get weight => (_$data['weight'] as int?);
  String? get epicId => (_$data['epicId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('locked')) {
      final l$locked = locked;
      result$data['locked'] = l$locked;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$IssueType(l$type);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('addLabelIds')) {
      final l$addLabelIds = addLabelIds;
      result$data['addLabelIds'] = l$addLabelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeLabelIds')) {
      final l$removeLabelIds = removeLabelIds;
      result$data['removeLabelIds'] = l$removeLabelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('stateEvent')) {
      final l$stateEvent = stateEvent;
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : toJson$Enum$IssueStateEvent(l$stateEvent);
    }
    if (_$data.containsKey('healthStatus')) {
      final l$healthStatus = healthStatus;
      result$data['healthStatus'] = l$healthStatus == null
          ? null
          : toJson$Enum$HealthStatus(l$healthStatus);
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('epicId')) {
      final l$epicId = epicId;
      result$data['epicId'] = l$epicId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIssueInput<Input$UpdateIssueInput> get copyWith =>
      CopyWith$Input$UpdateIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$locked = locked;
    final lOther$locked = other.locked;
    if (_$data.containsKey('locked') != other._$data.containsKey('locked')) {
      return false;
    }
    if (l$locked != lOther$locked) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$addLabelIds = addLabelIds;
    final lOther$addLabelIds = other.addLabelIds;
    if (_$data.containsKey('addLabelIds') !=
        other._$data.containsKey('addLabelIds')) {
      return false;
    }
    if (l$addLabelIds != null && lOther$addLabelIds != null) {
      if (l$addLabelIds.length != lOther$addLabelIds.length) {
        return false;
      }
      for (int i = 0; i < l$addLabelIds.length; i++) {
        final l$addLabelIds$entry = l$addLabelIds[i];
        final lOther$addLabelIds$entry = lOther$addLabelIds[i];
        if (l$addLabelIds$entry != lOther$addLabelIds$entry) {
          return false;
        }
      }
    } else if (l$addLabelIds != lOther$addLabelIds) {
      return false;
    }
    final l$removeLabelIds = removeLabelIds;
    final lOther$removeLabelIds = other.removeLabelIds;
    if (_$data.containsKey('removeLabelIds') !=
        other._$data.containsKey('removeLabelIds')) {
      return false;
    }
    if (l$removeLabelIds != null && lOther$removeLabelIds != null) {
      if (l$removeLabelIds.length != lOther$removeLabelIds.length) {
        return false;
      }
      for (int i = 0; i < l$removeLabelIds.length; i++) {
        final l$removeLabelIds$entry = l$removeLabelIds[i];
        final lOther$removeLabelIds$entry = lOther$removeLabelIds[i];
        if (l$removeLabelIds$entry != lOther$removeLabelIds$entry) {
          return false;
        }
      }
    } else if (l$removeLabelIds != lOther$removeLabelIds) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$stateEvent = stateEvent;
    final lOther$stateEvent = other.stateEvent;
    if (_$data.containsKey('stateEvent') !=
        other._$data.containsKey('stateEvent')) {
      return false;
    }
    if (l$stateEvent != lOther$stateEvent) {
      return false;
    }
    final l$healthStatus = healthStatus;
    final lOther$healthStatus = other.healthStatus;
    if (_$data.containsKey('healthStatus') !=
        other._$data.containsKey('healthStatus')) {
      return false;
    }
    if (l$healthStatus != lOther$healthStatus) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$epicId = epicId;
    final lOther$epicId = other.epicId;
    if (_$data.containsKey('epicId') != other._$data.containsKey('epicId')) {
      return false;
    }
    if (l$epicId != lOther$epicId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectPath = projectPath;
    final l$iid = iid;
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$dueDate = dueDate;
    final l$confidential = confidential;
    final l$locked = locked;
    final l$type = type;
    final l$title = title;
    final l$milestoneId = milestoneId;
    final l$addLabelIds = addLabelIds;
    final l$removeLabelIds = removeLabelIds;
    final l$labelIds = labelIds;
    final l$stateEvent = stateEvent;
    final l$healthStatus = healthStatus;
    final l$weight = weight;
    final l$epicId = epicId;
    return Object.hashAll([
      l$projectPath,
      l$iid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('dueDate') ? l$dueDate : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('locked') ? l$locked : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('addLabelIds')
          ? l$addLabelIds == null
              ? null
              : Object.hashAll(l$addLabelIds.map((v) => v))
          : const {},
      _$data.containsKey('removeLabelIds')
          ? l$removeLabelIds == null
              ? null
              : Object.hashAll(l$removeLabelIds.map((v) => v))
          : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('stateEvent') ? l$stateEvent : const {},
      _$data.containsKey('healthStatus') ? l$healthStatus : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('epicId') ? l$epicId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueInput<TRes> {
  factory CopyWith$Input$UpdateIssueInput(
    Input$UpdateIssueInput instance,
    TRes Function(Input$UpdateIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueInput;

  factory CopyWith$Input$UpdateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueInput;

  TRes call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? description,
    String? dueDate,
    bool? confidential,
    bool? locked,
    Enum$IssueType? type,
    String? title,
    String? milestoneId,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? labelIds,
    Enum$IssueStateEvent? stateEvent,
    Enum$HealthStatus? healthStatus,
    int? weight,
    String? epicId,
  });
}

class _CopyWithImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueInput _instance;

  final TRes Function(Input$UpdateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? projectPath = _undefined,
    Object? iid = _undefined,
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? dueDate = _undefined,
    Object? confidential = _undefined,
    Object? locked = _undefined,
    Object? type = _undefined,
    Object? title = _undefined,
    Object? milestoneId = _undefined,
    Object? addLabelIds = _undefined,
    Object? removeLabelIds = _undefined,
    Object? labelIds = _undefined,
    Object? stateEvent = _undefined,
    Object? healthStatus = _undefined,
    Object? weight = _undefined,
    Object? epicId = _undefined,
  }) =>
      _then(Input$UpdateIssueInput._({
        ..._instance._$data,
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (locked != _undefined) 'locked': (locked as bool?),
        if (type != _undefined) 'type': (type as Enum$IssueType?),
        if (title != _undefined) 'title': (title as String?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (addLabelIds != _undefined)
          'addLabelIds': (addLabelIds as List<String>?),
        if (removeLabelIds != _undefined)
          'removeLabelIds': (removeLabelIds as List<String>?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (stateEvent != _undefined)
          'stateEvent': (stateEvent as Enum$IssueStateEvent?),
        if (healthStatus != _undefined)
          'healthStatus': (healthStatus as Enum$HealthStatus?),
        if (weight != _undefined) 'weight': (weight as int?),
        if (epicId != _undefined) 'epicId': (epicId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueInput(this._res);

  TRes _res;

  call({
    String? projectPath,
    String? iid,
    String? clientMutationId,
    String? description,
    String? dueDate,
    bool? confidential,
    bool? locked,
    Enum$IssueType? type,
    String? title,
    String? milestoneId,
    List<String>? addLabelIds,
    List<String>? removeLabelIds,
    List<String>? labelIds,
    Enum$IssueStateEvent? stateEvent,
    Enum$HealthStatus? healthStatus,
    int? weight,
    String? epicId,
  }) =>
      _res;
}

class Input$UpdateIterationInput {
  factory Input$UpdateIterationInput({
    String? clientMutationId,
    required String groupPath,
    required String id,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
  }) =>
      Input$UpdateIterationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'groupPath': groupPath,
        r'id': id,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (startDate != null) r'startDate': startDate,
        if (dueDate != null) r'dueDate': dueDate,
      });

  Input$UpdateIterationInput._(this._$data);

  factory Input$UpdateIterationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$groupPath = data['groupPath'];
    result$data['groupPath'] = (l$groupPath as String);
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    return Input$UpdateIterationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get groupPath => (_$data['groupPath'] as String);
  String get id => (_$data['id'] as String);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get startDate => (_$data['startDate'] as String?);
  String? get dueDate => (_$data['dueDate'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$groupPath = groupPath;
    result$data['groupPath'] = l$groupPath;
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIterationInput<Input$UpdateIterationInput>
      get copyWith => CopyWith$Input$UpdateIterationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIterationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$groupPath = groupPath;
    final l$id = id;
    final l$title = title;
    final l$description = description;
    final l$startDate = startDate;
    final l$dueDate = dueDate;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$groupPath,
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('dueDate') ? l$dueDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIterationInput<TRes> {
  factory CopyWith$Input$UpdateIterationInput(
    Input$UpdateIterationInput instance,
    TRes Function(Input$UpdateIterationInput) then,
  ) = _CopyWithImpl$Input$UpdateIterationInput;

  factory CopyWith$Input$UpdateIterationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIterationInput;

  TRes call({
    String? clientMutationId,
    String? groupPath,
    String? id,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
  });
}

class _CopyWithImpl$Input$UpdateIterationInput<TRes>
    implements CopyWith$Input$UpdateIterationInput<TRes> {
  _CopyWithImpl$Input$UpdateIterationInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIterationInput _instance;

  final TRes Function(Input$UpdateIterationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? groupPath = _undefined,
    Object? id = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? startDate = _undefined,
    Object? dueDate = _undefined,
  }) =>
      _then(Input$UpdateIterationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (groupPath != _undefined && groupPath != null)
          'groupPath': (groupPath as String),
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIterationInput<TRes>
    implements CopyWith$Input$UpdateIterationInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIterationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? groupPath,
    String? id,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
  }) =>
      _res;
}

class Input$UpdateNamespacePackageSettingsInput {
  factory Input$UpdateNamespacePackageSettingsInput({
    String? clientMutationId,
    required String namespacePath,
    bool? mavenDuplicatesAllowed,
    String? mavenDuplicateExceptionRegex,
    bool? genericDuplicatesAllowed,
    String? genericDuplicateExceptionRegex,
  }) =>
      Input$UpdateNamespacePackageSettingsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'namespacePath': namespacePath,
        if (mavenDuplicatesAllowed != null)
          r'mavenDuplicatesAllowed': mavenDuplicatesAllowed,
        if (mavenDuplicateExceptionRegex != null)
          r'mavenDuplicateExceptionRegex': mavenDuplicateExceptionRegex,
        if (genericDuplicatesAllowed != null)
          r'genericDuplicatesAllowed': genericDuplicatesAllowed,
        if (genericDuplicateExceptionRegex != null)
          r'genericDuplicateExceptionRegex': genericDuplicateExceptionRegex,
      });

  Input$UpdateNamespacePackageSettingsInput._(this._$data);

  factory Input$UpdateNamespacePackageSettingsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$namespacePath = data['namespacePath'];
    result$data['namespacePath'] = (l$namespacePath as String);
    if (data.containsKey('mavenDuplicatesAllowed')) {
      final l$mavenDuplicatesAllowed = data['mavenDuplicatesAllowed'];
      result$data['mavenDuplicatesAllowed'] =
          (l$mavenDuplicatesAllowed as bool?);
    }
    if (data.containsKey('mavenDuplicateExceptionRegex')) {
      final l$mavenDuplicateExceptionRegex =
          data['mavenDuplicateExceptionRegex'];
      result$data['mavenDuplicateExceptionRegex'] =
          (l$mavenDuplicateExceptionRegex as String?);
    }
    if (data.containsKey('genericDuplicatesAllowed')) {
      final l$genericDuplicatesAllowed = data['genericDuplicatesAllowed'];
      result$data['genericDuplicatesAllowed'] =
          (l$genericDuplicatesAllowed as bool?);
    }
    if (data.containsKey('genericDuplicateExceptionRegex')) {
      final l$genericDuplicateExceptionRegex =
          data['genericDuplicateExceptionRegex'];
      result$data['genericDuplicateExceptionRegex'] =
          (l$genericDuplicateExceptionRegex as String?);
    }
    return Input$UpdateNamespacePackageSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get namespacePath => (_$data['namespacePath'] as String);
  bool? get mavenDuplicatesAllowed =>
      (_$data['mavenDuplicatesAllowed'] as bool?);
  String? get mavenDuplicateExceptionRegex =>
      (_$data['mavenDuplicateExceptionRegex'] as String?);
  bool? get genericDuplicatesAllowed =>
      (_$data['genericDuplicatesAllowed'] as bool?);
  String? get genericDuplicateExceptionRegex =>
      (_$data['genericDuplicateExceptionRegex'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$namespacePath = namespacePath;
    result$data['namespacePath'] = l$namespacePath;
    if (_$data.containsKey('mavenDuplicatesAllowed')) {
      final l$mavenDuplicatesAllowed = mavenDuplicatesAllowed;
      result$data['mavenDuplicatesAllowed'] = l$mavenDuplicatesAllowed;
    }
    if (_$data.containsKey('mavenDuplicateExceptionRegex')) {
      final l$mavenDuplicateExceptionRegex = mavenDuplicateExceptionRegex;
      result$data['mavenDuplicateExceptionRegex'] =
          l$mavenDuplicateExceptionRegex;
    }
    if (_$data.containsKey('genericDuplicatesAllowed')) {
      final l$genericDuplicatesAllowed = genericDuplicatesAllowed;
      result$data['genericDuplicatesAllowed'] = l$genericDuplicatesAllowed;
    }
    if (_$data.containsKey('genericDuplicateExceptionRegex')) {
      final l$genericDuplicateExceptionRegex = genericDuplicateExceptionRegex;
      result$data['genericDuplicateExceptionRegex'] =
          l$genericDuplicateExceptionRegex;
    }
    return result$data;
  }

  CopyWith$Input$UpdateNamespacePackageSettingsInput<
          Input$UpdateNamespacePackageSettingsInput>
      get copyWith => CopyWith$Input$UpdateNamespacePackageSettingsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateNamespacePackageSettingsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$namespacePath = namespacePath;
    final lOther$namespacePath = other.namespacePath;
    if (l$namespacePath != lOther$namespacePath) {
      return false;
    }
    final l$mavenDuplicatesAllowed = mavenDuplicatesAllowed;
    final lOther$mavenDuplicatesAllowed = other.mavenDuplicatesAllowed;
    if (_$data.containsKey('mavenDuplicatesAllowed') !=
        other._$data.containsKey('mavenDuplicatesAllowed')) {
      return false;
    }
    if (l$mavenDuplicatesAllowed != lOther$mavenDuplicatesAllowed) {
      return false;
    }
    final l$mavenDuplicateExceptionRegex = mavenDuplicateExceptionRegex;
    final lOther$mavenDuplicateExceptionRegex =
        other.mavenDuplicateExceptionRegex;
    if (_$data.containsKey('mavenDuplicateExceptionRegex') !=
        other._$data.containsKey('mavenDuplicateExceptionRegex')) {
      return false;
    }
    if (l$mavenDuplicateExceptionRegex != lOther$mavenDuplicateExceptionRegex) {
      return false;
    }
    final l$genericDuplicatesAllowed = genericDuplicatesAllowed;
    final lOther$genericDuplicatesAllowed = other.genericDuplicatesAllowed;
    if (_$data.containsKey('genericDuplicatesAllowed') !=
        other._$data.containsKey('genericDuplicatesAllowed')) {
      return false;
    }
    if (l$genericDuplicatesAllowed != lOther$genericDuplicatesAllowed) {
      return false;
    }
    final l$genericDuplicateExceptionRegex = genericDuplicateExceptionRegex;
    final lOther$genericDuplicateExceptionRegex =
        other.genericDuplicateExceptionRegex;
    if (_$data.containsKey('genericDuplicateExceptionRegex') !=
        other._$data.containsKey('genericDuplicateExceptionRegex')) {
      return false;
    }
    if (l$genericDuplicateExceptionRegex !=
        lOther$genericDuplicateExceptionRegex) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$namespacePath = namespacePath;
    final l$mavenDuplicatesAllowed = mavenDuplicatesAllowed;
    final l$mavenDuplicateExceptionRegex = mavenDuplicateExceptionRegex;
    final l$genericDuplicatesAllowed = genericDuplicatesAllowed;
    final l$genericDuplicateExceptionRegex = genericDuplicateExceptionRegex;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$namespacePath,
      _$data.containsKey('mavenDuplicatesAllowed')
          ? l$mavenDuplicatesAllowed
          : const {},
      _$data.containsKey('mavenDuplicateExceptionRegex')
          ? l$mavenDuplicateExceptionRegex
          : const {},
      _$data.containsKey('genericDuplicatesAllowed')
          ? l$genericDuplicatesAllowed
          : const {},
      _$data.containsKey('genericDuplicateExceptionRegex')
          ? l$genericDuplicateExceptionRegex
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateNamespacePackageSettingsInput<TRes> {
  factory CopyWith$Input$UpdateNamespacePackageSettingsInput(
    Input$UpdateNamespacePackageSettingsInput instance,
    TRes Function(Input$UpdateNamespacePackageSettingsInput) then,
  ) = _CopyWithImpl$Input$UpdateNamespacePackageSettingsInput;

  factory CopyWith$Input$UpdateNamespacePackageSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateNamespacePackageSettingsInput;

  TRes call({
    String? clientMutationId,
    String? namespacePath,
    bool? mavenDuplicatesAllowed,
    String? mavenDuplicateExceptionRegex,
    bool? genericDuplicatesAllowed,
    String? genericDuplicateExceptionRegex,
  });
}

class _CopyWithImpl$Input$UpdateNamespacePackageSettingsInput<TRes>
    implements CopyWith$Input$UpdateNamespacePackageSettingsInput<TRes> {
  _CopyWithImpl$Input$UpdateNamespacePackageSettingsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateNamespacePackageSettingsInput _instance;

  final TRes Function(Input$UpdateNamespacePackageSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? namespacePath = _undefined,
    Object? mavenDuplicatesAllowed = _undefined,
    Object? mavenDuplicateExceptionRegex = _undefined,
    Object? genericDuplicatesAllowed = _undefined,
    Object? genericDuplicateExceptionRegex = _undefined,
  }) =>
      _then(Input$UpdateNamespacePackageSettingsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (namespacePath != _undefined && namespacePath != null)
          'namespacePath': (namespacePath as String),
        if (mavenDuplicatesAllowed != _undefined)
          'mavenDuplicatesAllowed': (mavenDuplicatesAllowed as bool?),
        if (mavenDuplicateExceptionRegex != _undefined)
          'mavenDuplicateExceptionRegex':
              (mavenDuplicateExceptionRegex as String?),
        if (genericDuplicatesAllowed != _undefined)
          'genericDuplicatesAllowed': (genericDuplicatesAllowed as bool?),
        if (genericDuplicateExceptionRegex != _undefined)
          'genericDuplicateExceptionRegex':
              (genericDuplicateExceptionRegex as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateNamespacePackageSettingsInput<TRes>
    implements CopyWith$Input$UpdateNamespacePackageSettingsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateNamespacePackageSettingsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? namespacePath,
    bool? mavenDuplicatesAllowed,
    String? mavenDuplicateExceptionRegex,
    bool? genericDuplicatesAllowed,
    String? genericDuplicateExceptionRegex,
  }) =>
      _res;
}

class Input$UpdateNoteInput {
  factory Input$UpdateNoteInput({
    required String id,
    String? clientMutationId,
    String? body,
  }) =>
      Input$UpdateNoteInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (body != null) r'body': body,
      });

  Input$UpdateNoteInput._(this._$data);

  factory Input$UpdateNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$UpdateNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get body => (_$data['body'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$UpdateNoteInput<Input$UpdateNoteInput> get copyWith =>
      CopyWith$Input$UpdateNoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateNoteInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    final l$body = body;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateNoteInput<TRes> {
  factory CopyWith$Input$UpdateNoteInput(
    Input$UpdateNoteInput instance,
    TRes Function(Input$UpdateNoteInput) then,
  ) = _CopyWithImpl$Input$UpdateNoteInput;

  factory CopyWith$Input$UpdateNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateNoteInput;

  TRes call({
    String? id,
    String? clientMutationId,
    String? body,
  });
}

class _CopyWithImpl$Input$UpdateNoteInput<TRes>
    implements CopyWith$Input$UpdateNoteInput<TRes> {
  _CopyWithImpl$Input$UpdateNoteInput(
    this._instance,
    this._then,
  );

  final Input$UpdateNoteInput _instance;

  final TRes Function(Input$UpdateNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$UpdateNoteInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateNoteInput<TRes>
    implements CopyWith$Input$UpdateNoteInput<TRes> {
  _CopyWithStubImpl$Input$UpdateNoteInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
    String? body,
  }) =>
      _res;
}

class Input$UpdatePackagesCleanupPolicyInput {
  factory Input$UpdatePackagesCleanupPolicyInput({
    String? clientMutationId,
    required String projectPath,
    Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum?
        keepNDuplicatedPackageFiles,
  }) =>
      Input$UpdatePackagesCleanupPolicyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectPath': projectPath,
        if (keepNDuplicatedPackageFiles != null)
          r'keepNDuplicatedPackageFiles': keepNDuplicatedPackageFiles,
      });

  Input$UpdatePackagesCleanupPolicyInput._(this._$data);

  factory Input$UpdatePackagesCleanupPolicyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('keepNDuplicatedPackageFiles')) {
      final l$keepNDuplicatedPackageFiles = data['keepNDuplicatedPackageFiles'];
      result$data['keepNDuplicatedPackageFiles'] =
          l$keepNDuplicatedPackageFiles == null
              ? null
              : fromJson$Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum(
                  (l$keepNDuplicatedPackageFiles as String));
    }
    return Input$UpdatePackagesCleanupPolicyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum?
      get keepNDuplicatedPackageFiles => (_$data['keepNDuplicatedPackageFiles']
          as Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('keepNDuplicatedPackageFiles')) {
      final l$keepNDuplicatedPackageFiles = keepNDuplicatedPackageFiles;
      result$data['keepNDuplicatedPackageFiles'] =
          l$keepNDuplicatedPackageFiles == null
              ? null
              : toJson$Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum(
                  l$keepNDuplicatedPackageFiles);
    }
    return result$data;
  }

  CopyWith$Input$UpdatePackagesCleanupPolicyInput<
          Input$UpdatePackagesCleanupPolicyInput>
      get copyWith => CopyWith$Input$UpdatePackagesCleanupPolicyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePackagesCleanupPolicyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$keepNDuplicatedPackageFiles = keepNDuplicatedPackageFiles;
    final lOther$keepNDuplicatedPackageFiles =
        other.keepNDuplicatedPackageFiles;
    if (_$data.containsKey('keepNDuplicatedPackageFiles') !=
        other._$data.containsKey('keepNDuplicatedPackageFiles')) {
      return false;
    }
    if (l$keepNDuplicatedPackageFiles != lOther$keepNDuplicatedPackageFiles) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$keepNDuplicatedPackageFiles = keepNDuplicatedPackageFiles;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectPath,
      _$data.containsKey('keepNDuplicatedPackageFiles')
          ? l$keepNDuplicatedPackageFiles
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePackagesCleanupPolicyInput<TRes> {
  factory CopyWith$Input$UpdatePackagesCleanupPolicyInput(
    Input$UpdatePackagesCleanupPolicyInput instance,
    TRes Function(Input$UpdatePackagesCleanupPolicyInput) then,
  ) = _CopyWithImpl$Input$UpdatePackagesCleanupPolicyInput;

  factory CopyWith$Input$UpdatePackagesCleanupPolicyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePackagesCleanupPolicyInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum?
        keepNDuplicatedPackageFiles,
  });
}

class _CopyWithImpl$Input$UpdatePackagesCleanupPolicyInput<TRes>
    implements CopyWith$Input$UpdatePackagesCleanupPolicyInput<TRes> {
  _CopyWithImpl$Input$UpdatePackagesCleanupPolicyInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePackagesCleanupPolicyInput _instance;

  final TRes Function(Input$UpdatePackagesCleanupPolicyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? keepNDuplicatedPackageFiles = _undefined,
  }) =>
      _then(Input$UpdatePackagesCleanupPolicyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (keepNDuplicatedPackageFiles != _undefined)
          'keepNDuplicatedPackageFiles': (keepNDuplicatedPackageFiles
              as Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePackagesCleanupPolicyInput<TRes>
    implements CopyWith$Input$UpdatePackagesCleanupPolicyInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePackagesCleanupPolicyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum?
        keepNDuplicatedPackageFiles,
  }) =>
      _res;
}

class Input$UpdateRequirementInput {
  factory Input$UpdateRequirementInput({
    String? title,
    String? description,
    required String projectPath,
    String? clientMutationId,
    Enum$RequirementState? state,
    required String iid,
    Enum$TestReportState? lastTestReportState,
  }) =>
      Input$UpdateRequirementInput._({
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        r'projectPath': projectPath,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (state != null) r'state': state,
        r'iid': iid,
        if (lastTestReportState != null)
          r'lastTestReportState': lastTestReportState,
      });

  Input$UpdateRequirementInput._(this._$data);

  factory Input$UpdateRequirementInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$RequirementState((l$state as String));
    }
    final l$iid = data['iid'];
    result$data['iid'] = (l$iid as String);
    if (data.containsKey('lastTestReportState')) {
      final l$lastTestReportState = data['lastTestReportState'];
      result$data['lastTestReportState'] = l$lastTestReportState == null
          ? null
          : fromJson$Enum$TestReportState((l$lastTestReportState as String));
    }
    return Input$UpdateRequirementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  String get projectPath => (_$data['projectPath'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$RequirementState? get state =>
      (_$data['state'] as Enum$RequirementState?);
  String get iid => (_$data['iid'] as String);
  Enum$TestReportState? get lastTestReportState =>
      (_$data['lastTestReportState'] as Enum$TestReportState?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$RequirementState(l$state);
    }
    final l$iid = iid;
    result$data['iid'] = l$iid;
    if (_$data.containsKey('lastTestReportState')) {
      final l$lastTestReportState = lastTestReportState;
      result$data['lastTestReportState'] = l$lastTestReportState == null
          ? null
          : toJson$Enum$TestReportState(l$lastTestReportState);
    }
    return result$data;
  }

  CopyWith$Input$UpdateRequirementInput<Input$UpdateRequirementInput>
      get copyWith => CopyWith$Input$UpdateRequirementInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRequirementInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$iid = iid;
    final lOther$iid = other.iid;
    if (l$iid != lOther$iid) {
      return false;
    }
    final l$lastTestReportState = lastTestReportState;
    final lOther$lastTestReportState = other.lastTestReportState;
    if (_$data.containsKey('lastTestReportState') !=
        other._$data.containsKey('lastTestReportState')) {
      return false;
    }
    if (l$lastTestReportState != lOther$lastTestReportState) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$description = description;
    final l$projectPath = projectPath;
    final l$clientMutationId = clientMutationId;
    final l$state = state;
    final l$iid = iid;
    final l$lastTestReportState = lastTestReportState;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      l$projectPath,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('state') ? l$state : const {},
      l$iid,
      _$data.containsKey('lastTestReportState')
          ? l$lastTestReportState
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRequirementInput<TRes> {
  factory CopyWith$Input$UpdateRequirementInput(
    Input$UpdateRequirementInput instance,
    TRes Function(Input$UpdateRequirementInput) then,
  ) = _CopyWithImpl$Input$UpdateRequirementInput;

  factory CopyWith$Input$UpdateRequirementInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRequirementInput;

  TRes call({
    String? title,
    String? description,
    String? projectPath,
    String? clientMutationId,
    Enum$RequirementState? state,
    String? iid,
    Enum$TestReportState? lastTestReportState,
  });
}

class _CopyWithImpl$Input$UpdateRequirementInput<TRes>
    implements CopyWith$Input$UpdateRequirementInput<TRes> {
  _CopyWithImpl$Input$UpdateRequirementInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRequirementInput _instance;

  final TRes Function(Input$UpdateRequirementInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? description = _undefined,
    Object? projectPath = _undefined,
    Object? clientMutationId = _undefined,
    Object? state = _undefined,
    Object? iid = _undefined,
    Object? lastTestReportState = _undefined,
  }) =>
      _then(Input$UpdateRequirementInput._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (state != _undefined) 'state': (state as Enum$RequirementState?),
        if (iid != _undefined && iid != null) 'iid': (iid as String),
        if (lastTestReportState != _undefined)
          'lastTestReportState': (lastTestReportState as Enum$TestReportState?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRequirementInput<TRes>
    implements CopyWith$Input$UpdateRequirementInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRequirementInput(this._res);

  TRes _res;

  call({
    String? title,
    String? description,
    String? projectPath,
    String? clientMutationId,
    Enum$RequirementState? state,
    String? iid,
    Enum$TestReportState? lastTestReportState,
  }) =>
      _res;
}

class Input$UpdateSnippetInput {
  factory Input$UpdateSnippetInput({
    String? clientMutationId,
    required String id,
    String? title,
    String? description,
    Enum$VisibilityLevelsEnum? visibilityLevel,
    List<Input$SnippetBlobActionInputType>? blobActions,
  }) =>
      Input$UpdateSnippetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (visibilityLevel != null) r'visibilityLevel': visibilityLevel,
        if (blobActions != null) r'blobActions': blobActions,
      });

  Input$UpdateSnippetInput._(this._$data);

  factory Input$UpdateSnippetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('visibilityLevel')) {
      final l$visibilityLevel = data['visibilityLevel'];
      result$data['visibilityLevel'] = l$visibilityLevel == null
          ? null
          : fromJson$Enum$VisibilityLevelsEnum((l$visibilityLevel as String));
    }
    if (data.containsKey('blobActions')) {
      final l$blobActions = data['blobActions'];
      result$data['blobActions'] = (l$blobActions as List<dynamic>?)
          ?.map((e) => Input$SnippetBlobActionInputType.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$UpdateSnippetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  Enum$VisibilityLevelsEnum? get visibilityLevel =>
      (_$data['visibilityLevel'] as Enum$VisibilityLevelsEnum?);
  List<Input$SnippetBlobActionInputType>? get blobActions =>
      (_$data['blobActions'] as List<Input$SnippetBlobActionInputType>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('visibilityLevel')) {
      final l$visibilityLevel = visibilityLevel;
      result$data['visibilityLevel'] = l$visibilityLevel == null
          ? null
          : toJson$Enum$VisibilityLevelsEnum(l$visibilityLevel);
    }
    if (_$data.containsKey('blobActions')) {
      final l$blobActions = blobActions;
      result$data['blobActions'] =
          l$blobActions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateSnippetInput<Input$UpdateSnippetInput> get copyWith =>
      CopyWith$Input$UpdateSnippetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateSnippetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$visibilityLevel = visibilityLevel;
    final lOther$visibilityLevel = other.visibilityLevel;
    if (_$data.containsKey('visibilityLevel') !=
        other._$data.containsKey('visibilityLevel')) {
      return false;
    }
    if (l$visibilityLevel != lOther$visibilityLevel) {
      return false;
    }
    final l$blobActions = blobActions;
    final lOther$blobActions = other.blobActions;
    if (_$data.containsKey('blobActions') !=
        other._$data.containsKey('blobActions')) {
      return false;
    }
    if (l$blobActions != null && lOther$blobActions != null) {
      if (l$blobActions.length != lOther$blobActions.length) {
        return false;
      }
      for (int i = 0; i < l$blobActions.length; i++) {
        final l$blobActions$entry = l$blobActions[i];
        final lOther$blobActions$entry = lOther$blobActions[i];
        if (l$blobActions$entry != lOther$blobActions$entry) {
          return false;
        }
      }
    } else if (l$blobActions != lOther$blobActions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$title = title;
    final l$description = description;
    final l$visibilityLevel = visibilityLevel;
    final l$blobActions = blobActions;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('visibilityLevel') ? l$visibilityLevel : const {},
      _$data.containsKey('blobActions')
          ? l$blobActions == null
              ? null
              : Object.hashAll(l$blobActions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateSnippetInput<TRes> {
  factory CopyWith$Input$UpdateSnippetInput(
    Input$UpdateSnippetInput instance,
    TRes Function(Input$UpdateSnippetInput) then,
  ) = _CopyWithImpl$Input$UpdateSnippetInput;

  factory CopyWith$Input$UpdateSnippetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSnippetInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? title,
    String? description,
    Enum$VisibilityLevelsEnum? visibilityLevel,
    List<Input$SnippetBlobActionInputType>? blobActions,
  });
  TRes blobActions(
      Iterable<Input$SnippetBlobActionInputType>? Function(
              Iterable<
                  CopyWith$Input$SnippetBlobActionInputType<
                      Input$SnippetBlobActionInputType>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateSnippetInput<TRes>
    implements CopyWith$Input$UpdateSnippetInput<TRes> {
  _CopyWithImpl$Input$UpdateSnippetInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSnippetInput _instance;

  final TRes Function(Input$UpdateSnippetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? visibilityLevel = _undefined,
    Object? blobActions = _undefined,
  }) =>
      _then(Input$UpdateSnippetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (visibilityLevel != _undefined)
          'visibilityLevel': (visibilityLevel as Enum$VisibilityLevelsEnum?),
        if (blobActions != _undefined)
          'blobActions':
              (blobActions as List<Input$SnippetBlobActionInputType>?),
      }));
  TRes blobActions(
          Iterable<Input$SnippetBlobActionInputType>? Function(
                  Iterable<
                      CopyWith$Input$SnippetBlobActionInputType<
                          Input$SnippetBlobActionInputType>>?)
              _fn) =>
      call(
          blobActions: _fn(_instance.blobActions
              ?.map((e) => CopyWith$Input$SnippetBlobActionInputType(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateSnippetInput<TRes>
    implements CopyWith$Input$UpdateSnippetInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSnippetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? title,
    String? description,
    Enum$VisibilityLevelsEnum? visibilityLevel,
    List<Input$SnippetBlobActionInputType>? blobActions,
  }) =>
      _res;
  blobActions(_fn) => _res;
}

class Input$UploadDeleteInput {
  factory Input$UploadDeleteInput({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    required String secret,
    required String filename,
  }) =>
      Input$UploadDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (projectPath != null) r'projectPath': projectPath,
        if (groupPath != null) r'groupPath': groupPath,
        r'secret': secret,
        r'filename': filename,
      });

  Input$UploadDeleteInput._(this._$data);

  factory Input$UploadDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('projectPath')) {
      final l$projectPath = data['projectPath'];
      result$data['projectPath'] = (l$projectPath as String?);
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    final l$secret = data['secret'];
    result$data['secret'] = (l$secret as String);
    final l$filename = data['filename'];
    result$data['filename'] = (l$filename as String);
    return Input$UploadDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get projectPath => (_$data['projectPath'] as String?);
  String? get groupPath => (_$data['groupPath'] as String?);
  String get secret => (_$data['secret'] as String);
  String get filename => (_$data['filename'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('projectPath')) {
      final l$projectPath = projectPath;
      result$data['projectPath'] = l$projectPath;
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    final l$secret = secret;
    result$data['secret'] = l$secret;
    final l$filename = filename;
    result$data['filename'] = l$filename;
    return result$data;
  }

  CopyWith$Input$UploadDeleteInput<Input$UploadDeleteInput> get copyWith =>
      CopyWith$Input$UploadDeleteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UploadDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (_$data.containsKey('projectPath') !=
        other._$data.containsKey('projectPath')) {
      return false;
    }
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$secret = secret;
    final lOther$secret = other.secret;
    if (l$secret != lOther$secret) {
      return false;
    }
    final l$filename = filename;
    final lOther$filename = other.filename;
    if (l$filename != lOther$filename) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$groupPath = groupPath;
    final l$secret = secret;
    final l$filename = filename;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('projectPath') ? l$projectPath : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
      l$secret,
      l$filename,
    ]);
  }
}

abstract class CopyWith$Input$UploadDeleteInput<TRes> {
  factory CopyWith$Input$UploadDeleteInput(
    Input$UploadDeleteInput instance,
    TRes Function(Input$UploadDeleteInput) then,
  ) = _CopyWithImpl$Input$UploadDeleteInput;

  factory CopyWith$Input$UploadDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UploadDeleteInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? secret,
    String? filename,
  });
}

class _CopyWithImpl$Input$UploadDeleteInput<TRes>
    implements CopyWith$Input$UploadDeleteInput<TRes> {
  _CopyWithImpl$Input$UploadDeleteInput(
    this._instance,
    this._then,
  );

  final Input$UploadDeleteInput _instance;

  final TRes Function(Input$UploadDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? groupPath = _undefined,
    Object? secret = _undefined,
    Object? filename = _undefined,
  }) =>
      _then(Input$UploadDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined) 'projectPath': (projectPath as String?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
        if (secret != _undefined && secret != null)
          'secret': (secret as String),
        if (filename != _undefined && filename != null)
          'filename': (filename as String),
      }));
}

class _CopyWithStubImpl$Input$UploadDeleteInput<TRes>
    implements CopyWith$Input$UploadDeleteInput<TRes> {
  _CopyWithStubImpl$Input$UploadDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? secret,
    String? filename,
  }) =>
      _res;
}

class Input$UserCalloutCreateInput {
  factory Input$UserCalloutCreateInput({
    String? clientMutationId,
    required String featureName,
  }) =>
      Input$UserCalloutCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'featureName': featureName,
      });

  Input$UserCalloutCreateInput._(this._$data);

  factory Input$UserCalloutCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$featureName = data['featureName'];
    result$data['featureName'] = (l$featureName as String);
    return Input$UserCalloutCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get featureName => (_$data['featureName'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$featureName = featureName;
    result$data['featureName'] = l$featureName;
    return result$data;
  }

  CopyWith$Input$UserCalloutCreateInput<Input$UserCalloutCreateInput>
      get copyWith => CopyWith$Input$UserCalloutCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCalloutCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$featureName = featureName;
    final lOther$featureName = other.featureName;
    if (l$featureName != lOther$featureName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$featureName = featureName;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$featureName,
    ]);
  }
}

abstract class CopyWith$Input$UserCalloutCreateInput<TRes> {
  factory CopyWith$Input$UserCalloutCreateInput(
    Input$UserCalloutCreateInput instance,
    TRes Function(Input$UserCalloutCreateInput) then,
  ) = _CopyWithImpl$Input$UserCalloutCreateInput;

  factory CopyWith$Input$UserCalloutCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCalloutCreateInput;

  TRes call({
    String? clientMutationId,
    String? featureName,
  });
}

class _CopyWithImpl$Input$UserCalloutCreateInput<TRes>
    implements CopyWith$Input$UserCalloutCreateInput<TRes> {
  _CopyWithImpl$Input$UserCalloutCreateInput(
    this._instance,
    this._then,
  );

  final Input$UserCalloutCreateInput _instance;

  final TRes Function(Input$UserCalloutCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? featureName = _undefined,
  }) =>
      _then(Input$UserCalloutCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (featureName != _undefined && featureName != null)
          'featureName': (featureName as String),
      }));
}

class _CopyWithStubImpl$Input$UserCalloutCreateInput<TRes>
    implements CopyWith$Input$UserCalloutCreateInput<TRes> {
  _CopyWithStubImpl$Input$UserCalloutCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? featureName,
  }) =>
      _res;
}

class Input$UserPreferencesUpdateInput {
  factory Input$UserPreferencesUpdateInput({
    String? clientMutationId,
    Enum$IssueSort? issuesSort,
  }) =>
      Input$UserPreferencesUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (issuesSort != null) r'issuesSort': issuesSort,
      });

  Input$UserPreferencesUpdateInput._(this._$data);

  factory Input$UserPreferencesUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('issuesSort')) {
      final l$issuesSort = data['issuesSort'];
      result$data['issuesSort'] = l$issuesSort == null
          ? null
          : fromJson$Enum$IssueSort((l$issuesSort as String));
    }
    return Input$UserPreferencesUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$IssueSort? get issuesSort => (_$data['issuesSort'] as Enum$IssueSort?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('issuesSort')) {
      final l$issuesSort = issuesSort;
      result$data['issuesSort'] =
          l$issuesSort == null ? null : toJson$Enum$IssueSort(l$issuesSort);
    }
    return result$data;
  }

  CopyWith$Input$UserPreferencesUpdateInput<Input$UserPreferencesUpdateInput>
      get copyWith => CopyWith$Input$UserPreferencesUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPreferencesUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issuesSort = issuesSort;
    final lOther$issuesSort = other.issuesSort;
    if (_$data.containsKey('issuesSort') !=
        other._$data.containsKey('issuesSort')) {
      return false;
    }
    if (l$issuesSort != lOther$issuesSort) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issuesSort = issuesSort;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('issuesSort') ? l$issuesSort : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPreferencesUpdateInput<TRes> {
  factory CopyWith$Input$UserPreferencesUpdateInput(
    Input$UserPreferencesUpdateInput instance,
    TRes Function(Input$UserPreferencesUpdateInput) then,
  ) = _CopyWithImpl$Input$UserPreferencesUpdateInput;

  factory CopyWith$Input$UserPreferencesUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPreferencesUpdateInput;

  TRes call({
    String? clientMutationId,
    Enum$IssueSort? issuesSort,
  });
}

class _CopyWithImpl$Input$UserPreferencesUpdateInput<TRes>
    implements CopyWith$Input$UserPreferencesUpdateInput<TRes> {
  _CopyWithImpl$Input$UserPreferencesUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserPreferencesUpdateInput _instance;

  final TRes Function(Input$UserPreferencesUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issuesSort = _undefined,
  }) =>
      _then(Input$UserPreferencesUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issuesSort != _undefined)
          'issuesSort': (issuesSort as Enum$IssueSort?),
      }));
}

class _CopyWithStubImpl$Input$UserPreferencesUpdateInput<TRes>
    implements CopyWith$Input$UserPreferencesUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserPreferencesUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$IssueSort? issuesSort,
  }) =>
      _res;
}

class Input$VulnerabilityConfirmInput {
  factory Input$VulnerabilityConfirmInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$VulnerabilityConfirmInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$VulnerabilityConfirmInput._(this._$data);

  factory Input$VulnerabilityConfirmInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$VulnerabilityConfirmInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$VulnerabilityConfirmInput<Input$VulnerabilityConfirmInput>
      get copyWith => CopyWith$Input$VulnerabilityConfirmInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityConfirmInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityConfirmInput<TRes> {
  factory CopyWith$Input$VulnerabilityConfirmInput(
    Input$VulnerabilityConfirmInput instance,
    TRes Function(Input$VulnerabilityConfirmInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityConfirmInput;

  factory CopyWith$Input$VulnerabilityConfirmInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityConfirmInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$VulnerabilityConfirmInput<TRes>
    implements CopyWith$Input$VulnerabilityConfirmInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityConfirmInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityConfirmInput _instance;

  final TRes Function(Input$VulnerabilityConfirmInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$VulnerabilityConfirmInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityConfirmInput<TRes>
    implements CopyWith$Input$VulnerabilityConfirmInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityConfirmInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$VulnerabilityCreateInput {
  factory Input$VulnerabilityCreateInput({
    String? clientMutationId,
    required String project,
    required String name,
    required String description,
    required Input$VulnerabilityScannerInput scanner,
    required List<Input$VulnerabilityIdentifierInput> identifiers,
    Enum$VulnerabilityState? state,
    Enum$VulnerabilitySeverity? severity,
    Enum$VulnerabilityConfidence? confidence,
    String? solution,
    String? message,
    String? detectedAt,
    String? confirmedAt,
    String? resolvedAt,
    String? dismissedAt,
  }) =>
      Input$VulnerabilityCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'project': project,
        r'name': name,
        r'description': description,
        r'scanner': scanner,
        r'identifiers': identifiers,
        if (state != null) r'state': state,
        if (severity != null) r'severity': severity,
        if (confidence != null) r'confidence': confidence,
        if (solution != null) r'solution': solution,
        if (message != null) r'message': message,
        if (detectedAt != null) r'detectedAt': detectedAt,
        if (confirmedAt != null) r'confirmedAt': confirmedAt,
        if (resolvedAt != null) r'resolvedAt': resolvedAt,
        if (dismissedAt != null) r'dismissedAt': dismissedAt,
      });

  Input$VulnerabilityCreateInput._(this._$data);

  factory Input$VulnerabilityCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$project = data['project'];
    result$data['project'] = (l$project as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$scanner = data['scanner'];
    result$data['scanner'] = Input$VulnerabilityScannerInput.fromJson(
        (l$scanner as Map<String, dynamic>));
    final l$identifiers = data['identifiers'];
    result$data['identifiers'] = (l$identifiers as List<dynamic>)
        .map((e) => Input$VulnerabilityIdentifierInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$VulnerabilityState((l$state as String));
    }
    if (data.containsKey('severity')) {
      final l$severity = data['severity'];
      result$data['severity'] = l$severity == null
          ? null
          : fromJson$Enum$VulnerabilitySeverity((l$severity as String));
    }
    if (data.containsKey('confidence')) {
      final l$confidence = data['confidence'];
      result$data['confidence'] = l$confidence == null
          ? null
          : fromJson$Enum$VulnerabilityConfidence((l$confidence as String));
    }
    if (data.containsKey('solution')) {
      final l$solution = data['solution'];
      result$data['solution'] = (l$solution as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('detectedAt')) {
      final l$detectedAt = data['detectedAt'];
      result$data['detectedAt'] = (l$detectedAt as String?);
    }
    if (data.containsKey('confirmedAt')) {
      final l$confirmedAt = data['confirmedAt'];
      result$data['confirmedAt'] = (l$confirmedAt as String?);
    }
    if (data.containsKey('resolvedAt')) {
      final l$resolvedAt = data['resolvedAt'];
      result$data['resolvedAt'] = (l$resolvedAt as String?);
    }
    if (data.containsKey('dismissedAt')) {
      final l$dismissedAt = data['dismissedAt'];
      result$data['dismissedAt'] = (l$dismissedAt as String?);
    }
    return Input$VulnerabilityCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get project => (_$data['project'] as String);
  String get name => (_$data['name'] as String);
  String get description => (_$data['description'] as String);
  Input$VulnerabilityScannerInput get scanner =>
      (_$data['scanner'] as Input$VulnerabilityScannerInput);
  List<Input$VulnerabilityIdentifierInput> get identifiers =>
      (_$data['identifiers'] as List<Input$VulnerabilityIdentifierInput>);
  Enum$VulnerabilityState? get state =>
      (_$data['state'] as Enum$VulnerabilityState?);
  Enum$VulnerabilitySeverity? get severity =>
      (_$data['severity'] as Enum$VulnerabilitySeverity?);
  Enum$VulnerabilityConfidence? get confidence =>
      (_$data['confidence'] as Enum$VulnerabilityConfidence?);
  String? get solution => (_$data['solution'] as String?);
  String? get message => (_$data['message'] as String?);
  String? get detectedAt => (_$data['detectedAt'] as String?);
  String? get confirmedAt => (_$data['confirmedAt'] as String?);
  String? get resolvedAt => (_$data['resolvedAt'] as String?);
  String? get dismissedAt => (_$data['dismissedAt'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$project = project;
    result$data['project'] = l$project;
    final l$name = name;
    result$data['name'] = l$name;
    final l$description = description;
    result$data['description'] = l$description;
    final l$scanner = scanner;
    result$data['scanner'] = l$scanner.toJson();
    final l$identifiers = identifiers;
    result$data['identifiers'] = l$identifiers.map((e) => e.toJson()).toList();
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$VulnerabilityState(l$state);
    }
    if (_$data.containsKey('severity')) {
      final l$severity = severity;
      result$data['severity'] = l$severity == null
          ? null
          : toJson$Enum$VulnerabilitySeverity(l$severity);
    }
    if (_$data.containsKey('confidence')) {
      final l$confidence = confidence;
      result$data['confidence'] = l$confidence == null
          ? null
          : toJson$Enum$VulnerabilityConfidence(l$confidence);
    }
    if (_$data.containsKey('solution')) {
      final l$solution = solution;
      result$data['solution'] = l$solution;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('detectedAt')) {
      final l$detectedAt = detectedAt;
      result$data['detectedAt'] = l$detectedAt;
    }
    if (_$data.containsKey('confirmedAt')) {
      final l$confirmedAt = confirmedAt;
      result$data['confirmedAt'] = l$confirmedAt;
    }
    if (_$data.containsKey('resolvedAt')) {
      final l$resolvedAt = resolvedAt;
      result$data['resolvedAt'] = l$resolvedAt;
    }
    if (_$data.containsKey('dismissedAt')) {
      final l$dismissedAt = dismissedAt;
      result$data['dismissedAt'] = l$dismissedAt;
    }
    return result$data;
  }

  CopyWith$Input$VulnerabilityCreateInput<Input$VulnerabilityCreateInput>
      get copyWith => CopyWith$Input$VulnerabilityCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$project = project;
    final lOther$project = other.project;
    if (l$project != lOther$project) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$scanner = scanner;
    final lOther$scanner = other.scanner;
    if (l$scanner != lOther$scanner) {
      return false;
    }
    final l$identifiers = identifiers;
    final lOther$identifiers = other.identifiers;
    if (l$identifiers.length != lOther$identifiers.length) {
      return false;
    }
    for (int i = 0; i < l$identifiers.length; i++) {
      final l$identifiers$entry = l$identifiers[i];
      final lOther$identifiers$entry = lOther$identifiers[i];
      if (l$identifiers$entry != lOther$identifiers$entry) {
        return false;
      }
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$severity = severity;
    final lOther$severity = other.severity;
    if (_$data.containsKey('severity') !=
        other._$data.containsKey('severity')) {
      return false;
    }
    if (l$severity != lOther$severity) {
      return false;
    }
    final l$confidence = confidence;
    final lOther$confidence = other.confidence;
    if (_$data.containsKey('confidence') !=
        other._$data.containsKey('confidence')) {
      return false;
    }
    if (l$confidence != lOther$confidence) {
      return false;
    }
    final l$solution = solution;
    final lOther$solution = other.solution;
    if (_$data.containsKey('solution') !=
        other._$data.containsKey('solution')) {
      return false;
    }
    if (l$solution != lOther$solution) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$detectedAt = detectedAt;
    final lOther$detectedAt = other.detectedAt;
    if (_$data.containsKey('detectedAt') !=
        other._$data.containsKey('detectedAt')) {
      return false;
    }
    if (l$detectedAt != lOther$detectedAt) {
      return false;
    }
    final l$confirmedAt = confirmedAt;
    final lOther$confirmedAt = other.confirmedAt;
    if (_$data.containsKey('confirmedAt') !=
        other._$data.containsKey('confirmedAt')) {
      return false;
    }
    if (l$confirmedAt != lOther$confirmedAt) {
      return false;
    }
    final l$resolvedAt = resolvedAt;
    final lOther$resolvedAt = other.resolvedAt;
    if (_$data.containsKey('resolvedAt') !=
        other._$data.containsKey('resolvedAt')) {
      return false;
    }
    if (l$resolvedAt != lOther$resolvedAt) {
      return false;
    }
    final l$dismissedAt = dismissedAt;
    final lOther$dismissedAt = other.dismissedAt;
    if (_$data.containsKey('dismissedAt') !=
        other._$data.containsKey('dismissedAt')) {
      return false;
    }
    if (l$dismissedAt != lOther$dismissedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$project = project;
    final l$name = name;
    final l$description = description;
    final l$scanner = scanner;
    final l$identifiers = identifiers;
    final l$state = state;
    final l$severity = severity;
    final l$confidence = confidence;
    final l$solution = solution;
    final l$message = message;
    final l$detectedAt = detectedAt;
    final l$confirmedAt = confirmedAt;
    final l$resolvedAt = resolvedAt;
    final l$dismissedAt = dismissedAt;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$project,
      l$name,
      l$description,
      l$scanner,
      Object.hashAll(l$identifiers.map((v) => v)),
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('severity') ? l$severity : const {},
      _$data.containsKey('confidence') ? l$confidence : const {},
      _$data.containsKey('solution') ? l$solution : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('detectedAt') ? l$detectedAt : const {},
      _$data.containsKey('confirmedAt') ? l$confirmedAt : const {},
      _$data.containsKey('resolvedAt') ? l$resolvedAt : const {},
      _$data.containsKey('dismissedAt') ? l$dismissedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityCreateInput<TRes> {
  factory CopyWith$Input$VulnerabilityCreateInput(
    Input$VulnerabilityCreateInput instance,
    TRes Function(Input$VulnerabilityCreateInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityCreateInput;

  factory CopyWith$Input$VulnerabilityCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityCreateInput;

  TRes call({
    String? clientMutationId,
    String? project,
    String? name,
    String? description,
    Input$VulnerabilityScannerInput? scanner,
    List<Input$VulnerabilityIdentifierInput>? identifiers,
    Enum$VulnerabilityState? state,
    Enum$VulnerabilitySeverity? severity,
    Enum$VulnerabilityConfidence? confidence,
    String? solution,
    String? message,
    String? detectedAt,
    String? confirmedAt,
    String? resolvedAt,
    String? dismissedAt,
  });
  CopyWith$Input$VulnerabilityScannerInput<TRes> get scanner;
  TRes identifiers(
      Iterable<Input$VulnerabilityIdentifierInput> Function(
              Iterable<
                  CopyWith$Input$VulnerabilityIdentifierInput<
                      Input$VulnerabilityIdentifierInput>>)
          _fn);
}

class _CopyWithImpl$Input$VulnerabilityCreateInput<TRes>
    implements CopyWith$Input$VulnerabilityCreateInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityCreateInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityCreateInput _instance;

  final TRes Function(Input$VulnerabilityCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? project = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? scanner = _undefined,
    Object? identifiers = _undefined,
    Object? state = _undefined,
    Object? severity = _undefined,
    Object? confidence = _undefined,
    Object? solution = _undefined,
    Object? message = _undefined,
    Object? detectedAt = _undefined,
    Object? confirmedAt = _undefined,
    Object? resolvedAt = _undefined,
    Object? dismissedAt = _undefined,
  }) =>
      _then(Input$VulnerabilityCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (project != _undefined && project != null)
          'project': (project as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (scanner != _undefined && scanner != null)
          'scanner': (scanner as Input$VulnerabilityScannerInput),
        if (identifiers != _undefined && identifiers != null)
          'identifiers':
              (identifiers as List<Input$VulnerabilityIdentifierInput>),
        if (state != _undefined) 'state': (state as Enum$VulnerabilityState?),
        if (severity != _undefined)
          'severity': (severity as Enum$VulnerabilitySeverity?),
        if (confidence != _undefined)
          'confidence': (confidence as Enum$VulnerabilityConfidence?),
        if (solution != _undefined) 'solution': (solution as String?),
        if (message != _undefined) 'message': (message as String?),
        if (detectedAt != _undefined) 'detectedAt': (detectedAt as String?),
        if (confirmedAt != _undefined) 'confirmedAt': (confirmedAt as String?),
        if (resolvedAt != _undefined) 'resolvedAt': (resolvedAt as String?),
        if (dismissedAt != _undefined) 'dismissedAt': (dismissedAt as String?),
      }));
  CopyWith$Input$VulnerabilityScannerInput<TRes> get scanner {
    final local$scanner = _instance.scanner;
    return CopyWith$Input$VulnerabilityScannerInput(
        local$scanner, (e) => call(scanner: e));
  }

  TRes identifiers(
          Iterable<Input$VulnerabilityIdentifierInput> Function(
                  Iterable<
                      CopyWith$Input$VulnerabilityIdentifierInput<
                          Input$VulnerabilityIdentifierInput>>)
              _fn) =>
      call(
          identifiers: _fn(_instance.identifiers
              .map((e) => CopyWith$Input$VulnerabilityIdentifierInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$VulnerabilityCreateInput<TRes>
    implements CopyWith$Input$VulnerabilityCreateInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? project,
    String? name,
    String? description,
    Input$VulnerabilityScannerInput? scanner,
    List<Input$VulnerabilityIdentifierInput>? identifiers,
    Enum$VulnerabilityState? state,
    Enum$VulnerabilitySeverity? severity,
    Enum$VulnerabilityConfidence? confidence,
    String? solution,
    String? message,
    String? detectedAt,
    String? confirmedAt,
    String? resolvedAt,
    String? dismissedAt,
  }) =>
      _res;
  CopyWith$Input$VulnerabilityScannerInput<TRes> get scanner =>
      CopyWith$Input$VulnerabilityScannerInput.stub(_res);
  identifiers(_fn) => _res;
}

class Input$VulnerabilityDismissInput {
  factory Input$VulnerabilityDismissInput({
    String? clientMutationId,
    required String id,
    String? comment,
    Enum$VulnerabilityDismissalReason? dismissalReason,
  }) =>
      Input$VulnerabilityDismissInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (comment != null) r'comment': comment,
        if (dismissalReason != null) r'dismissalReason': dismissalReason,
      });

  Input$VulnerabilityDismissInput._(this._$data);

  factory Input$VulnerabilityDismissInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('dismissalReason')) {
      final l$dismissalReason = data['dismissalReason'];
      result$data['dismissalReason'] = l$dismissalReason == null
          ? null
          : fromJson$Enum$VulnerabilityDismissalReason(
              (l$dismissalReason as String));
    }
    return Input$VulnerabilityDismissInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  String? get comment => (_$data['comment'] as String?);
  Enum$VulnerabilityDismissalReason? get dismissalReason =>
      (_$data['dismissalReason'] as Enum$VulnerabilityDismissalReason?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('dismissalReason')) {
      final l$dismissalReason = dismissalReason;
      result$data['dismissalReason'] = l$dismissalReason == null
          ? null
          : toJson$Enum$VulnerabilityDismissalReason(l$dismissalReason);
    }
    return result$data;
  }

  CopyWith$Input$VulnerabilityDismissInput<Input$VulnerabilityDismissInput>
      get copyWith => CopyWith$Input$VulnerabilityDismissInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityDismissInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$dismissalReason = dismissalReason;
    final lOther$dismissalReason = other.dismissalReason;
    if (_$data.containsKey('dismissalReason') !=
        other._$data.containsKey('dismissalReason')) {
      return false;
    }
    if (l$dismissalReason != lOther$dismissalReason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$comment = comment;
    final l$dismissalReason = dismissalReason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('dismissalReason') ? l$dismissalReason : const {},
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityDismissInput<TRes> {
  factory CopyWith$Input$VulnerabilityDismissInput(
    Input$VulnerabilityDismissInput instance,
    TRes Function(Input$VulnerabilityDismissInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityDismissInput;

  factory CopyWith$Input$VulnerabilityDismissInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityDismissInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? comment,
    Enum$VulnerabilityDismissalReason? dismissalReason,
  });
}

class _CopyWithImpl$Input$VulnerabilityDismissInput<TRes>
    implements CopyWith$Input$VulnerabilityDismissInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityDismissInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityDismissInput _instance;

  final TRes Function(Input$VulnerabilityDismissInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? comment = _undefined,
    Object? dismissalReason = _undefined,
  }) =>
      _then(Input$VulnerabilityDismissInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (comment != _undefined) 'comment': (comment as String?),
        if (dismissalReason != _undefined)
          'dismissalReason':
              (dismissalReason as Enum$VulnerabilityDismissalReason?),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityDismissInput<TRes>
    implements CopyWith$Input$VulnerabilityDismissInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityDismissInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? comment,
    Enum$VulnerabilityDismissalReason? dismissalReason,
  }) =>
      _res;
}

class Input$VulnerabilityExternalIssueLinkCreateInput {
  factory Input$VulnerabilityExternalIssueLinkCreateInput({
    String? clientMutationId,
    required String id,
    required Enum$VulnerabilityExternalIssueLinkType linkType,
    required Enum$VulnerabilityExternalIssueLinkExternalTracker externalTracker,
  }) =>
      Input$VulnerabilityExternalIssueLinkCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'linkType': linkType,
        r'externalTracker': externalTracker,
      });

  Input$VulnerabilityExternalIssueLinkCreateInput._(this._$data);

  factory Input$VulnerabilityExternalIssueLinkCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$linkType = data['linkType'];
    result$data['linkType'] = fromJson$Enum$VulnerabilityExternalIssueLinkType(
        (l$linkType as String));
    final l$externalTracker = data['externalTracker'];
    result$data['externalTracker'] =
        fromJson$Enum$VulnerabilityExternalIssueLinkExternalTracker(
            (l$externalTracker as String));
    return Input$VulnerabilityExternalIssueLinkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Enum$VulnerabilityExternalIssueLinkType get linkType =>
      (_$data['linkType'] as Enum$VulnerabilityExternalIssueLinkType);
  Enum$VulnerabilityExternalIssueLinkExternalTracker get externalTracker =>
      (_$data['externalTracker']
          as Enum$VulnerabilityExternalIssueLinkExternalTracker);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$linkType = linkType;
    result$data['linkType'] =
        toJson$Enum$VulnerabilityExternalIssueLinkType(l$linkType);
    final l$externalTracker = externalTracker;
    result$data['externalTracker'] =
        toJson$Enum$VulnerabilityExternalIssueLinkExternalTracker(
            l$externalTracker);
    return result$data;
  }

  CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput<
          Input$VulnerabilityExternalIssueLinkCreateInput>
      get copyWith => CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityExternalIssueLinkCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$linkType = linkType;
    final lOther$linkType = other.linkType;
    if (l$linkType != lOther$linkType) {
      return false;
    }
    final l$externalTracker = externalTracker;
    final lOther$externalTracker = other.externalTracker;
    if (l$externalTracker != lOther$externalTracker) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$linkType = linkType;
    final l$externalTracker = externalTracker;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$linkType,
      l$externalTracker,
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput<TRes> {
  factory CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput(
    Input$VulnerabilityExternalIssueLinkCreateInput instance,
    TRes Function(Input$VulnerabilityExternalIssueLinkCreateInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityExternalIssueLinkCreateInput;

  factory CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityExternalIssueLinkCreateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Enum$VulnerabilityExternalIssueLinkType? linkType,
    Enum$VulnerabilityExternalIssueLinkExternalTracker? externalTracker,
  });
}

class _CopyWithImpl$Input$VulnerabilityExternalIssueLinkCreateInput<TRes>
    implements CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityExternalIssueLinkCreateInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityExternalIssueLinkCreateInput _instance;

  final TRes Function(Input$VulnerabilityExternalIssueLinkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? linkType = _undefined,
    Object? externalTracker = _undefined,
  }) =>
      _then(Input$VulnerabilityExternalIssueLinkCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (linkType != _undefined && linkType != null)
          'linkType': (linkType as Enum$VulnerabilityExternalIssueLinkType),
        if (externalTracker != _undefined && externalTracker != null)
          'externalTracker': (externalTracker
              as Enum$VulnerabilityExternalIssueLinkExternalTracker),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityExternalIssueLinkCreateInput<TRes>
    implements CopyWith$Input$VulnerabilityExternalIssueLinkCreateInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityExternalIssueLinkCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Enum$VulnerabilityExternalIssueLinkType? linkType,
    Enum$VulnerabilityExternalIssueLinkExternalTracker? externalTracker,
  }) =>
      _res;
}

class Input$VulnerabilityExternalIssueLinkDestroyInput {
  factory Input$VulnerabilityExternalIssueLinkDestroyInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$VulnerabilityExternalIssueLinkDestroyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$VulnerabilityExternalIssueLinkDestroyInput._(this._$data);

  factory Input$VulnerabilityExternalIssueLinkDestroyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$VulnerabilityExternalIssueLinkDestroyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput<
          Input$VulnerabilityExternalIssueLinkDestroyInput>
      get copyWith => CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityExternalIssueLinkDestroyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput<TRes> {
  factory CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput(
    Input$VulnerabilityExternalIssueLinkDestroyInput instance,
    TRes Function(Input$VulnerabilityExternalIssueLinkDestroyInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityExternalIssueLinkDestroyInput;

  factory CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityExternalIssueLinkDestroyInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$VulnerabilityExternalIssueLinkDestroyInput<TRes>
    implements CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityExternalIssueLinkDestroyInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityExternalIssueLinkDestroyInput _instance;

  final TRes Function(Input$VulnerabilityExternalIssueLinkDestroyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$VulnerabilityExternalIssueLinkDestroyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityExternalIssueLinkDestroyInput<TRes>
    implements CopyWith$Input$VulnerabilityExternalIssueLinkDestroyInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityExternalIssueLinkDestroyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$VulnerabilityFindingDismissInput {
  factory Input$VulnerabilityFindingDismissInput({
    String? clientMutationId,
    String? uuid,
    String? comment,
    Enum$VulnerabilityDismissalReason? dismissalReason,
  }) =>
      Input$VulnerabilityFindingDismissInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (uuid != null) r'uuid': uuid,
        if (comment != null) r'comment': comment,
        if (dismissalReason != null) r'dismissalReason': dismissalReason,
      });

  Input$VulnerabilityFindingDismissInput._(this._$data);

  factory Input$VulnerabilityFindingDismissInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('dismissalReason')) {
      final l$dismissalReason = data['dismissalReason'];
      result$data['dismissalReason'] = l$dismissalReason == null
          ? null
          : fromJson$Enum$VulnerabilityDismissalReason(
              (l$dismissalReason as String));
    }
    return Input$VulnerabilityFindingDismissInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get uuid => (_$data['uuid'] as String?);
  String? get comment => (_$data['comment'] as String?);
  Enum$VulnerabilityDismissalReason? get dismissalReason =>
      (_$data['dismissalReason'] as Enum$VulnerabilityDismissalReason?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('dismissalReason')) {
      final l$dismissalReason = dismissalReason;
      result$data['dismissalReason'] = l$dismissalReason == null
          ? null
          : toJson$Enum$VulnerabilityDismissalReason(l$dismissalReason);
    }
    return result$data;
  }

  CopyWith$Input$VulnerabilityFindingDismissInput<
          Input$VulnerabilityFindingDismissInput>
      get copyWith => CopyWith$Input$VulnerabilityFindingDismissInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityFindingDismissInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$dismissalReason = dismissalReason;
    final lOther$dismissalReason = other.dismissalReason;
    if (_$data.containsKey('dismissalReason') !=
        other._$data.containsKey('dismissalReason')) {
      return false;
    }
    if (l$dismissalReason != lOther$dismissalReason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$uuid = uuid;
    final l$comment = comment;
    final l$dismissalReason = dismissalReason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('dismissalReason') ? l$dismissalReason : const {},
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityFindingDismissInput<TRes> {
  factory CopyWith$Input$VulnerabilityFindingDismissInput(
    Input$VulnerabilityFindingDismissInput instance,
    TRes Function(Input$VulnerabilityFindingDismissInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityFindingDismissInput;

  factory CopyWith$Input$VulnerabilityFindingDismissInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityFindingDismissInput;

  TRes call({
    String? clientMutationId,
    String? uuid,
    String? comment,
    Enum$VulnerabilityDismissalReason? dismissalReason,
  });
}

class _CopyWithImpl$Input$VulnerabilityFindingDismissInput<TRes>
    implements CopyWith$Input$VulnerabilityFindingDismissInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityFindingDismissInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityFindingDismissInput _instance;

  final TRes Function(Input$VulnerabilityFindingDismissInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? uuid = _undefined,
    Object? comment = _undefined,
    Object? dismissalReason = _undefined,
  }) =>
      _then(Input$VulnerabilityFindingDismissInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (dismissalReason != _undefined)
          'dismissalReason':
              (dismissalReason as Enum$VulnerabilityDismissalReason?),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityFindingDismissInput<TRes>
    implements CopyWith$Input$VulnerabilityFindingDismissInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityFindingDismissInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? uuid,
    String? comment,
    Enum$VulnerabilityDismissalReason? dismissalReason,
  }) =>
      _res;
}

class Input$VulnerabilityIdentifierInput {
  factory Input$VulnerabilityIdentifierInput({
    required String name,
    required String url,
    String? externalType,
    String? externalId,
  }) =>
      Input$VulnerabilityIdentifierInput._({
        r'name': name,
        r'url': url,
        if (externalType != null) r'externalType': externalType,
        if (externalId != null) r'externalId': externalId,
      });

  Input$VulnerabilityIdentifierInput._(this._$data);

  factory Input$VulnerabilityIdentifierInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    if (data.containsKey('externalType')) {
      final l$externalType = data['externalType'];
      result$data['externalType'] = (l$externalType as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    return Input$VulnerabilityIdentifierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get url => (_$data['url'] as String);
  String? get externalType => (_$data['externalType'] as String?);
  String? get externalId => (_$data['externalId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$url = url;
    result$data['url'] = l$url;
    if (_$data.containsKey('externalType')) {
      final l$externalType = externalType;
      result$data['externalType'] = l$externalType;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    return result$data;
  }

  CopyWith$Input$VulnerabilityIdentifierInput<
          Input$VulnerabilityIdentifierInput>
      get copyWith => CopyWith$Input$VulnerabilityIdentifierInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityIdentifierInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    final l$externalType = externalType;
    final lOther$externalType = other.externalType;
    if (_$data.containsKey('externalType') !=
        other._$data.containsKey('externalType')) {
      return false;
    }
    if (l$externalType != lOther$externalType) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$url = url;
    final l$externalType = externalType;
    final l$externalId = externalId;
    return Object.hashAll([
      l$name,
      l$url,
      _$data.containsKey('externalType') ? l$externalType : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityIdentifierInput<TRes> {
  factory CopyWith$Input$VulnerabilityIdentifierInput(
    Input$VulnerabilityIdentifierInput instance,
    TRes Function(Input$VulnerabilityIdentifierInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityIdentifierInput;

  factory CopyWith$Input$VulnerabilityIdentifierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityIdentifierInput;

  TRes call({
    String? name,
    String? url,
    String? externalType,
    String? externalId,
  });
}

class _CopyWithImpl$Input$VulnerabilityIdentifierInput<TRes>
    implements CopyWith$Input$VulnerabilityIdentifierInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityIdentifierInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityIdentifierInput _instance;

  final TRes Function(Input$VulnerabilityIdentifierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? url = _undefined,
    Object? externalType = _undefined,
    Object? externalId = _undefined,
  }) =>
      _then(Input$VulnerabilityIdentifierInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined && url != null) 'url': (url as String),
        if (externalType != _undefined)
          'externalType': (externalType as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityIdentifierInput<TRes>
    implements CopyWith$Input$VulnerabilityIdentifierInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityIdentifierInput(this._res);

  TRes _res;

  call({
    String? name,
    String? url,
    String? externalType,
    String? externalId,
  }) =>
      _res;
}

class Input$VulnerabilityResolveInput {
  factory Input$VulnerabilityResolveInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$VulnerabilityResolveInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$VulnerabilityResolveInput._(this._$data);

  factory Input$VulnerabilityResolveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$VulnerabilityResolveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$VulnerabilityResolveInput<Input$VulnerabilityResolveInput>
      get copyWith => CopyWith$Input$VulnerabilityResolveInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityResolveInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityResolveInput<TRes> {
  factory CopyWith$Input$VulnerabilityResolveInput(
    Input$VulnerabilityResolveInput instance,
    TRes Function(Input$VulnerabilityResolveInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityResolveInput;

  factory CopyWith$Input$VulnerabilityResolveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityResolveInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$VulnerabilityResolveInput<TRes>
    implements CopyWith$Input$VulnerabilityResolveInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityResolveInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityResolveInput _instance;

  final TRes Function(Input$VulnerabilityResolveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$VulnerabilityResolveInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityResolveInput<TRes>
    implements CopyWith$Input$VulnerabilityResolveInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityResolveInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$VulnerabilityRevertToDetectedInput {
  factory Input$VulnerabilityRevertToDetectedInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$VulnerabilityRevertToDetectedInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$VulnerabilityRevertToDetectedInput._(this._$data);

  factory Input$VulnerabilityRevertToDetectedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$VulnerabilityRevertToDetectedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$VulnerabilityRevertToDetectedInput<
          Input$VulnerabilityRevertToDetectedInput>
      get copyWith => CopyWith$Input$VulnerabilityRevertToDetectedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityRevertToDetectedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityRevertToDetectedInput<TRes> {
  factory CopyWith$Input$VulnerabilityRevertToDetectedInput(
    Input$VulnerabilityRevertToDetectedInput instance,
    TRes Function(Input$VulnerabilityRevertToDetectedInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityRevertToDetectedInput;

  factory CopyWith$Input$VulnerabilityRevertToDetectedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityRevertToDetectedInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$VulnerabilityRevertToDetectedInput<TRes>
    implements CopyWith$Input$VulnerabilityRevertToDetectedInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityRevertToDetectedInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityRevertToDetectedInput _instance;

  final TRes Function(Input$VulnerabilityRevertToDetectedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$VulnerabilityRevertToDetectedInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityRevertToDetectedInput<TRes>
    implements CopyWith$Input$VulnerabilityRevertToDetectedInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityRevertToDetectedInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$VulnerabilityScannerInput {
  factory Input$VulnerabilityScannerInput({
    required String id,
    required String name,
    required String url,
    Input$VulnerabilityScannerVendorInput? vendor,
    required String version,
  }) =>
      Input$VulnerabilityScannerInput._({
        r'id': id,
        r'name': name,
        r'url': url,
        if (vendor != null) r'vendor': vendor,
        r'version': version,
      });

  Input$VulnerabilityScannerInput._(this._$data);

  factory Input$VulnerabilityScannerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    if (data.containsKey('vendor')) {
      final l$vendor = data['vendor'];
      result$data['vendor'] = l$vendor == null
          ? null
          : Input$VulnerabilityScannerVendorInput.fromJson(
              (l$vendor as Map<String, dynamic>));
    }
    final l$version = data['version'];
    result$data['version'] = (l$version as String);
    return Input$VulnerabilityScannerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String get name => (_$data['name'] as String);
  String get url => (_$data['url'] as String);
  Input$VulnerabilityScannerVendorInput? get vendor =>
      (_$data['vendor'] as Input$VulnerabilityScannerVendorInput?);
  String get version => (_$data['version'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$name = name;
    result$data['name'] = l$name;
    final l$url = url;
    result$data['url'] = l$url;
    if (_$data.containsKey('vendor')) {
      final l$vendor = vendor;
      result$data['vendor'] = l$vendor?.toJson();
    }
    final l$version = version;
    result$data['version'] = l$version;
    return result$data;
  }

  CopyWith$Input$VulnerabilityScannerInput<Input$VulnerabilityScannerInput>
      get copyWith => CopyWith$Input$VulnerabilityScannerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityScannerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    final l$vendor = vendor;
    final lOther$vendor = other.vendor;
    if (_$data.containsKey('vendor') != other._$data.containsKey('vendor')) {
      return false;
    }
    if (l$vendor != lOther$vendor) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$url = url;
    final l$vendor = vendor;
    final l$version = version;
    return Object.hashAll([
      l$id,
      l$name,
      l$url,
      _$data.containsKey('vendor') ? l$vendor : const {},
      l$version,
    ]);
  }
}

abstract class CopyWith$Input$VulnerabilityScannerInput<TRes> {
  factory CopyWith$Input$VulnerabilityScannerInput(
    Input$VulnerabilityScannerInput instance,
    TRes Function(Input$VulnerabilityScannerInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityScannerInput;

  factory CopyWith$Input$VulnerabilityScannerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityScannerInput;

  TRes call({
    String? id,
    String? name,
    String? url,
    Input$VulnerabilityScannerVendorInput? vendor,
    String? version,
  });
  CopyWith$Input$VulnerabilityScannerVendorInput<TRes> get vendor;
}

class _CopyWithImpl$Input$VulnerabilityScannerInput<TRes>
    implements CopyWith$Input$VulnerabilityScannerInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityScannerInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityScannerInput _instance;

  final TRes Function(Input$VulnerabilityScannerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? url = _undefined,
    Object? vendor = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$VulnerabilityScannerInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined && url != null) 'url': (url as String),
        if (vendor != _undefined)
          'vendor': (vendor as Input$VulnerabilityScannerVendorInput?),
        if (version != _undefined && version != null)
          'version': (version as String),
      }));
  CopyWith$Input$VulnerabilityScannerVendorInput<TRes> get vendor {
    final local$vendor = _instance.vendor;
    return local$vendor == null
        ? CopyWith$Input$VulnerabilityScannerVendorInput.stub(_then(_instance))
        : CopyWith$Input$VulnerabilityScannerVendorInput(
            local$vendor, (e) => call(vendor: e));
  }
}

class _CopyWithStubImpl$Input$VulnerabilityScannerInput<TRes>
    implements CopyWith$Input$VulnerabilityScannerInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityScannerInput(this._res);

  TRes _res;

  call({
    String? id,
    String? name,
    String? url,
    Input$VulnerabilityScannerVendorInput? vendor,
    String? version,
  }) =>
      _res;
  CopyWith$Input$VulnerabilityScannerVendorInput<TRes> get vendor =>
      CopyWith$Input$VulnerabilityScannerVendorInput.stub(_res);
}

class Input$VulnerabilityScannerVendorInput {
  factory Input$VulnerabilityScannerVendorInput({required String name}) =>
      Input$VulnerabilityScannerVendorInput._({
        r'name': name,
      });

  Input$VulnerabilityScannerVendorInput._(this._$data);

  factory Input$VulnerabilityScannerVendorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$VulnerabilityScannerVendorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$VulnerabilityScannerVendorInput<
          Input$VulnerabilityScannerVendorInput>
      get copyWith => CopyWith$Input$VulnerabilityScannerVendorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VulnerabilityScannerVendorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    return Object.hashAll([l$name]);
  }
}

abstract class CopyWith$Input$VulnerabilityScannerVendorInput<TRes> {
  factory CopyWith$Input$VulnerabilityScannerVendorInput(
    Input$VulnerabilityScannerVendorInput instance,
    TRes Function(Input$VulnerabilityScannerVendorInput) then,
  ) = _CopyWithImpl$Input$VulnerabilityScannerVendorInput;

  factory CopyWith$Input$VulnerabilityScannerVendorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VulnerabilityScannerVendorInput;

  TRes call({String? name});
}

class _CopyWithImpl$Input$VulnerabilityScannerVendorInput<TRes>
    implements CopyWith$Input$VulnerabilityScannerVendorInput<TRes> {
  _CopyWithImpl$Input$VulnerabilityScannerVendorInput(
    this._instance,
    this._then,
  );

  final Input$VulnerabilityScannerVendorInput _instance;

  final TRes Function(Input$VulnerabilityScannerVendorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? name = _undefined}) =>
      _then(Input$VulnerabilityScannerVendorInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$VulnerabilityScannerVendorInput<TRes>
    implements CopyWith$Input$VulnerabilityScannerVendorInput<TRes> {
  _CopyWithStubImpl$Input$VulnerabilityScannerVendorInput(this._res);

  TRes _res;

  call({String? name}) => _res;
}

class Input$WorkItemConvertTaskInput {
  factory Input$WorkItemConvertTaskInput({
    required int lineNumberEnd,
    required int lineNumberStart,
    required int lockVersion,
    required String title,
    required String workItemTypeId,
  }) =>
      Input$WorkItemConvertTaskInput._({
        r'lineNumberEnd': lineNumberEnd,
        r'lineNumberStart': lineNumberStart,
        r'lockVersion': lockVersion,
        r'title': title,
        r'workItemTypeId': workItemTypeId,
      });

  Input$WorkItemConvertTaskInput._(this._$data);

  factory Input$WorkItemConvertTaskInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$lineNumberEnd = data['lineNumberEnd'];
    result$data['lineNumberEnd'] = (l$lineNumberEnd as int);
    final l$lineNumberStart = data['lineNumberStart'];
    result$data['lineNumberStart'] = (l$lineNumberStart as int);
    final l$lockVersion = data['lockVersion'];
    result$data['lockVersion'] = (l$lockVersion as int);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$workItemTypeId = data['workItemTypeId'];
    result$data['workItemTypeId'] = (l$workItemTypeId as String);
    return Input$WorkItemConvertTaskInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get lineNumberEnd => (_$data['lineNumberEnd'] as int);
  int get lineNumberStart => (_$data['lineNumberStart'] as int);
  int get lockVersion => (_$data['lockVersion'] as int);
  String get title => (_$data['title'] as String);
  String get workItemTypeId => (_$data['workItemTypeId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$lineNumberEnd = lineNumberEnd;
    result$data['lineNumberEnd'] = l$lineNumberEnd;
    final l$lineNumberStart = lineNumberStart;
    result$data['lineNumberStart'] = l$lineNumberStart;
    final l$lockVersion = lockVersion;
    result$data['lockVersion'] = l$lockVersion;
    final l$title = title;
    result$data['title'] = l$title;
    final l$workItemTypeId = workItemTypeId;
    result$data['workItemTypeId'] = l$workItemTypeId;
    return result$data;
  }

  CopyWith$Input$WorkItemConvertTaskInput<Input$WorkItemConvertTaskInput>
      get copyWith => CopyWith$Input$WorkItemConvertTaskInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemConvertTaskInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$lineNumberEnd = lineNumberEnd;
    final lOther$lineNumberEnd = other.lineNumberEnd;
    if (l$lineNumberEnd != lOther$lineNumberEnd) {
      return false;
    }
    final l$lineNumberStart = lineNumberStart;
    final lOther$lineNumberStart = other.lineNumberStart;
    if (l$lineNumberStart != lOther$lineNumberStart) {
      return false;
    }
    final l$lockVersion = lockVersion;
    final lOther$lockVersion = other.lockVersion;
    if (l$lockVersion != lOther$lockVersion) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$workItemTypeId = workItemTypeId;
    final lOther$workItemTypeId = other.workItemTypeId;
    if (l$workItemTypeId != lOther$workItemTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$lineNumberEnd = lineNumberEnd;
    final l$lineNumberStart = lineNumberStart;
    final l$lockVersion = lockVersion;
    final l$title = title;
    final l$workItemTypeId = workItemTypeId;
    return Object.hashAll([
      l$lineNumberEnd,
      l$lineNumberStart,
      l$lockVersion,
      l$title,
      l$workItemTypeId,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemConvertTaskInput<TRes> {
  factory CopyWith$Input$WorkItemConvertTaskInput(
    Input$WorkItemConvertTaskInput instance,
    TRes Function(Input$WorkItemConvertTaskInput) then,
  ) = _CopyWithImpl$Input$WorkItemConvertTaskInput;

  factory CopyWith$Input$WorkItemConvertTaskInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemConvertTaskInput;

  TRes call({
    int? lineNumberEnd,
    int? lineNumberStart,
    int? lockVersion,
    String? title,
    String? workItemTypeId,
  });
}

class _CopyWithImpl$Input$WorkItemConvertTaskInput<TRes>
    implements CopyWith$Input$WorkItemConvertTaskInput<TRes> {
  _CopyWithImpl$Input$WorkItemConvertTaskInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemConvertTaskInput _instance;

  final TRes Function(Input$WorkItemConvertTaskInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? lineNumberEnd = _undefined,
    Object? lineNumberStart = _undefined,
    Object? lockVersion = _undefined,
    Object? title = _undefined,
    Object? workItemTypeId = _undefined,
  }) =>
      _then(Input$WorkItemConvertTaskInput._({
        ..._instance._$data,
        if (lineNumberEnd != _undefined && lineNumberEnd != null)
          'lineNumberEnd': (lineNumberEnd as int),
        if (lineNumberStart != _undefined && lineNumberStart != null)
          'lineNumberStart': (lineNumberStart as int),
        if (lockVersion != _undefined && lockVersion != null)
          'lockVersion': (lockVersion as int),
        if (title != _undefined && title != null) 'title': (title as String),
        if (workItemTypeId != _undefined && workItemTypeId != null)
          'workItemTypeId': (workItemTypeId as String),
      }));
}

class _CopyWithStubImpl$Input$WorkItemConvertTaskInput<TRes>
    implements CopyWith$Input$WorkItemConvertTaskInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemConvertTaskInput(this._res);

  TRes _res;

  call({
    int? lineNumberEnd,
    int? lineNumberStart,
    int? lockVersion,
    String? title,
    String? workItemTypeId,
  }) =>
      _res;
}

class Input$WorkItemCreateFromTaskInput {
  factory Input$WorkItemCreateFromTaskInput({
    String? clientMutationId,
    required String id,
    required Input$WorkItemConvertTaskInput workItemData,
  }) =>
      Input$WorkItemCreateFromTaskInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'workItemData': workItemData,
      });

  Input$WorkItemCreateFromTaskInput._(this._$data);

  factory Input$WorkItemCreateFromTaskInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$workItemData = data['workItemData'];
    result$data['workItemData'] = Input$WorkItemConvertTaskInput.fromJson(
        (l$workItemData as Map<String, dynamic>));
    return Input$WorkItemCreateFromTaskInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Input$WorkItemConvertTaskInput get workItemData =>
      (_$data['workItemData'] as Input$WorkItemConvertTaskInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$workItemData = workItemData;
    result$data['workItemData'] = l$workItemData.toJson();
    return result$data;
  }

  CopyWith$Input$WorkItemCreateFromTaskInput<Input$WorkItemCreateFromTaskInput>
      get copyWith => CopyWith$Input$WorkItemCreateFromTaskInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemCreateFromTaskInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$workItemData = workItemData;
    final lOther$workItemData = other.workItemData;
    if (l$workItemData != lOther$workItemData) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$workItemData = workItemData;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$workItemData,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemCreateFromTaskInput<TRes> {
  factory CopyWith$Input$WorkItemCreateFromTaskInput(
    Input$WorkItemCreateFromTaskInput instance,
    TRes Function(Input$WorkItemCreateFromTaskInput) then,
  ) = _CopyWithImpl$Input$WorkItemCreateFromTaskInput;

  factory CopyWith$Input$WorkItemCreateFromTaskInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemCreateFromTaskInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Input$WorkItemConvertTaskInput? workItemData,
  });
  CopyWith$Input$WorkItemConvertTaskInput<TRes> get workItemData;
}

class _CopyWithImpl$Input$WorkItemCreateFromTaskInput<TRes>
    implements CopyWith$Input$WorkItemCreateFromTaskInput<TRes> {
  _CopyWithImpl$Input$WorkItemCreateFromTaskInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemCreateFromTaskInput _instance;

  final TRes Function(Input$WorkItemCreateFromTaskInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? workItemData = _undefined,
  }) =>
      _then(Input$WorkItemCreateFromTaskInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (workItemData != _undefined && workItemData != null)
          'workItemData': (workItemData as Input$WorkItemConvertTaskInput),
      }));
  CopyWith$Input$WorkItemConvertTaskInput<TRes> get workItemData {
    final local$workItemData = _instance.workItemData;
    return CopyWith$Input$WorkItemConvertTaskInput(
        local$workItemData, (e) => call(workItemData: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemCreateFromTaskInput<TRes>
    implements CopyWith$Input$WorkItemCreateFromTaskInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemCreateFromTaskInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Input$WorkItemConvertTaskInput? workItemData,
  }) =>
      _res;
  CopyWith$Input$WorkItemConvertTaskInput<TRes> get workItemData =>
      CopyWith$Input$WorkItemConvertTaskInput.stub(_res);
}

class Input$WorkItemCreateInput {
  factory Input$WorkItemCreateInput({
    String? clientMutationId,
    bool? confidential,
    String? description,
    Input$WorkItemWidgetHierarchyCreateInput? hierarchyWidget,
    required String projectPath,
    required String title,
    required String workItemTypeId,
  }) =>
      Input$WorkItemCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (confidential != null) r'confidential': confidential,
        if (description != null) r'description': description,
        if (hierarchyWidget != null) r'hierarchyWidget': hierarchyWidget,
        r'projectPath': projectPath,
        r'title': title,
        r'workItemTypeId': workItemTypeId,
      });

  Input$WorkItemCreateInput._(this._$data);

  factory Input$WorkItemCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('hierarchyWidget')) {
      final l$hierarchyWidget = data['hierarchyWidget'];
      result$data['hierarchyWidget'] = l$hierarchyWidget == null
          ? null
          : Input$WorkItemWidgetHierarchyCreateInput.fromJson(
              (l$hierarchyWidget as Map<String, dynamic>));
    }
    final l$projectPath = data['projectPath'];
    result$data['projectPath'] = (l$projectPath as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$workItemTypeId = data['workItemTypeId'];
    result$data['workItemTypeId'] = (l$workItemTypeId as String);
    return Input$WorkItemCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  String? get description => (_$data['description'] as String?);
  Input$WorkItemWidgetHierarchyCreateInput? get hierarchyWidget =>
      (_$data['hierarchyWidget'] as Input$WorkItemWidgetHierarchyCreateInput?);
  String get projectPath => (_$data['projectPath'] as String);
  String get title => (_$data['title'] as String);
  String get workItemTypeId => (_$data['workItemTypeId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('hierarchyWidget')) {
      final l$hierarchyWidget = hierarchyWidget;
      result$data['hierarchyWidget'] = l$hierarchyWidget?.toJson();
    }
    final l$projectPath = projectPath;
    result$data['projectPath'] = l$projectPath;
    final l$title = title;
    result$data['title'] = l$title;
    final l$workItemTypeId = workItemTypeId;
    result$data['workItemTypeId'] = l$workItemTypeId;
    return result$data;
  }

  CopyWith$Input$WorkItemCreateInput<Input$WorkItemCreateInput> get copyWith =>
      CopyWith$Input$WorkItemCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$hierarchyWidget = hierarchyWidget;
    final lOther$hierarchyWidget = other.hierarchyWidget;
    if (_$data.containsKey('hierarchyWidget') !=
        other._$data.containsKey('hierarchyWidget')) {
      return false;
    }
    if (l$hierarchyWidget != lOther$hierarchyWidget) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$workItemTypeId = workItemTypeId;
    final lOther$workItemTypeId = other.workItemTypeId;
    if (l$workItemTypeId != lOther$workItemTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$confidential = confidential;
    final l$description = description;
    final l$hierarchyWidget = hierarchyWidget;
    final l$projectPath = projectPath;
    final l$title = title;
    final l$workItemTypeId = workItemTypeId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('hierarchyWidget') ? l$hierarchyWidget : const {},
      l$projectPath,
      l$title,
      l$workItemTypeId,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemCreateInput<TRes> {
  factory CopyWith$Input$WorkItemCreateInput(
    Input$WorkItemCreateInput instance,
    TRes Function(Input$WorkItemCreateInput) then,
  ) = _CopyWithImpl$Input$WorkItemCreateInput;

  factory CopyWith$Input$WorkItemCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemCreateInput;

  TRes call({
    String? clientMutationId,
    bool? confidential,
    String? description,
    Input$WorkItemWidgetHierarchyCreateInput? hierarchyWidget,
    String? projectPath,
    String? title,
    String? workItemTypeId,
  });
  CopyWith$Input$WorkItemWidgetHierarchyCreateInput<TRes> get hierarchyWidget;
}

class _CopyWithImpl$Input$WorkItemCreateInput<TRes>
    implements CopyWith$Input$WorkItemCreateInput<TRes> {
  _CopyWithImpl$Input$WorkItemCreateInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemCreateInput _instance;

  final TRes Function(Input$WorkItemCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? confidential = _undefined,
    Object? description = _undefined,
    Object? hierarchyWidget = _undefined,
    Object? projectPath = _undefined,
    Object? title = _undefined,
    Object? workItemTypeId = _undefined,
  }) =>
      _then(Input$WorkItemCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (description != _undefined) 'description': (description as String?),
        if (hierarchyWidget != _undefined)
          'hierarchyWidget':
              (hierarchyWidget as Input$WorkItemWidgetHierarchyCreateInput?),
        if (projectPath != _undefined && projectPath != null)
          'projectPath': (projectPath as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (workItemTypeId != _undefined && workItemTypeId != null)
          'workItemTypeId': (workItemTypeId as String),
      }));
  CopyWith$Input$WorkItemWidgetHierarchyCreateInput<TRes> get hierarchyWidget {
    final local$hierarchyWidget = _instance.hierarchyWidget;
    return local$hierarchyWidget == null
        ? CopyWith$Input$WorkItemWidgetHierarchyCreateInput.stub(
            _then(_instance))
        : CopyWith$Input$WorkItemWidgetHierarchyCreateInput(
            local$hierarchyWidget, (e) => call(hierarchyWidget: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemCreateInput<TRes>
    implements CopyWith$Input$WorkItemCreateInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? confidential,
    String? description,
    Input$WorkItemWidgetHierarchyCreateInput? hierarchyWidget,
    String? projectPath,
    String? title,
    String? workItemTypeId,
  }) =>
      _res;
  CopyWith$Input$WorkItemWidgetHierarchyCreateInput<TRes> get hierarchyWidget =>
      CopyWith$Input$WorkItemWidgetHierarchyCreateInput.stub(_res);
}

class Input$WorkItemDeleteInput {
  factory Input$WorkItemDeleteInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$WorkItemDeleteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$WorkItemDeleteInput._(this._$data);

  factory Input$WorkItemDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$WorkItemDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$WorkItemDeleteInput<Input$WorkItemDeleteInput> get copyWith =>
      CopyWith$Input$WorkItemDeleteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemDeleteInput<TRes> {
  factory CopyWith$Input$WorkItemDeleteInput(
    Input$WorkItemDeleteInput instance,
    TRes Function(Input$WorkItemDeleteInput) then,
  ) = _CopyWithImpl$Input$WorkItemDeleteInput;

  factory CopyWith$Input$WorkItemDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemDeleteInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$WorkItemDeleteInput<TRes>
    implements CopyWith$Input$WorkItemDeleteInput<TRes> {
  _CopyWithImpl$Input$WorkItemDeleteInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemDeleteInput _instance;

  final TRes Function(Input$WorkItemDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$WorkItemDeleteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$WorkItemDeleteInput<TRes>
    implements CopyWith$Input$WorkItemDeleteInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemDeleteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$WorkItemDeleteTaskInput {
  factory Input$WorkItemDeleteTaskInput({
    String? clientMutationId,
    required String id,
    required int lockVersion,
    required Input$WorkItemDeletedTaskInput taskData,
  }) =>
      Input$WorkItemDeleteTaskInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'lockVersion': lockVersion,
        r'taskData': taskData,
      });

  Input$WorkItemDeleteTaskInput._(this._$data);

  factory Input$WorkItemDeleteTaskInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$lockVersion = data['lockVersion'];
    result$data['lockVersion'] = (l$lockVersion as int);
    final l$taskData = data['taskData'];
    result$data['taskData'] = Input$WorkItemDeletedTaskInput.fromJson(
        (l$taskData as Map<String, dynamic>));
    return Input$WorkItemDeleteTaskInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  int get lockVersion => (_$data['lockVersion'] as int);
  Input$WorkItemDeletedTaskInput get taskData =>
      (_$data['taskData'] as Input$WorkItemDeletedTaskInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$lockVersion = lockVersion;
    result$data['lockVersion'] = l$lockVersion;
    final l$taskData = taskData;
    result$data['taskData'] = l$taskData.toJson();
    return result$data;
  }

  CopyWith$Input$WorkItemDeleteTaskInput<Input$WorkItemDeleteTaskInput>
      get copyWith => CopyWith$Input$WorkItemDeleteTaskInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemDeleteTaskInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$lockVersion = lockVersion;
    final lOther$lockVersion = other.lockVersion;
    if (l$lockVersion != lOther$lockVersion) {
      return false;
    }
    final l$taskData = taskData;
    final lOther$taskData = other.taskData;
    if (l$taskData != lOther$taskData) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$lockVersion = lockVersion;
    final l$taskData = taskData;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$lockVersion,
      l$taskData,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemDeleteTaskInput<TRes> {
  factory CopyWith$Input$WorkItemDeleteTaskInput(
    Input$WorkItemDeleteTaskInput instance,
    TRes Function(Input$WorkItemDeleteTaskInput) then,
  ) = _CopyWithImpl$Input$WorkItemDeleteTaskInput;

  factory CopyWith$Input$WorkItemDeleteTaskInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemDeleteTaskInput;

  TRes call({
    String? clientMutationId,
    String? id,
    int? lockVersion,
    Input$WorkItemDeletedTaskInput? taskData,
  });
  CopyWith$Input$WorkItemDeletedTaskInput<TRes> get taskData;
}

class _CopyWithImpl$Input$WorkItemDeleteTaskInput<TRes>
    implements CopyWith$Input$WorkItemDeleteTaskInput<TRes> {
  _CopyWithImpl$Input$WorkItemDeleteTaskInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemDeleteTaskInput _instance;

  final TRes Function(Input$WorkItemDeleteTaskInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? lockVersion = _undefined,
    Object? taskData = _undefined,
  }) =>
      _then(Input$WorkItemDeleteTaskInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (lockVersion != _undefined && lockVersion != null)
          'lockVersion': (lockVersion as int),
        if (taskData != _undefined && taskData != null)
          'taskData': (taskData as Input$WorkItemDeletedTaskInput),
      }));
  CopyWith$Input$WorkItemDeletedTaskInput<TRes> get taskData {
    final local$taskData = _instance.taskData;
    return CopyWith$Input$WorkItemDeletedTaskInput(
        local$taskData, (e) => call(taskData: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemDeleteTaskInput<TRes>
    implements CopyWith$Input$WorkItemDeleteTaskInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemDeleteTaskInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    int? lockVersion,
    Input$WorkItemDeletedTaskInput? taskData,
  }) =>
      _res;
  CopyWith$Input$WorkItemDeletedTaskInput<TRes> get taskData =>
      CopyWith$Input$WorkItemDeletedTaskInput.stub(_res);
}

class Input$WorkItemDeletedTaskInput {
  factory Input$WorkItemDeletedTaskInput({
    required String id,
    required int lineNumberEnd,
    required int lineNumberStart,
  }) =>
      Input$WorkItemDeletedTaskInput._({
        r'id': id,
        r'lineNumberEnd': lineNumberEnd,
        r'lineNumberStart': lineNumberStart,
      });

  Input$WorkItemDeletedTaskInput._(this._$data);

  factory Input$WorkItemDeletedTaskInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$lineNumberEnd = data['lineNumberEnd'];
    result$data['lineNumberEnd'] = (l$lineNumberEnd as int);
    final l$lineNumberStart = data['lineNumberStart'];
    result$data['lineNumberStart'] = (l$lineNumberStart as int);
    return Input$WorkItemDeletedTaskInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  int get lineNumberEnd => (_$data['lineNumberEnd'] as int);
  int get lineNumberStart => (_$data['lineNumberStart'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$lineNumberEnd = lineNumberEnd;
    result$data['lineNumberEnd'] = l$lineNumberEnd;
    final l$lineNumberStart = lineNumberStart;
    result$data['lineNumberStart'] = l$lineNumberStart;
    return result$data;
  }

  CopyWith$Input$WorkItemDeletedTaskInput<Input$WorkItemDeletedTaskInput>
      get copyWith => CopyWith$Input$WorkItemDeletedTaskInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemDeletedTaskInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$lineNumberEnd = lineNumberEnd;
    final lOther$lineNumberEnd = other.lineNumberEnd;
    if (l$lineNumberEnd != lOther$lineNumberEnd) {
      return false;
    }
    final l$lineNumberStart = lineNumberStart;
    final lOther$lineNumberStart = other.lineNumberStart;
    if (l$lineNumberStart != lOther$lineNumberStart) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$lineNumberEnd = lineNumberEnd;
    final l$lineNumberStart = lineNumberStart;
    return Object.hashAll([
      l$id,
      l$lineNumberEnd,
      l$lineNumberStart,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemDeletedTaskInput<TRes> {
  factory CopyWith$Input$WorkItemDeletedTaskInput(
    Input$WorkItemDeletedTaskInput instance,
    TRes Function(Input$WorkItemDeletedTaskInput) then,
  ) = _CopyWithImpl$Input$WorkItemDeletedTaskInput;

  factory CopyWith$Input$WorkItemDeletedTaskInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemDeletedTaskInput;

  TRes call({
    String? id,
    int? lineNumberEnd,
    int? lineNumberStart,
  });
}

class _CopyWithImpl$Input$WorkItemDeletedTaskInput<TRes>
    implements CopyWith$Input$WorkItemDeletedTaskInput<TRes> {
  _CopyWithImpl$Input$WorkItemDeletedTaskInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemDeletedTaskInput _instance;

  final TRes Function(Input$WorkItemDeletedTaskInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? lineNumberEnd = _undefined,
    Object? lineNumberStart = _undefined,
  }) =>
      _then(Input$WorkItemDeletedTaskInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (lineNumberEnd != _undefined && lineNumberEnd != null)
          'lineNumberEnd': (lineNumberEnd as int),
        if (lineNumberStart != _undefined && lineNumberStart != null)
          'lineNumberStart': (lineNumberStart as int),
      }));
}

class _CopyWithStubImpl$Input$WorkItemDeletedTaskInput<TRes>
    implements CopyWith$Input$WorkItemDeletedTaskInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemDeletedTaskInput(this._res);

  TRes _res;

  call({
    String? id,
    int? lineNumberEnd,
    int? lineNumberStart,
  }) =>
      _res;
}

class Input$WorkItemUpdateInput {
  factory Input$WorkItemUpdateInput({
    String? clientMutationId,
    required String id,
    Enum$WorkItemStateEvent? stateEvent,
    String? title,
    bool? confidential,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
    Input$WorkItemWidgetAssigneesInput? assigneesWidget,
    Input$WorkItemWidgetHierarchyUpdateInput? hierarchyWidget,
    Input$WorkItemWidgetStartAndDueDateUpdateInput? startAndDueDateWidget,
    Input$WorkItemWidgetWeightInput? weightWidget,
  }) =>
      Input$WorkItemUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (stateEvent != null) r'stateEvent': stateEvent,
        if (title != null) r'title': title,
        if (confidential != null) r'confidential': confidential,
        if (descriptionWidget != null) r'descriptionWidget': descriptionWidget,
        if (assigneesWidget != null) r'assigneesWidget': assigneesWidget,
        if (hierarchyWidget != null) r'hierarchyWidget': hierarchyWidget,
        if (startAndDueDateWidget != null)
          r'startAndDueDateWidget': startAndDueDateWidget,
        if (weightWidget != null) r'weightWidget': weightWidget,
      });

  Input$WorkItemUpdateInput._(this._$data);

  factory Input$WorkItemUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('stateEvent')) {
      final l$stateEvent = data['stateEvent'];
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : fromJson$Enum$WorkItemStateEvent((l$stateEvent as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('descriptionWidget')) {
      final l$descriptionWidget = data['descriptionWidget'];
      result$data['descriptionWidget'] = l$descriptionWidget == null
          ? null
          : Input$WorkItemWidgetDescriptionInput.fromJson(
              (l$descriptionWidget as Map<String, dynamic>));
    }
    if (data.containsKey('assigneesWidget')) {
      final l$assigneesWidget = data['assigneesWidget'];
      result$data['assigneesWidget'] = l$assigneesWidget == null
          ? null
          : Input$WorkItemWidgetAssigneesInput.fromJson(
              (l$assigneesWidget as Map<String, dynamic>));
    }
    if (data.containsKey('hierarchyWidget')) {
      final l$hierarchyWidget = data['hierarchyWidget'];
      result$data['hierarchyWidget'] = l$hierarchyWidget == null
          ? null
          : Input$WorkItemWidgetHierarchyUpdateInput.fromJson(
              (l$hierarchyWidget as Map<String, dynamic>));
    }
    if (data.containsKey('startAndDueDateWidget')) {
      final l$startAndDueDateWidget = data['startAndDueDateWidget'];
      result$data['startAndDueDateWidget'] = l$startAndDueDateWidget == null
          ? null
          : Input$WorkItemWidgetStartAndDueDateUpdateInput.fromJson(
              (l$startAndDueDateWidget as Map<String, dynamic>));
    }
    if (data.containsKey('weightWidget')) {
      final l$weightWidget = data['weightWidget'];
      result$data['weightWidget'] = l$weightWidget == null
          ? null
          : Input$WorkItemWidgetWeightInput.fromJson(
              (l$weightWidget as Map<String, dynamic>));
    }
    return Input$WorkItemUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Enum$WorkItemStateEvent? get stateEvent =>
      (_$data['stateEvent'] as Enum$WorkItemStateEvent?);
  String? get title => (_$data['title'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  Input$WorkItemWidgetDescriptionInput? get descriptionWidget =>
      (_$data['descriptionWidget'] as Input$WorkItemWidgetDescriptionInput?);
  Input$WorkItemWidgetAssigneesInput? get assigneesWidget =>
      (_$data['assigneesWidget'] as Input$WorkItemWidgetAssigneesInput?);
  Input$WorkItemWidgetHierarchyUpdateInput? get hierarchyWidget =>
      (_$data['hierarchyWidget'] as Input$WorkItemWidgetHierarchyUpdateInput?);
  Input$WorkItemWidgetStartAndDueDateUpdateInput? get startAndDueDateWidget =>
      (_$data['startAndDueDateWidget']
          as Input$WorkItemWidgetStartAndDueDateUpdateInput?);
  Input$WorkItemWidgetWeightInput? get weightWidget =>
      (_$data['weightWidget'] as Input$WorkItemWidgetWeightInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('stateEvent')) {
      final l$stateEvent = stateEvent;
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : toJson$Enum$WorkItemStateEvent(l$stateEvent);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('descriptionWidget')) {
      final l$descriptionWidget = descriptionWidget;
      result$data['descriptionWidget'] = l$descriptionWidget?.toJson();
    }
    if (_$data.containsKey('assigneesWidget')) {
      final l$assigneesWidget = assigneesWidget;
      result$data['assigneesWidget'] = l$assigneesWidget?.toJson();
    }
    if (_$data.containsKey('hierarchyWidget')) {
      final l$hierarchyWidget = hierarchyWidget;
      result$data['hierarchyWidget'] = l$hierarchyWidget?.toJson();
    }
    if (_$data.containsKey('startAndDueDateWidget')) {
      final l$startAndDueDateWidget = startAndDueDateWidget;
      result$data['startAndDueDateWidget'] = l$startAndDueDateWidget?.toJson();
    }
    if (_$data.containsKey('weightWidget')) {
      final l$weightWidget = weightWidget;
      result$data['weightWidget'] = l$weightWidget?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WorkItemUpdateInput<Input$WorkItemUpdateInput> get copyWith =>
      CopyWith$Input$WorkItemUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$stateEvent = stateEvent;
    final lOther$stateEvent = other.stateEvent;
    if (_$data.containsKey('stateEvent') !=
        other._$data.containsKey('stateEvent')) {
      return false;
    }
    if (l$stateEvent != lOther$stateEvent) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$descriptionWidget = descriptionWidget;
    final lOther$descriptionWidget = other.descriptionWidget;
    if (_$data.containsKey('descriptionWidget') !=
        other._$data.containsKey('descriptionWidget')) {
      return false;
    }
    if (l$descriptionWidget != lOther$descriptionWidget) {
      return false;
    }
    final l$assigneesWidget = assigneesWidget;
    final lOther$assigneesWidget = other.assigneesWidget;
    if (_$data.containsKey('assigneesWidget') !=
        other._$data.containsKey('assigneesWidget')) {
      return false;
    }
    if (l$assigneesWidget != lOther$assigneesWidget) {
      return false;
    }
    final l$hierarchyWidget = hierarchyWidget;
    final lOther$hierarchyWidget = other.hierarchyWidget;
    if (_$data.containsKey('hierarchyWidget') !=
        other._$data.containsKey('hierarchyWidget')) {
      return false;
    }
    if (l$hierarchyWidget != lOther$hierarchyWidget) {
      return false;
    }
    final l$startAndDueDateWidget = startAndDueDateWidget;
    final lOther$startAndDueDateWidget = other.startAndDueDateWidget;
    if (_$data.containsKey('startAndDueDateWidget') !=
        other._$data.containsKey('startAndDueDateWidget')) {
      return false;
    }
    if (l$startAndDueDateWidget != lOther$startAndDueDateWidget) {
      return false;
    }
    final l$weightWidget = weightWidget;
    final lOther$weightWidget = other.weightWidget;
    if (_$data.containsKey('weightWidget') !=
        other._$data.containsKey('weightWidget')) {
      return false;
    }
    if (l$weightWidget != lOther$weightWidget) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$stateEvent = stateEvent;
    final l$title = title;
    final l$confidential = confidential;
    final l$descriptionWidget = descriptionWidget;
    final l$assigneesWidget = assigneesWidget;
    final l$hierarchyWidget = hierarchyWidget;
    final l$startAndDueDateWidget = startAndDueDateWidget;
    final l$weightWidget = weightWidget;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('stateEvent') ? l$stateEvent : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('descriptionWidget') ? l$descriptionWidget : const {},
      _$data.containsKey('assigneesWidget') ? l$assigneesWidget : const {},
      _$data.containsKey('hierarchyWidget') ? l$hierarchyWidget : const {},
      _$data.containsKey('startAndDueDateWidget')
          ? l$startAndDueDateWidget
          : const {},
      _$data.containsKey('weightWidget') ? l$weightWidget : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkItemUpdateInput<TRes> {
  factory CopyWith$Input$WorkItemUpdateInput(
    Input$WorkItemUpdateInput instance,
    TRes Function(Input$WorkItemUpdateInput) then,
  ) = _CopyWithImpl$Input$WorkItemUpdateInput;

  factory CopyWith$Input$WorkItemUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemUpdateInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Enum$WorkItemStateEvent? stateEvent,
    String? title,
    bool? confidential,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
    Input$WorkItemWidgetAssigneesInput? assigneesWidget,
    Input$WorkItemWidgetHierarchyUpdateInput? hierarchyWidget,
    Input$WorkItemWidgetStartAndDueDateUpdateInput? startAndDueDateWidget,
    Input$WorkItemWidgetWeightInput? weightWidget,
  });
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget;
  CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> get assigneesWidget;
  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> get hierarchyWidget;
  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
      get startAndDueDateWidget;
  CopyWith$Input$WorkItemWidgetWeightInput<TRes> get weightWidget;
}

class _CopyWithImpl$Input$WorkItemUpdateInput<TRes>
    implements CopyWith$Input$WorkItemUpdateInput<TRes> {
  _CopyWithImpl$Input$WorkItemUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemUpdateInput _instance;

  final TRes Function(Input$WorkItemUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? stateEvent = _undefined,
    Object? title = _undefined,
    Object? confidential = _undefined,
    Object? descriptionWidget = _undefined,
    Object? assigneesWidget = _undefined,
    Object? hierarchyWidget = _undefined,
    Object? startAndDueDateWidget = _undefined,
    Object? weightWidget = _undefined,
  }) =>
      _then(Input$WorkItemUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (stateEvent != _undefined)
          'stateEvent': (stateEvent as Enum$WorkItemStateEvent?),
        if (title != _undefined) 'title': (title as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (descriptionWidget != _undefined)
          'descriptionWidget':
              (descriptionWidget as Input$WorkItemWidgetDescriptionInput?),
        if (assigneesWidget != _undefined)
          'assigneesWidget':
              (assigneesWidget as Input$WorkItemWidgetAssigneesInput?),
        if (hierarchyWidget != _undefined)
          'hierarchyWidget':
              (hierarchyWidget as Input$WorkItemWidgetHierarchyUpdateInput?),
        if (startAndDueDateWidget != _undefined)
          'startAndDueDateWidget': (startAndDueDateWidget
              as Input$WorkItemWidgetStartAndDueDateUpdateInput?),
        if (weightWidget != _undefined)
          'weightWidget': (weightWidget as Input$WorkItemWidgetWeightInput?),
      }));
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget {
    final local$descriptionWidget = _instance.descriptionWidget;
    return local$descriptionWidget == null
        ? CopyWith$Input$WorkItemWidgetDescriptionInput.stub(_then(_instance))
        : CopyWith$Input$WorkItemWidgetDescriptionInput(
            local$descriptionWidget, (e) => call(descriptionWidget: e));
  }

  CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> get assigneesWidget {
    final local$assigneesWidget = _instance.assigneesWidget;
    return local$assigneesWidget == null
        ? CopyWith$Input$WorkItemWidgetAssigneesInput.stub(_then(_instance))
        : CopyWith$Input$WorkItemWidgetAssigneesInput(
            local$assigneesWidget, (e) => call(assigneesWidget: e));
  }

  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> get hierarchyWidget {
    final local$hierarchyWidget = _instance.hierarchyWidget;
    return local$hierarchyWidget == null
        ? CopyWith$Input$WorkItemWidgetHierarchyUpdateInput.stub(
            _then(_instance))
        : CopyWith$Input$WorkItemWidgetHierarchyUpdateInput(
            local$hierarchyWidget, (e) => call(hierarchyWidget: e));
  }

  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
      get startAndDueDateWidget {
    final local$startAndDueDateWidget = _instance.startAndDueDateWidget;
    return local$startAndDueDateWidget == null
        ? CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput.stub(
            _then(_instance))
        : CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput(
            local$startAndDueDateWidget, (e) => call(startAndDueDateWidget: e));
  }

  CopyWith$Input$WorkItemWidgetWeightInput<TRes> get weightWidget {
    final local$weightWidget = _instance.weightWidget;
    return local$weightWidget == null
        ? CopyWith$Input$WorkItemWidgetWeightInput.stub(_then(_instance))
        : CopyWith$Input$WorkItemWidgetWeightInput(
            local$weightWidget, (e) => call(weightWidget: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemUpdateInput<TRes>
    implements CopyWith$Input$WorkItemUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Enum$WorkItemStateEvent? stateEvent,
    String? title,
    bool? confidential,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
    Input$WorkItemWidgetAssigneesInput? assigneesWidget,
    Input$WorkItemWidgetHierarchyUpdateInput? hierarchyWidget,
    Input$WorkItemWidgetStartAndDueDateUpdateInput? startAndDueDateWidget,
    Input$WorkItemWidgetWeightInput? weightWidget,
  }) =>
      _res;
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget =>
      CopyWith$Input$WorkItemWidgetDescriptionInput.stub(_res);
  CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> get assigneesWidget =>
      CopyWith$Input$WorkItemWidgetAssigneesInput.stub(_res);
  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> get hierarchyWidget =>
      CopyWith$Input$WorkItemWidgetHierarchyUpdateInput.stub(_res);
  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
      get startAndDueDateWidget =>
          CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput.stub(_res);
  CopyWith$Input$WorkItemWidgetWeightInput<TRes> get weightWidget =>
      CopyWith$Input$WorkItemWidgetWeightInput.stub(_res);
}

class Input$WorkItemUpdateTaskInput {
  factory Input$WorkItemUpdateTaskInput({
    String? clientMutationId,
    required String id,
    required Input$WorkItemUpdatedTaskInput taskData,
  }) =>
      Input$WorkItemUpdateTaskInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'taskData': taskData,
      });

  Input$WorkItemUpdateTaskInput._(this._$data);

  factory Input$WorkItemUpdateTaskInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$taskData = data['taskData'];
    result$data['taskData'] = Input$WorkItemUpdatedTaskInput.fromJson(
        (l$taskData as Map<String, dynamic>));
    return Input$WorkItemUpdateTaskInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Input$WorkItemUpdatedTaskInput get taskData =>
      (_$data['taskData'] as Input$WorkItemUpdatedTaskInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$taskData = taskData;
    result$data['taskData'] = l$taskData.toJson();
    return result$data;
  }

  CopyWith$Input$WorkItemUpdateTaskInput<Input$WorkItemUpdateTaskInput>
      get copyWith => CopyWith$Input$WorkItemUpdateTaskInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemUpdateTaskInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$taskData = taskData;
    final lOther$taskData = other.taskData;
    if (l$taskData != lOther$taskData) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$taskData = taskData;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$taskData,
    ]);
  }
}

abstract class CopyWith$Input$WorkItemUpdateTaskInput<TRes> {
  factory CopyWith$Input$WorkItemUpdateTaskInput(
    Input$WorkItemUpdateTaskInput instance,
    TRes Function(Input$WorkItemUpdateTaskInput) then,
  ) = _CopyWithImpl$Input$WorkItemUpdateTaskInput;

  factory CopyWith$Input$WorkItemUpdateTaskInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemUpdateTaskInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Input$WorkItemUpdatedTaskInput? taskData,
  });
  CopyWith$Input$WorkItemUpdatedTaskInput<TRes> get taskData;
}

class _CopyWithImpl$Input$WorkItemUpdateTaskInput<TRes>
    implements CopyWith$Input$WorkItemUpdateTaskInput<TRes> {
  _CopyWithImpl$Input$WorkItemUpdateTaskInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemUpdateTaskInput _instance;

  final TRes Function(Input$WorkItemUpdateTaskInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? taskData = _undefined,
  }) =>
      _then(Input$WorkItemUpdateTaskInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (taskData != _undefined && taskData != null)
          'taskData': (taskData as Input$WorkItemUpdatedTaskInput),
      }));
  CopyWith$Input$WorkItemUpdatedTaskInput<TRes> get taskData {
    final local$taskData = _instance.taskData;
    return CopyWith$Input$WorkItemUpdatedTaskInput(
        local$taskData, (e) => call(taskData: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemUpdateTaskInput<TRes>
    implements CopyWith$Input$WorkItemUpdateTaskInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemUpdateTaskInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Input$WorkItemUpdatedTaskInput? taskData,
  }) =>
      _res;
  CopyWith$Input$WorkItemUpdatedTaskInput<TRes> get taskData =>
      CopyWith$Input$WorkItemUpdatedTaskInput.stub(_res);
}

class Input$WorkItemUpdateWidgetsInput {
  factory Input$WorkItemUpdateWidgetsInput({
    String? clientMutationId,
    required String id,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
  }) =>
      Input$WorkItemUpdateWidgetsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (descriptionWidget != null) r'descriptionWidget': descriptionWidget,
      });

  Input$WorkItemUpdateWidgetsInput._(this._$data);

  factory Input$WorkItemUpdateWidgetsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('descriptionWidget')) {
      final l$descriptionWidget = data['descriptionWidget'];
      result$data['descriptionWidget'] = l$descriptionWidget == null
          ? null
          : Input$WorkItemWidgetDescriptionInput.fromJson(
              (l$descriptionWidget as Map<String, dynamic>));
    }
    return Input$WorkItemUpdateWidgetsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Input$WorkItemWidgetDescriptionInput? get descriptionWidget =>
      (_$data['descriptionWidget'] as Input$WorkItemWidgetDescriptionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('descriptionWidget')) {
      final l$descriptionWidget = descriptionWidget;
      result$data['descriptionWidget'] = l$descriptionWidget?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WorkItemUpdateWidgetsInput<Input$WorkItemUpdateWidgetsInput>
      get copyWith => CopyWith$Input$WorkItemUpdateWidgetsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemUpdateWidgetsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$descriptionWidget = descriptionWidget;
    final lOther$descriptionWidget = other.descriptionWidget;
    if (_$data.containsKey('descriptionWidget') !=
        other._$data.containsKey('descriptionWidget')) {
      return false;
    }
    if (l$descriptionWidget != lOther$descriptionWidget) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$descriptionWidget = descriptionWidget;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('descriptionWidget') ? l$descriptionWidget : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkItemUpdateWidgetsInput<TRes> {
  factory CopyWith$Input$WorkItemUpdateWidgetsInput(
    Input$WorkItemUpdateWidgetsInput instance,
    TRes Function(Input$WorkItemUpdateWidgetsInput) then,
  ) = _CopyWithImpl$Input$WorkItemUpdateWidgetsInput;

  factory CopyWith$Input$WorkItemUpdateWidgetsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemUpdateWidgetsInput;

  TRes call({
    String? clientMutationId,
    String? id,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
  });
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget;
}

class _CopyWithImpl$Input$WorkItemUpdateWidgetsInput<TRes>
    implements CopyWith$Input$WorkItemUpdateWidgetsInput<TRes> {
  _CopyWithImpl$Input$WorkItemUpdateWidgetsInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemUpdateWidgetsInput _instance;

  final TRes Function(Input$WorkItemUpdateWidgetsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? descriptionWidget = _undefined,
  }) =>
      _then(Input$WorkItemUpdateWidgetsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (descriptionWidget != _undefined)
          'descriptionWidget':
              (descriptionWidget as Input$WorkItemWidgetDescriptionInput?),
      }));
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget {
    final local$descriptionWidget = _instance.descriptionWidget;
    return local$descriptionWidget == null
        ? CopyWith$Input$WorkItemWidgetDescriptionInput.stub(_then(_instance))
        : CopyWith$Input$WorkItemWidgetDescriptionInput(
            local$descriptionWidget, (e) => call(descriptionWidget: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemUpdateWidgetsInput<TRes>
    implements CopyWith$Input$WorkItemUpdateWidgetsInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemUpdateWidgetsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
  }) =>
      _res;
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget =>
      CopyWith$Input$WorkItemWidgetDescriptionInput.stub(_res);
}

class Input$WorkItemUpdatedTaskInput {
  factory Input$WorkItemUpdatedTaskInput({
    required String id,
    Enum$WorkItemStateEvent? stateEvent,
    String? title,
    bool? confidential,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
    Input$WorkItemWidgetAssigneesInput? assigneesWidget,
    Input$WorkItemWidgetHierarchyUpdateInput? hierarchyWidget,
    Input$WorkItemWidgetStartAndDueDateUpdateInput? startAndDueDateWidget,
  }) =>
      Input$WorkItemUpdatedTaskInput._({
        r'id': id,
        if (stateEvent != null) r'stateEvent': stateEvent,
        if (title != null) r'title': title,
        if (confidential != null) r'confidential': confidential,
        if (descriptionWidget != null) r'descriptionWidget': descriptionWidget,
        if (assigneesWidget != null) r'assigneesWidget': assigneesWidget,
        if (hierarchyWidget != null) r'hierarchyWidget': hierarchyWidget,
        if (startAndDueDateWidget != null)
          r'startAndDueDateWidget': startAndDueDateWidget,
      });

  Input$WorkItemUpdatedTaskInput._(this._$data);

  factory Input$WorkItemUpdatedTaskInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('stateEvent')) {
      final l$stateEvent = data['stateEvent'];
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : fromJson$Enum$WorkItemStateEvent((l$stateEvent as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('confidential')) {
      final l$confidential = data['confidential'];
      result$data['confidential'] = (l$confidential as bool?);
    }
    if (data.containsKey('descriptionWidget')) {
      final l$descriptionWidget = data['descriptionWidget'];
      result$data['descriptionWidget'] = l$descriptionWidget == null
          ? null
          : Input$WorkItemWidgetDescriptionInput.fromJson(
              (l$descriptionWidget as Map<String, dynamic>));
    }
    if (data.containsKey('assigneesWidget')) {
      final l$assigneesWidget = data['assigneesWidget'];
      result$data['assigneesWidget'] = l$assigneesWidget == null
          ? null
          : Input$WorkItemWidgetAssigneesInput.fromJson(
              (l$assigneesWidget as Map<String, dynamic>));
    }
    if (data.containsKey('hierarchyWidget')) {
      final l$hierarchyWidget = data['hierarchyWidget'];
      result$data['hierarchyWidget'] = l$hierarchyWidget == null
          ? null
          : Input$WorkItemWidgetHierarchyUpdateInput.fromJson(
              (l$hierarchyWidget as Map<String, dynamic>));
    }
    if (data.containsKey('startAndDueDateWidget')) {
      final l$startAndDueDateWidget = data['startAndDueDateWidget'];
      result$data['startAndDueDateWidget'] = l$startAndDueDateWidget == null
          ? null
          : Input$WorkItemWidgetStartAndDueDateUpdateInput.fromJson(
              (l$startAndDueDateWidget as Map<String, dynamic>));
    }
    return Input$WorkItemUpdatedTaskInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Enum$WorkItemStateEvent? get stateEvent =>
      (_$data['stateEvent'] as Enum$WorkItemStateEvent?);
  String? get title => (_$data['title'] as String?);
  bool? get confidential => (_$data['confidential'] as bool?);
  Input$WorkItemWidgetDescriptionInput? get descriptionWidget =>
      (_$data['descriptionWidget'] as Input$WorkItemWidgetDescriptionInput?);
  Input$WorkItemWidgetAssigneesInput? get assigneesWidget =>
      (_$data['assigneesWidget'] as Input$WorkItemWidgetAssigneesInput?);
  Input$WorkItemWidgetHierarchyUpdateInput? get hierarchyWidget =>
      (_$data['hierarchyWidget'] as Input$WorkItemWidgetHierarchyUpdateInput?);
  Input$WorkItemWidgetStartAndDueDateUpdateInput? get startAndDueDateWidget =>
      (_$data['startAndDueDateWidget']
          as Input$WorkItemWidgetStartAndDueDateUpdateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('stateEvent')) {
      final l$stateEvent = stateEvent;
      result$data['stateEvent'] = l$stateEvent == null
          ? null
          : toJson$Enum$WorkItemStateEvent(l$stateEvent);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('confidential')) {
      final l$confidential = confidential;
      result$data['confidential'] = l$confidential;
    }
    if (_$data.containsKey('descriptionWidget')) {
      final l$descriptionWidget = descriptionWidget;
      result$data['descriptionWidget'] = l$descriptionWidget?.toJson();
    }
    if (_$data.containsKey('assigneesWidget')) {
      final l$assigneesWidget = assigneesWidget;
      result$data['assigneesWidget'] = l$assigneesWidget?.toJson();
    }
    if (_$data.containsKey('hierarchyWidget')) {
      final l$hierarchyWidget = hierarchyWidget;
      result$data['hierarchyWidget'] = l$hierarchyWidget?.toJson();
    }
    if (_$data.containsKey('startAndDueDateWidget')) {
      final l$startAndDueDateWidget = startAndDueDateWidget;
      result$data['startAndDueDateWidget'] = l$startAndDueDateWidget?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WorkItemUpdatedTaskInput<Input$WorkItemUpdatedTaskInput>
      get copyWith => CopyWith$Input$WorkItemUpdatedTaskInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemUpdatedTaskInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$stateEvent = stateEvent;
    final lOther$stateEvent = other.stateEvent;
    if (_$data.containsKey('stateEvent') !=
        other._$data.containsKey('stateEvent')) {
      return false;
    }
    if (l$stateEvent != lOther$stateEvent) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$confidential = confidential;
    final lOther$confidential = other.confidential;
    if (_$data.containsKey('confidential') !=
        other._$data.containsKey('confidential')) {
      return false;
    }
    if (l$confidential != lOther$confidential) {
      return false;
    }
    final l$descriptionWidget = descriptionWidget;
    final lOther$descriptionWidget = other.descriptionWidget;
    if (_$data.containsKey('descriptionWidget') !=
        other._$data.containsKey('descriptionWidget')) {
      return false;
    }
    if (l$descriptionWidget != lOther$descriptionWidget) {
      return false;
    }
    final l$assigneesWidget = assigneesWidget;
    final lOther$assigneesWidget = other.assigneesWidget;
    if (_$data.containsKey('assigneesWidget') !=
        other._$data.containsKey('assigneesWidget')) {
      return false;
    }
    if (l$assigneesWidget != lOther$assigneesWidget) {
      return false;
    }
    final l$hierarchyWidget = hierarchyWidget;
    final lOther$hierarchyWidget = other.hierarchyWidget;
    if (_$data.containsKey('hierarchyWidget') !=
        other._$data.containsKey('hierarchyWidget')) {
      return false;
    }
    if (l$hierarchyWidget != lOther$hierarchyWidget) {
      return false;
    }
    final l$startAndDueDateWidget = startAndDueDateWidget;
    final lOther$startAndDueDateWidget = other.startAndDueDateWidget;
    if (_$data.containsKey('startAndDueDateWidget') !=
        other._$data.containsKey('startAndDueDateWidget')) {
      return false;
    }
    if (l$startAndDueDateWidget != lOther$startAndDueDateWidget) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$stateEvent = stateEvent;
    final l$title = title;
    final l$confidential = confidential;
    final l$descriptionWidget = descriptionWidget;
    final l$assigneesWidget = assigneesWidget;
    final l$hierarchyWidget = hierarchyWidget;
    final l$startAndDueDateWidget = startAndDueDateWidget;
    return Object.hashAll([
      l$id,
      _$data.containsKey('stateEvent') ? l$stateEvent : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('confidential') ? l$confidential : const {},
      _$data.containsKey('descriptionWidget') ? l$descriptionWidget : const {},
      _$data.containsKey('assigneesWidget') ? l$assigneesWidget : const {},
      _$data.containsKey('hierarchyWidget') ? l$hierarchyWidget : const {},
      _$data.containsKey('startAndDueDateWidget')
          ? l$startAndDueDateWidget
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkItemUpdatedTaskInput<TRes> {
  factory CopyWith$Input$WorkItemUpdatedTaskInput(
    Input$WorkItemUpdatedTaskInput instance,
    TRes Function(Input$WorkItemUpdatedTaskInput) then,
  ) = _CopyWithImpl$Input$WorkItemUpdatedTaskInput;

  factory CopyWith$Input$WorkItemUpdatedTaskInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemUpdatedTaskInput;

  TRes call({
    String? id,
    Enum$WorkItemStateEvent? stateEvent,
    String? title,
    bool? confidential,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
    Input$WorkItemWidgetAssigneesInput? assigneesWidget,
    Input$WorkItemWidgetHierarchyUpdateInput? hierarchyWidget,
    Input$WorkItemWidgetStartAndDueDateUpdateInput? startAndDueDateWidget,
  });
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget;
  CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> get assigneesWidget;
  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> get hierarchyWidget;
  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
      get startAndDueDateWidget;
}

class _CopyWithImpl$Input$WorkItemUpdatedTaskInput<TRes>
    implements CopyWith$Input$WorkItemUpdatedTaskInput<TRes> {
  _CopyWithImpl$Input$WorkItemUpdatedTaskInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemUpdatedTaskInput _instance;

  final TRes Function(Input$WorkItemUpdatedTaskInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? stateEvent = _undefined,
    Object? title = _undefined,
    Object? confidential = _undefined,
    Object? descriptionWidget = _undefined,
    Object? assigneesWidget = _undefined,
    Object? hierarchyWidget = _undefined,
    Object? startAndDueDateWidget = _undefined,
  }) =>
      _then(Input$WorkItemUpdatedTaskInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (stateEvent != _undefined)
          'stateEvent': (stateEvent as Enum$WorkItemStateEvent?),
        if (title != _undefined) 'title': (title as String?),
        if (confidential != _undefined) 'confidential': (confidential as bool?),
        if (descriptionWidget != _undefined)
          'descriptionWidget':
              (descriptionWidget as Input$WorkItemWidgetDescriptionInput?),
        if (assigneesWidget != _undefined)
          'assigneesWidget':
              (assigneesWidget as Input$WorkItemWidgetAssigneesInput?),
        if (hierarchyWidget != _undefined)
          'hierarchyWidget':
              (hierarchyWidget as Input$WorkItemWidgetHierarchyUpdateInput?),
        if (startAndDueDateWidget != _undefined)
          'startAndDueDateWidget': (startAndDueDateWidget
              as Input$WorkItemWidgetStartAndDueDateUpdateInput?),
      }));
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget {
    final local$descriptionWidget = _instance.descriptionWidget;
    return local$descriptionWidget == null
        ? CopyWith$Input$WorkItemWidgetDescriptionInput.stub(_then(_instance))
        : CopyWith$Input$WorkItemWidgetDescriptionInput(
            local$descriptionWidget, (e) => call(descriptionWidget: e));
  }

  CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> get assigneesWidget {
    final local$assigneesWidget = _instance.assigneesWidget;
    return local$assigneesWidget == null
        ? CopyWith$Input$WorkItemWidgetAssigneesInput.stub(_then(_instance))
        : CopyWith$Input$WorkItemWidgetAssigneesInput(
            local$assigneesWidget, (e) => call(assigneesWidget: e));
  }

  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> get hierarchyWidget {
    final local$hierarchyWidget = _instance.hierarchyWidget;
    return local$hierarchyWidget == null
        ? CopyWith$Input$WorkItemWidgetHierarchyUpdateInput.stub(
            _then(_instance))
        : CopyWith$Input$WorkItemWidgetHierarchyUpdateInput(
            local$hierarchyWidget, (e) => call(hierarchyWidget: e));
  }

  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
      get startAndDueDateWidget {
    final local$startAndDueDateWidget = _instance.startAndDueDateWidget;
    return local$startAndDueDateWidget == null
        ? CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput.stub(
            _then(_instance))
        : CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput(
            local$startAndDueDateWidget, (e) => call(startAndDueDateWidget: e));
  }
}

class _CopyWithStubImpl$Input$WorkItemUpdatedTaskInput<TRes>
    implements CopyWith$Input$WorkItemUpdatedTaskInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemUpdatedTaskInput(this._res);

  TRes _res;

  call({
    String? id,
    Enum$WorkItemStateEvent? stateEvent,
    String? title,
    bool? confidential,
    Input$WorkItemWidgetDescriptionInput? descriptionWidget,
    Input$WorkItemWidgetAssigneesInput? assigneesWidget,
    Input$WorkItemWidgetHierarchyUpdateInput? hierarchyWidget,
    Input$WorkItemWidgetStartAndDueDateUpdateInput? startAndDueDateWidget,
  }) =>
      _res;
  CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> get descriptionWidget =>
      CopyWith$Input$WorkItemWidgetDescriptionInput.stub(_res);
  CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> get assigneesWidget =>
      CopyWith$Input$WorkItemWidgetAssigneesInput.stub(_res);
  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> get hierarchyWidget =>
      CopyWith$Input$WorkItemWidgetHierarchyUpdateInput.stub(_res);
  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
      get startAndDueDateWidget =>
          CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput.stub(_res);
}

class Input$WorkItemWidgetAssigneesInput {
  factory Input$WorkItemWidgetAssigneesInput(
          {required List<String> assigneeIds}) =>
      Input$WorkItemWidgetAssigneesInput._({
        r'assigneeIds': assigneeIds,
      });

  Input$WorkItemWidgetAssigneesInput._(this._$data);

  factory Input$WorkItemWidgetAssigneesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$WorkItemWidgetAssigneesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$WorkItemWidgetAssigneesInput<
          Input$WorkItemWidgetAssigneesInput>
      get copyWith => CopyWith$Input$WorkItemWidgetAssigneesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemWidgetAssigneesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeIds = assigneeIds;
    return Object.hashAll([Object.hashAll(l$assigneeIds.map((v) => v))]);
  }
}

abstract class CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> {
  factory CopyWith$Input$WorkItemWidgetAssigneesInput(
    Input$WorkItemWidgetAssigneesInput instance,
    TRes Function(Input$WorkItemWidgetAssigneesInput) then,
  ) = _CopyWithImpl$Input$WorkItemWidgetAssigneesInput;

  factory CopyWith$Input$WorkItemWidgetAssigneesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemWidgetAssigneesInput;

  TRes call({List<String>? assigneeIds});
}

class _CopyWithImpl$Input$WorkItemWidgetAssigneesInput<TRes>
    implements CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> {
  _CopyWithImpl$Input$WorkItemWidgetAssigneesInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemWidgetAssigneesInput _instance;

  final TRes Function(Input$WorkItemWidgetAssigneesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? assigneeIds = _undefined}) =>
      _then(Input$WorkItemWidgetAssigneesInput._({
        ..._instance._$data,
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$WorkItemWidgetAssigneesInput<TRes>
    implements CopyWith$Input$WorkItemWidgetAssigneesInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemWidgetAssigneesInput(this._res);

  TRes _res;

  call({List<String>? assigneeIds}) => _res;
}

class Input$WorkItemWidgetDescriptionInput {
  factory Input$WorkItemWidgetDescriptionInput({required String description}) =>
      Input$WorkItemWidgetDescriptionInput._({
        r'description': description,
      });

  Input$WorkItemWidgetDescriptionInput._(this._$data);

  factory Input$WorkItemWidgetDescriptionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    return Input$WorkItemWidgetDescriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get description => (_$data['description'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$description = description;
    result$data['description'] = l$description;
    return result$data;
  }

  CopyWith$Input$WorkItemWidgetDescriptionInput<
          Input$WorkItemWidgetDescriptionInput>
      get copyWith => CopyWith$Input$WorkItemWidgetDescriptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemWidgetDescriptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    return Object.hashAll([l$description]);
  }
}

abstract class CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> {
  factory CopyWith$Input$WorkItemWidgetDescriptionInput(
    Input$WorkItemWidgetDescriptionInput instance,
    TRes Function(Input$WorkItemWidgetDescriptionInput) then,
  ) = _CopyWithImpl$Input$WorkItemWidgetDescriptionInput;

  factory CopyWith$Input$WorkItemWidgetDescriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemWidgetDescriptionInput;

  TRes call({String? description});
}

class _CopyWithImpl$Input$WorkItemWidgetDescriptionInput<TRes>
    implements CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> {
  _CopyWithImpl$Input$WorkItemWidgetDescriptionInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemWidgetDescriptionInput _instance;

  final TRes Function(Input$WorkItemWidgetDescriptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? description = _undefined}) =>
      _then(Input$WorkItemWidgetDescriptionInput._({
        ..._instance._$data,
        if (description != _undefined && description != null)
          'description': (description as String),
      }));
}

class _CopyWithStubImpl$Input$WorkItemWidgetDescriptionInput<TRes>
    implements CopyWith$Input$WorkItemWidgetDescriptionInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemWidgetDescriptionInput(this._res);

  TRes _res;

  call({String? description}) => _res;
}

class Input$WorkItemWidgetHierarchyCreateInput {
  factory Input$WorkItemWidgetHierarchyCreateInput({String? parentId}) =>
      Input$WorkItemWidgetHierarchyCreateInput._({
        if (parentId != null) r'parentId': parentId,
      });

  Input$WorkItemWidgetHierarchyCreateInput._(this._$data);

  factory Input$WorkItemWidgetHierarchyCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = (l$parentId as String?);
    }
    return Input$WorkItemWidgetHierarchyCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get parentId => (_$data['parentId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] = l$parentId;
    }
    return result$data;
  }

  CopyWith$Input$WorkItemWidgetHierarchyCreateInput<
          Input$WorkItemWidgetHierarchyCreateInput>
      get copyWith => CopyWith$Input$WorkItemWidgetHierarchyCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemWidgetHierarchyCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$parentId = parentId;
    return Object.hashAll(
        [_$data.containsKey('parentId') ? l$parentId : const {}]);
  }
}

abstract class CopyWith$Input$WorkItemWidgetHierarchyCreateInput<TRes> {
  factory CopyWith$Input$WorkItemWidgetHierarchyCreateInput(
    Input$WorkItemWidgetHierarchyCreateInput instance,
    TRes Function(Input$WorkItemWidgetHierarchyCreateInput) then,
  ) = _CopyWithImpl$Input$WorkItemWidgetHierarchyCreateInput;

  factory CopyWith$Input$WorkItemWidgetHierarchyCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemWidgetHierarchyCreateInput;

  TRes call({String? parentId});
}

class _CopyWithImpl$Input$WorkItemWidgetHierarchyCreateInput<TRes>
    implements CopyWith$Input$WorkItemWidgetHierarchyCreateInput<TRes> {
  _CopyWithImpl$Input$WorkItemWidgetHierarchyCreateInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemWidgetHierarchyCreateInput _instance;

  final TRes Function(Input$WorkItemWidgetHierarchyCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? parentId = _undefined}) =>
      _then(Input$WorkItemWidgetHierarchyCreateInput._({
        ..._instance._$data,
        if (parentId != _undefined) 'parentId': (parentId as String?),
      }));
}

class _CopyWithStubImpl$Input$WorkItemWidgetHierarchyCreateInput<TRes>
    implements CopyWith$Input$WorkItemWidgetHierarchyCreateInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemWidgetHierarchyCreateInput(this._res);

  TRes _res;

  call({String? parentId}) => _res;
}

class Input$WorkItemWidgetHierarchyUpdateInput {
  factory Input$WorkItemWidgetHierarchyUpdateInput({
    String? parentId,
    List<String>? childrenIds,
  }) =>
      Input$WorkItemWidgetHierarchyUpdateInput._({
        if (parentId != null) r'parentId': parentId,
        if (childrenIds != null) r'childrenIds': childrenIds,
      });

  Input$WorkItemWidgetHierarchyUpdateInput._(this._$data);

  factory Input$WorkItemWidgetHierarchyUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = (l$parentId as String?);
    }
    if (data.containsKey('childrenIds')) {
      final l$childrenIds = data['childrenIds'];
      result$data['childrenIds'] =
          (l$childrenIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$WorkItemWidgetHierarchyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get parentId => (_$data['parentId'] as String?);
  List<String>? get childrenIds => (_$data['childrenIds'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] = l$parentId;
    }
    if (_$data.containsKey('childrenIds')) {
      final l$childrenIds = childrenIds;
      result$data['childrenIds'] = l$childrenIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<
          Input$WorkItemWidgetHierarchyUpdateInput>
      get copyWith => CopyWith$Input$WorkItemWidgetHierarchyUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemWidgetHierarchyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    final l$childrenIds = childrenIds;
    final lOther$childrenIds = other.childrenIds;
    if (_$data.containsKey('childrenIds') !=
        other._$data.containsKey('childrenIds')) {
      return false;
    }
    if (l$childrenIds != null && lOther$childrenIds != null) {
      if (l$childrenIds.length != lOther$childrenIds.length) {
        return false;
      }
      for (int i = 0; i < l$childrenIds.length; i++) {
        final l$childrenIds$entry = l$childrenIds[i];
        final lOther$childrenIds$entry = lOther$childrenIds[i];
        if (l$childrenIds$entry != lOther$childrenIds$entry) {
          return false;
        }
      }
    } else if (l$childrenIds != lOther$childrenIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$parentId = parentId;
    final l$childrenIds = childrenIds;
    return Object.hashAll([
      _$data.containsKey('parentId') ? l$parentId : const {},
      _$data.containsKey('childrenIds')
          ? l$childrenIds == null
              ? null
              : Object.hashAll(l$childrenIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> {
  factory CopyWith$Input$WorkItemWidgetHierarchyUpdateInput(
    Input$WorkItemWidgetHierarchyUpdateInput instance,
    TRes Function(Input$WorkItemWidgetHierarchyUpdateInput) then,
  ) = _CopyWithImpl$Input$WorkItemWidgetHierarchyUpdateInput;

  factory CopyWith$Input$WorkItemWidgetHierarchyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemWidgetHierarchyUpdateInput;

  TRes call({
    String? parentId,
    List<String>? childrenIds,
  });
}

class _CopyWithImpl$Input$WorkItemWidgetHierarchyUpdateInput<TRes>
    implements CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> {
  _CopyWithImpl$Input$WorkItemWidgetHierarchyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemWidgetHierarchyUpdateInput _instance;

  final TRes Function(Input$WorkItemWidgetHierarchyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? parentId = _undefined,
    Object? childrenIds = _undefined,
  }) =>
      _then(Input$WorkItemWidgetHierarchyUpdateInput._({
        ..._instance._$data,
        if (parentId != _undefined) 'parentId': (parentId as String?),
        if (childrenIds != _undefined)
          'childrenIds': (childrenIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$WorkItemWidgetHierarchyUpdateInput<TRes>
    implements CopyWith$Input$WorkItemWidgetHierarchyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemWidgetHierarchyUpdateInput(this._res);

  TRes _res;

  call({
    String? parentId,
    List<String>? childrenIds,
  }) =>
      _res;
}

class Input$WorkItemWidgetStartAndDueDateUpdateInput {
  factory Input$WorkItemWidgetStartAndDueDateUpdateInput({
    String? dueDate,
    String? startDate,
  }) =>
      Input$WorkItemWidgetStartAndDueDateUpdateInput._({
        if (dueDate != null) r'dueDate': dueDate,
        if (startDate != null) r'startDate': startDate,
      });

  Input$WorkItemWidgetStartAndDueDateUpdateInput._(this._$data);

  factory Input$WorkItemWidgetStartAndDueDateUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    return Input$WorkItemWidgetStartAndDueDateUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get dueDate => (_$data['dueDate'] as String?);
  String? get startDate => (_$data['startDate'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    return result$data;
  }

  CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<
          Input$WorkItemWidgetStartAndDueDateUpdateInput>
      get copyWith => CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemWidgetStartAndDueDateUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$dueDate = dueDate;
    final l$startDate = startDate;
    return Object.hashAll([
      _$data.containsKey('dueDate') ? l$dueDate : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes> {
  factory CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput(
    Input$WorkItemWidgetStartAndDueDateUpdateInput instance,
    TRes Function(Input$WorkItemWidgetStartAndDueDateUpdateInput) then,
  ) = _CopyWithImpl$Input$WorkItemWidgetStartAndDueDateUpdateInput;

  factory CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WorkItemWidgetStartAndDueDateUpdateInput;

  TRes call({
    String? dueDate,
    String? startDate,
  });
}

class _CopyWithImpl$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
    implements CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes> {
  _CopyWithImpl$Input$WorkItemWidgetStartAndDueDateUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemWidgetStartAndDueDateUpdateInput _instance;

  final TRes Function(Input$WorkItemWidgetStartAndDueDateUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? dueDate = _undefined,
    Object? startDate = _undefined,
  }) =>
      _then(Input$WorkItemWidgetStartAndDueDateUpdateInput._({
        ..._instance._$data,
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
      }));
}

class _CopyWithStubImpl$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes>
    implements CopyWith$Input$WorkItemWidgetStartAndDueDateUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemWidgetStartAndDueDateUpdateInput(this._res);

  TRes _res;

  call({
    String? dueDate,
    String? startDate,
  }) =>
      _res;
}

class Input$WorkItemWidgetWeightInput {
  factory Input$WorkItemWidgetWeightInput({int? weight}) =>
      Input$WorkItemWidgetWeightInput._({
        if (weight != null) r'weight': weight,
      });

  Input$WorkItemWidgetWeightInput._(this._$data);

  factory Input$WorkItemWidgetWeightInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as int?);
    }
    return Input$WorkItemWidgetWeightInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get weight => (_$data['weight'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    return result$data;
  }

  CopyWith$Input$WorkItemWidgetWeightInput<Input$WorkItemWidgetWeightInput>
      get copyWith => CopyWith$Input$WorkItemWidgetWeightInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkItemWidgetWeightInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$weight = weight;
    return Object.hashAll([_$data.containsKey('weight') ? l$weight : const {}]);
  }
}

abstract class CopyWith$Input$WorkItemWidgetWeightInput<TRes> {
  factory CopyWith$Input$WorkItemWidgetWeightInput(
    Input$WorkItemWidgetWeightInput instance,
    TRes Function(Input$WorkItemWidgetWeightInput) then,
  ) = _CopyWithImpl$Input$WorkItemWidgetWeightInput;

  factory CopyWith$Input$WorkItemWidgetWeightInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkItemWidgetWeightInput;

  TRes call({int? weight});
}

class _CopyWithImpl$Input$WorkItemWidgetWeightInput<TRes>
    implements CopyWith$Input$WorkItemWidgetWeightInput<TRes> {
  _CopyWithImpl$Input$WorkItemWidgetWeightInput(
    this._instance,
    this._then,
  );

  final Input$WorkItemWidgetWeightInput _instance;

  final TRes Function(Input$WorkItemWidgetWeightInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? weight = _undefined}) =>
      _then(Input$WorkItemWidgetWeightInput._({
        ..._instance._$data,
        if (weight != _undefined) 'weight': (weight as int?),
      }));
}

class _CopyWithStubImpl$Input$WorkItemWidgetWeightInput<TRes>
    implements CopyWith$Input$WorkItemWidgetWeightInput<TRes> {
  _CopyWithStubImpl$Input$WorkItemWidgetWeightInput(this._res);

  TRes _res;

  call({int? weight}) => _res;
}

class Input$iterationCreateInput {
  factory Input$iterationCreateInput({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? iterationsCadenceId,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
  }) =>
      Input$iterationCreateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (projectPath != null) r'projectPath': projectPath,
        if (groupPath != null) r'groupPath': groupPath,
        if (iterationsCadenceId != null)
          r'iterationsCadenceId': iterationsCadenceId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (startDate != null) r'startDate': startDate,
        if (dueDate != null) r'dueDate': dueDate,
      });

  Input$iterationCreateInput._(this._$data);

  factory Input$iterationCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('projectPath')) {
      final l$projectPath = data['projectPath'];
      result$data['projectPath'] = (l$projectPath as String?);
    }
    if (data.containsKey('groupPath')) {
      final l$groupPath = data['groupPath'];
      result$data['groupPath'] = (l$groupPath as String?);
    }
    if (data.containsKey('iterationsCadenceId')) {
      final l$iterationsCadenceId = data['iterationsCadenceId'];
      result$data['iterationsCadenceId'] = (l$iterationsCadenceId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('dueDate')) {
      final l$dueDate = data['dueDate'];
      result$data['dueDate'] = (l$dueDate as String?);
    }
    return Input$iterationCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get projectPath => (_$data['projectPath'] as String?);
  String? get groupPath => (_$data['groupPath'] as String?);
  String? get iterationsCadenceId => (_$data['iterationsCadenceId'] as String?);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get startDate => (_$data['startDate'] as String?);
  String? get dueDate => (_$data['dueDate'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('projectPath')) {
      final l$projectPath = projectPath;
      result$data['projectPath'] = l$projectPath;
    }
    if (_$data.containsKey('groupPath')) {
      final l$groupPath = groupPath;
      result$data['groupPath'] = l$groupPath;
    }
    if (_$data.containsKey('iterationsCadenceId')) {
      final l$iterationsCadenceId = iterationsCadenceId;
      result$data['iterationsCadenceId'] = l$iterationsCadenceId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('dueDate')) {
      final l$dueDate = dueDate;
      result$data['dueDate'] = l$dueDate;
    }
    return result$data;
  }

  CopyWith$Input$iterationCreateInput<Input$iterationCreateInput>
      get copyWith => CopyWith$Input$iterationCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$iterationCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectPath = projectPath;
    final lOther$projectPath = other.projectPath;
    if (_$data.containsKey('projectPath') !=
        other._$data.containsKey('projectPath')) {
      return false;
    }
    if (l$projectPath != lOther$projectPath) {
      return false;
    }
    final l$groupPath = groupPath;
    final lOther$groupPath = other.groupPath;
    if (_$data.containsKey('groupPath') !=
        other._$data.containsKey('groupPath')) {
      return false;
    }
    if (l$groupPath != lOther$groupPath) {
      return false;
    }
    final l$iterationsCadenceId = iterationsCadenceId;
    final lOther$iterationsCadenceId = other.iterationsCadenceId;
    if (_$data.containsKey('iterationsCadenceId') !=
        other._$data.containsKey('iterationsCadenceId')) {
      return false;
    }
    if (l$iterationsCadenceId != lOther$iterationsCadenceId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$dueDate = dueDate;
    final lOther$dueDate = other.dueDate;
    if (_$data.containsKey('dueDate') != other._$data.containsKey('dueDate')) {
      return false;
    }
    if (l$dueDate != lOther$dueDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectPath = projectPath;
    final l$groupPath = groupPath;
    final l$iterationsCadenceId = iterationsCadenceId;
    final l$title = title;
    final l$description = description;
    final l$startDate = startDate;
    final l$dueDate = dueDate;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('projectPath') ? l$projectPath : const {},
      _$data.containsKey('groupPath') ? l$groupPath : const {},
      _$data.containsKey('iterationsCadenceId')
          ? l$iterationsCadenceId
          : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('dueDate') ? l$dueDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$iterationCreateInput<TRes> {
  factory CopyWith$Input$iterationCreateInput(
    Input$iterationCreateInput instance,
    TRes Function(Input$iterationCreateInput) then,
  ) = _CopyWithImpl$Input$iterationCreateInput;

  factory CopyWith$Input$iterationCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$iterationCreateInput;

  TRes call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? iterationsCadenceId,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
  });
}

class _CopyWithImpl$Input$iterationCreateInput<TRes>
    implements CopyWith$Input$iterationCreateInput<TRes> {
  _CopyWithImpl$Input$iterationCreateInput(
    this._instance,
    this._then,
  );

  final Input$iterationCreateInput _instance;

  final TRes Function(Input$iterationCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectPath = _undefined,
    Object? groupPath = _undefined,
    Object? iterationsCadenceId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? startDate = _undefined,
    Object? dueDate = _undefined,
  }) =>
      _then(Input$iterationCreateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectPath != _undefined) 'projectPath': (projectPath as String?),
        if (groupPath != _undefined) 'groupPath': (groupPath as String?),
        if (iterationsCadenceId != _undefined)
          'iterationsCadenceId': (iterationsCadenceId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (dueDate != _undefined) 'dueDate': (dueDate as String?),
      }));
}

class _CopyWithStubImpl$Input$iterationCreateInput<TRes>
    implements CopyWith$Input$iterationCreateInput<TRes> {
  _CopyWithStubImpl$Input$iterationCreateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectPath,
    String? groupPath,
    String? iterationsCadenceId,
    String? title,
    String? description,
    String? startDate,
    String? dueDate,
  }) =>
      _res;
}

enum Enum$AccessLevelEnum {
  NO_ACCESS,
  MINIMAL_ACCESS,
  GUEST,
  REPORTER,
  DEVELOPER,
  MAINTAINER,
  OWNER,
  $unknown
}

String toJson$Enum$AccessLevelEnum(Enum$AccessLevelEnum e) {
  switch (e) {
    case Enum$AccessLevelEnum.NO_ACCESS:
      return r'NO_ACCESS';
    case Enum$AccessLevelEnum.MINIMAL_ACCESS:
      return r'MINIMAL_ACCESS';
    case Enum$AccessLevelEnum.GUEST:
      return r'GUEST';
    case Enum$AccessLevelEnum.REPORTER:
      return r'REPORTER';
    case Enum$AccessLevelEnum.DEVELOPER:
      return r'DEVELOPER';
    case Enum$AccessLevelEnum.MAINTAINER:
      return r'MAINTAINER';
    case Enum$AccessLevelEnum.OWNER:
      return r'OWNER';
    case Enum$AccessLevelEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AccessLevelEnum fromJson$Enum$AccessLevelEnum(String value) {
  switch (value) {
    case r'NO_ACCESS':
      return Enum$AccessLevelEnum.NO_ACCESS;
    case r'MINIMAL_ACCESS':
      return Enum$AccessLevelEnum.MINIMAL_ACCESS;
    case r'GUEST':
      return Enum$AccessLevelEnum.GUEST;
    case r'REPORTER':
      return Enum$AccessLevelEnum.REPORTER;
    case r'DEVELOPER':
      return Enum$AccessLevelEnum.DEVELOPER;
    case r'MAINTAINER':
      return Enum$AccessLevelEnum.MAINTAINER;
    case r'OWNER':
      return Enum$AccessLevelEnum.OWNER;
    default:
      return Enum$AccessLevelEnum.$unknown;
  }
}

enum Enum$AgentTokenStatus { ACTIVE, REVOKED, $unknown }

String toJson$Enum$AgentTokenStatus(Enum$AgentTokenStatus e) {
  switch (e) {
    case Enum$AgentTokenStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$AgentTokenStatus.REVOKED:
      return r'REVOKED';
    case Enum$AgentTokenStatus.$unknown:
      return r'$unknown';
  }
}

Enum$AgentTokenStatus fromJson$Enum$AgentTokenStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$AgentTokenStatus.ACTIVE;
    case r'REVOKED':
      return Enum$AgentTokenStatus.REVOKED;
    default:
      return Enum$AgentTokenStatus.$unknown;
  }
}

enum Enum$AlertManagementAlertSort {
  STARTED_AT_ASC,
  STARTED_AT_DESC,
  ENDED_AT_ASC,
  ENDED_AT_DESC,
  CREATED_TIME_ASC,
  CREATED_TIME_DESC,
  UPDATED_TIME_ASC,
  UPDATED_TIME_DESC,
  EVENT_COUNT_ASC,
  EVENT_COUNT_DESC,
  SEVERITY_ASC,
  SEVERITY_DESC,
  STATUS_ASC,
  STATUS_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$AlertManagementAlertSort(Enum$AlertManagementAlertSort e) {
  switch (e) {
    case Enum$AlertManagementAlertSort.STARTED_AT_ASC:
      return r'STARTED_AT_ASC';
    case Enum$AlertManagementAlertSort.STARTED_AT_DESC:
      return r'STARTED_AT_DESC';
    case Enum$AlertManagementAlertSort.ENDED_AT_ASC:
      return r'ENDED_AT_ASC';
    case Enum$AlertManagementAlertSort.ENDED_AT_DESC:
      return r'ENDED_AT_DESC';
    case Enum$AlertManagementAlertSort.CREATED_TIME_ASC:
      return r'CREATED_TIME_ASC';
    case Enum$AlertManagementAlertSort.CREATED_TIME_DESC:
      return r'CREATED_TIME_DESC';
    case Enum$AlertManagementAlertSort.UPDATED_TIME_ASC:
      return r'UPDATED_TIME_ASC';
    case Enum$AlertManagementAlertSort.UPDATED_TIME_DESC:
      return r'UPDATED_TIME_DESC';
    case Enum$AlertManagementAlertSort.EVENT_COUNT_ASC:
      return r'EVENT_COUNT_ASC';
    case Enum$AlertManagementAlertSort.EVENT_COUNT_DESC:
      return r'EVENT_COUNT_DESC';
    case Enum$AlertManagementAlertSort.SEVERITY_ASC:
      return r'SEVERITY_ASC';
    case Enum$AlertManagementAlertSort.SEVERITY_DESC:
      return r'SEVERITY_DESC';
    case Enum$AlertManagementAlertSort.STATUS_ASC:
      return r'STATUS_ASC';
    case Enum$AlertManagementAlertSort.STATUS_DESC:
      return r'STATUS_DESC';
    case Enum$AlertManagementAlertSort.updated_desc:
      return r'updated_desc';
    case Enum$AlertManagementAlertSort.updated_asc:
      return r'updated_asc';
    case Enum$AlertManagementAlertSort.created_desc:
      return r'created_desc';
    case Enum$AlertManagementAlertSort.created_asc:
      return r'created_asc';
    case Enum$AlertManagementAlertSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$AlertManagementAlertSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$AlertManagementAlertSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$AlertManagementAlertSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$AlertManagementAlertSort.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementAlertSort fromJson$Enum$AlertManagementAlertSort(
    String value) {
  switch (value) {
    case r'STARTED_AT_ASC':
      return Enum$AlertManagementAlertSort.STARTED_AT_ASC;
    case r'STARTED_AT_DESC':
      return Enum$AlertManagementAlertSort.STARTED_AT_DESC;
    case r'ENDED_AT_ASC':
      return Enum$AlertManagementAlertSort.ENDED_AT_ASC;
    case r'ENDED_AT_DESC':
      return Enum$AlertManagementAlertSort.ENDED_AT_DESC;
    case r'CREATED_TIME_ASC':
      return Enum$AlertManagementAlertSort.CREATED_TIME_ASC;
    case r'CREATED_TIME_DESC':
      return Enum$AlertManagementAlertSort.CREATED_TIME_DESC;
    case r'UPDATED_TIME_ASC':
      return Enum$AlertManagementAlertSort.UPDATED_TIME_ASC;
    case r'UPDATED_TIME_DESC':
      return Enum$AlertManagementAlertSort.UPDATED_TIME_DESC;
    case r'EVENT_COUNT_ASC':
      return Enum$AlertManagementAlertSort.EVENT_COUNT_ASC;
    case r'EVENT_COUNT_DESC':
      return Enum$AlertManagementAlertSort.EVENT_COUNT_DESC;
    case r'SEVERITY_ASC':
      return Enum$AlertManagementAlertSort.SEVERITY_ASC;
    case r'SEVERITY_DESC':
      return Enum$AlertManagementAlertSort.SEVERITY_DESC;
    case r'STATUS_ASC':
      return Enum$AlertManagementAlertSort.STATUS_ASC;
    case r'STATUS_DESC':
      return Enum$AlertManagementAlertSort.STATUS_DESC;
    case r'updated_desc':
      return Enum$AlertManagementAlertSort.updated_desc;
    case r'updated_asc':
      return Enum$AlertManagementAlertSort.updated_asc;
    case r'created_desc':
      return Enum$AlertManagementAlertSort.created_desc;
    case r'created_asc':
      return Enum$AlertManagementAlertSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$AlertManagementAlertSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$AlertManagementAlertSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$AlertManagementAlertSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$AlertManagementAlertSort.CREATED_ASC;
    default:
      return Enum$AlertManagementAlertSort.$unknown;
  }
}

enum Enum$AlertManagementDomainFilter {
  operations,
  threat_monitoring,
  $unknown
}

String toJson$Enum$AlertManagementDomainFilter(
    Enum$AlertManagementDomainFilter e) {
  switch (e) {
    case Enum$AlertManagementDomainFilter.operations:
      return r'operations';
    case Enum$AlertManagementDomainFilter.threat_monitoring:
      return r'threat_monitoring';
    case Enum$AlertManagementDomainFilter.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementDomainFilter fromJson$Enum$AlertManagementDomainFilter(
    String value) {
  switch (value) {
    case r'operations':
      return Enum$AlertManagementDomainFilter.operations;
    case r'threat_monitoring':
      return Enum$AlertManagementDomainFilter.threat_monitoring;
    default:
      return Enum$AlertManagementDomainFilter.$unknown;
  }
}

enum Enum$AlertManagementIntegrationType { PROMETHEUS, HTTP, $unknown }

String toJson$Enum$AlertManagementIntegrationType(
    Enum$AlertManagementIntegrationType e) {
  switch (e) {
    case Enum$AlertManagementIntegrationType.PROMETHEUS:
      return r'PROMETHEUS';
    case Enum$AlertManagementIntegrationType.HTTP:
      return r'HTTP';
    case Enum$AlertManagementIntegrationType.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementIntegrationType
    fromJson$Enum$AlertManagementIntegrationType(String value) {
  switch (value) {
    case r'PROMETHEUS':
      return Enum$AlertManagementIntegrationType.PROMETHEUS;
    case r'HTTP':
      return Enum$AlertManagementIntegrationType.HTTP;
    default:
      return Enum$AlertManagementIntegrationType.$unknown;
  }
}

enum Enum$AlertManagementPayloadAlertFieldName {
  TITLE,
  DESCRIPTION,
  START_TIME,
  END_TIME,
  SERVICE,
  MONITORING_TOOL,
  HOSTS,
  SEVERITY,
  FINGERPRINT,
  GITLAB_ENVIRONMENT_NAME,
  $unknown
}

String toJson$Enum$AlertManagementPayloadAlertFieldName(
    Enum$AlertManagementPayloadAlertFieldName e) {
  switch (e) {
    case Enum$AlertManagementPayloadAlertFieldName.TITLE:
      return r'TITLE';
    case Enum$AlertManagementPayloadAlertFieldName.DESCRIPTION:
      return r'DESCRIPTION';
    case Enum$AlertManagementPayloadAlertFieldName.START_TIME:
      return r'START_TIME';
    case Enum$AlertManagementPayloadAlertFieldName.END_TIME:
      return r'END_TIME';
    case Enum$AlertManagementPayloadAlertFieldName.SERVICE:
      return r'SERVICE';
    case Enum$AlertManagementPayloadAlertFieldName.MONITORING_TOOL:
      return r'MONITORING_TOOL';
    case Enum$AlertManagementPayloadAlertFieldName.HOSTS:
      return r'HOSTS';
    case Enum$AlertManagementPayloadAlertFieldName.SEVERITY:
      return r'SEVERITY';
    case Enum$AlertManagementPayloadAlertFieldName.FINGERPRINT:
      return r'FINGERPRINT';
    case Enum$AlertManagementPayloadAlertFieldName.GITLAB_ENVIRONMENT_NAME:
      return r'GITLAB_ENVIRONMENT_NAME';
    case Enum$AlertManagementPayloadAlertFieldName.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementPayloadAlertFieldName
    fromJson$Enum$AlertManagementPayloadAlertFieldName(String value) {
  switch (value) {
    case r'TITLE':
      return Enum$AlertManagementPayloadAlertFieldName.TITLE;
    case r'DESCRIPTION':
      return Enum$AlertManagementPayloadAlertFieldName.DESCRIPTION;
    case r'START_TIME':
      return Enum$AlertManagementPayloadAlertFieldName.START_TIME;
    case r'END_TIME':
      return Enum$AlertManagementPayloadAlertFieldName.END_TIME;
    case r'SERVICE':
      return Enum$AlertManagementPayloadAlertFieldName.SERVICE;
    case r'MONITORING_TOOL':
      return Enum$AlertManagementPayloadAlertFieldName.MONITORING_TOOL;
    case r'HOSTS':
      return Enum$AlertManagementPayloadAlertFieldName.HOSTS;
    case r'SEVERITY':
      return Enum$AlertManagementPayloadAlertFieldName.SEVERITY;
    case r'FINGERPRINT':
      return Enum$AlertManagementPayloadAlertFieldName.FINGERPRINT;
    case r'GITLAB_ENVIRONMENT_NAME':
      return Enum$AlertManagementPayloadAlertFieldName.GITLAB_ENVIRONMENT_NAME;
    default:
      return Enum$AlertManagementPayloadAlertFieldName.$unknown;
  }
}

enum Enum$AlertManagementPayloadAlertFieldType {
  ARRAY,
  DATETIME,
  STRING,
  $unknown
}

String toJson$Enum$AlertManagementPayloadAlertFieldType(
    Enum$AlertManagementPayloadAlertFieldType e) {
  switch (e) {
    case Enum$AlertManagementPayloadAlertFieldType.ARRAY:
      return r'ARRAY';
    case Enum$AlertManagementPayloadAlertFieldType.DATETIME:
      return r'DATETIME';
    case Enum$AlertManagementPayloadAlertFieldType.STRING:
      return r'STRING';
    case Enum$AlertManagementPayloadAlertFieldType.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementPayloadAlertFieldType
    fromJson$Enum$AlertManagementPayloadAlertFieldType(String value) {
  switch (value) {
    case r'ARRAY':
      return Enum$AlertManagementPayloadAlertFieldType.ARRAY;
    case r'DATETIME':
      return Enum$AlertManagementPayloadAlertFieldType.DATETIME;
    case r'STRING':
      return Enum$AlertManagementPayloadAlertFieldType.STRING;
    default:
      return Enum$AlertManagementPayloadAlertFieldType.$unknown;
  }
}

enum Enum$AlertManagementSeverity {
  CRITICAL,
  HIGH,
  MEDIUM,
  LOW,
  INFO,
  UNKNOWN,
  $unknown
}

String toJson$Enum$AlertManagementSeverity(Enum$AlertManagementSeverity e) {
  switch (e) {
    case Enum$AlertManagementSeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$AlertManagementSeverity.HIGH:
      return r'HIGH';
    case Enum$AlertManagementSeverity.MEDIUM:
      return r'MEDIUM';
    case Enum$AlertManagementSeverity.LOW:
      return r'LOW';
    case Enum$AlertManagementSeverity.INFO:
      return r'INFO';
    case Enum$AlertManagementSeverity.UNKNOWN:
      return r'UNKNOWN';
    case Enum$AlertManagementSeverity.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementSeverity fromJson$Enum$AlertManagementSeverity(
    String value) {
  switch (value) {
    case r'CRITICAL':
      return Enum$AlertManagementSeverity.CRITICAL;
    case r'HIGH':
      return Enum$AlertManagementSeverity.HIGH;
    case r'MEDIUM':
      return Enum$AlertManagementSeverity.MEDIUM;
    case r'LOW':
      return Enum$AlertManagementSeverity.LOW;
    case r'INFO':
      return Enum$AlertManagementSeverity.INFO;
    case r'UNKNOWN':
      return Enum$AlertManagementSeverity.UNKNOWN;
    default:
      return Enum$AlertManagementSeverity.$unknown;
  }
}

enum Enum$AlertManagementStatus {
  TRIGGERED,
  ACKNOWLEDGED,
  RESOLVED,
  IGNORED,
  $unknown
}

String toJson$Enum$AlertManagementStatus(Enum$AlertManagementStatus e) {
  switch (e) {
    case Enum$AlertManagementStatus.TRIGGERED:
      return r'TRIGGERED';
    case Enum$AlertManagementStatus.ACKNOWLEDGED:
      return r'ACKNOWLEDGED';
    case Enum$AlertManagementStatus.RESOLVED:
      return r'RESOLVED';
    case Enum$AlertManagementStatus.IGNORED:
      return r'IGNORED';
    case Enum$AlertManagementStatus.$unknown:
      return r'$unknown';
  }
}

Enum$AlertManagementStatus fromJson$Enum$AlertManagementStatus(String value) {
  switch (value) {
    case r'TRIGGERED':
      return Enum$AlertManagementStatus.TRIGGERED;
    case r'ACKNOWLEDGED':
      return Enum$AlertManagementStatus.ACKNOWLEDGED;
    case r'RESOLVED':
      return Enum$AlertManagementStatus.RESOLVED;
    case r'IGNORED':
      return Enum$AlertManagementStatus.IGNORED;
    default:
      return Enum$AlertManagementStatus.$unknown;
  }
}

enum Enum$ApiFuzzingScanMode { HAR, OPENAPI, POSTMAN, $unknown }

String toJson$Enum$ApiFuzzingScanMode(Enum$ApiFuzzingScanMode e) {
  switch (e) {
    case Enum$ApiFuzzingScanMode.HAR:
      return r'HAR';
    case Enum$ApiFuzzingScanMode.OPENAPI:
      return r'OPENAPI';
    case Enum$ApiFuzzingScanMode.POSTMAN:
      return r'POSTMAN';
    case Enum$ApiFuzzingScanMode.$unknown:
      return r'$unknown';
  }
}

Enum$ApiFuzzingScanMode fromJson$Enum$ApiFuzzingScanMode(String value) {
  switch (value) {
    case r'HAR':
      return Enum$ApiFuzzingScanMode.HAR;
    case r'OPENAPI':
      return Enum$ApiFuzzingScanMode.OPENAPI;
    case r'POSTMAN':
      return Enum$ApiFuzzingScanMode.POSTMAN;
    default:
      return Enum$ApiFuzzingScanMode.$unknown;
  }
}

enum Enum$ApprovalRuleType {
  REGULAR,
  CODE_OWNER,
  REPORT_APPROVER,
  ANY_APPROVER,
  $unknown
}

String toJson$Enum$ApprovalRuleType(Enum$ApprovalRuleType e) {
  switch (e) {
    case Enum$ApprovalRuleType.REGULAR:
      return r'REGULAR';
    case Enum$ApprovalRuleType.CODE_OWNER:
      return r'CODE_OWNER';
    case Enum$ApprovalRuleType.REPORT_APPROVER:
      return r'REPORT_APPROVER';
    case Enum$ApprovalRuleType.ANY_APPROVER:
      return r'ANY_APPROVER';
    case Enum$ApprovalRuleType.$unknown:
      return r'$unknown';
  }
}

Enum$ApprovalRuleType fromJson$Enum$ApprovalRuleType(String value) {
  switch (value) {
    case r'REGULAR':
      return Enum$ApprovalRuleType.REGULAR;
    case r'CODE_OWNER':
      return Enum$ApprovalRuleType.CODE_OWNER;
    case r'REPORT_APPROVER':
      return Enum$ApprovalRuleType.REPORT_APPROVER;
    case r'ANY_APPROVER':
      return Enum$ApprovalRuleType.ANY_APPROVER;
    default:
      return Enum$ApprovalRuleType.$unknown;
  }
}

enum Enum$AssigneeWildcardId { NONE, ANY, $unknown }

String toJson$Enum$AssigneeWildcardId(Enum$AssigneeWildcardId e) {
  switch (e) {
    case Enum$AssigneeWildcardId.NONE:
      return r'NONE';
    case Enum$AssigneeWildcardId.ANY:
      return r'ANY';
    case Enum$AssigneeWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$AssigneeWildcardId fromJson$Enum$AssigneeWildcardId(String value) {
  switch (value) {
    case r'NONE':
      return Enum$AssigneeWildcardId.NONE;
    case r'ANY':
      return Enum$AssigneeWildcardId.ANY;
    default:
      return Enum$AssigneeWildcardId.$unknown;
  }
}

enum Enum$AvailabilityEnum { NOT_SET, BUSY, $unknown }

String toJson$Enum$AvailabilityEnum(Enum$AvailabilityEnum e) {
  switch (e) {
    case Enum$AvailabilityEnum.NOT_SET:
      return r'NOT_SET';
    case Enum$AvailabilityEnum.BUSY:
      return r'BUSY';
    case Enum$AvailabilityEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AvailabilityEnum fromJson$Enum$AvailabilityEnum(String value) {
  switch (value) {
    case r'NOT_SET':
      return Enum$AvailabilityEnum.NOT_SET;
    case r'BUSY':
      return Enum$AvailabilityEnum.BUSY;
    default:
      return Enum$AvailabilityEnum.$unknown;
  }
}

enum Enum$BlobViewersType { rich, simple, auxiliary, $unknown }

String toJson$Enum$BlobViewersType(Enum$BlobViewersType e) {
  switch (e) {
    case Enum$BlobViewersType.rich:
      return r'rich';
    case Enum$BlobViewersType.simple:
      return r'simple';
    case Enum$BlobViewersType.auxiliary:
      return r'auxiliary';
    case Enum$BlobViewersType.$unknown:
      return r'$unknown';
  }
}

Enum$BlobViewersType fromJson$Enum$BlobViewersType(String value) {
  switch (value) {
    case r'rich':
      return Enum$BlobViewersType.rich;
    case r'simple':
      return Enum$BlobViewersType.simple;
    case r'auxiliary':
      return Enum$BlobViewersType.auxiliary;
    default:
      return Enum$BlobViewersType.$unknown;
  }
}

enum Enum$CiConfigIncludeType { remote, local, file, template, $unknown }

String toJson$Enum$CiConfigIncludeType(Enum$CiConfigIncludeType e) {
  switch (e) {
    case Enum$CiConfigIncludeType.remote:
      return r'remote';
    case Enum$CiConfigIncludeType.local:
      return r'local';
    case Enum$CiConfigIncludeType.file:
      return r'file';
    case Enum$CiConfigIncludeType.template:
      return r'template';
    case Enum$CiConfigIncludeType.$unknown:
      return r'$unknown';
  }
}

Enum$CiConfigIncludeType fromJson$Enum$CiConfigIncludeType(String value) {
  switch (value) {
    case r'remote':
      return Enum$CiConfigIncludeType.remote;
    case r'local':
      return Enum$CiConfigIncludeType.local;
    case r'file':
      return Enum$CiConfigIncludeType.file;
    case r'template':
      return Enum$CiConfigIncludeType.template;
    default:
      return Enum$CiConfigIncludeType.$unknown;
  }
}

enum Enum$CiConfigStatus { VALID, INVALID, $unknown }

String toJson$Enum$CiConfigStatus(Enum$CiConfigStatus e) {
  switch (e) {
    case Enum$CiConfigStatus.VALID:
      return r'VALID';
    case Enum$CiConfigStatus.INVALID:
      return r'INVALID';
    case Enum$CiConfigStatus.$unknown:
      return r'$unknown';
  }
}

Enum$CiConfigStatus fromJson$Enum$CiConfigStatus(String value) {
  switch (value) {
    case r'VALID':
      return Enum$CiConfigStatus.VALID;
    case r'INVALID':
      return Enum$CiConfigStatus.INVALID;
    default:
      return Enum$CiConfigStatus.$unknown;
  }
}

enum Enum$CiJobKind { BUILD, BRIDGE, $unknown }

String toJson$Enum$CiJobKind(Enum$CiJobKind e) {
  switch (e) {
    case Enum$CiJobKind.BUILD:
      return r'BUILD';
    case Enum$CiJobKind.BRIDGE:
      return r'BRIDGE';
    case Enum$CiJobKind.$unknown:
      return r'$unknown';
  }
}

Enum$CiJobKind fromJson$Enum$CiJobKind(String value) {
  switch (value) {
    case r'BUILD':
      return Enum$CiJobKind.BUILD;
    case r'BRIDGE':
      return Enum$CiJobKind.BRIDGE;
    default:
      return Enum$CiJobKind.$unknown;
  }
}

enum Enum$CiJobStatus {
  CREATED,
  WAITING_FOR_RESOURCE,
  PREPARING,
  PENDING,
  RUNNING,
  SUCCESS,
  FAILED,
  CANCELED,
  SKIPPED,
  MANUAL,
  SCHEDULED,
  $unknown
}

String toJson$Enum$CiJobStatus(Enum$CiJobStatus e) {
  switch (e) {
    case Enum$CiJobStatus.CREATED:
      return r'CREATED';
    case Enum$CiJobStatus.WAITING_FOR_RESOURCE:
      return r'WAITING_FOR_RESOURCE';
    case Enum$CiJobStatus.PREPARING:
      return r'PREPARING';
    case Enum$CiJobStatus.PENDING:
      return r'PENDING';
    case Enum$CiJobStatus.RUNNING:
      return r'RUNNING';
    case Enum$CiJobStatus.SUCCESS:
      return r'SUCCESS';
    case Enum$CiJobStatus.FAILED:
      return r'FAILED';
    case Enum$CiJobStatus.CANCELED:
      return r'CANCELED';
    case Enum$CiJobStatus.SKIPPED:
      return r'SKIPPED';
    case Enum$CiJobStatus.MANUAL:
      return r'MANUAL';
    case Enum$CiJobStatus.SCHEDULED:
      return r'SCHEDULED';
    case Enum$CiJobStatus.$unknown:
      return r'$unknown';
  }
}

Enum$CiJobStatus fromJson$Enum$CiJobStatus(String value) {
  switch (value) {
    case r'CREATED':
      return Enum$CiJobStatus.CREATED;
    case r'WAITING_FOR_RESOURCE':
      return Enum$CiJobStatus.WAITING_FOR_RESOURCE;
    case r'PREPARING':
      return Enum$CiJobStatus.PREPARING;
    case r'PENDING':
      return Enum$CiJobStatus.PENDING;
    case r'RUNNING':
      return Enum$CiJobStatus.RUNNING;
    case r'SUCCESS':
      return Enum$CiJobStatus.SUCCESS;
    case r'FAILED':
      return Enum$CiJobStatus.FAILED;
    case r'CANCELED':
      return Enum$CiJobStatus.CANCELED;
    case r'SKIPPED':
      return Enum$CiJobStatus.SKIPPED;
    case r'MANUAL':
      return Enum$CiJobStatus.MANUAL;
    case r'SCHEDULED':
      return Enum$CiJobStatus.SCHEDULED;
    default:
      return Enum$CiJobStatus.$unknown;
  }
}

enum Enum$CiRunnerAccessLevel { NOT_PROTECTED, REF_PROTECTED, $unknown }

String toJson$Enum$CiRunnerAccessLevel(Enum$CiRunnerAccessLevel e) {
  switch (e) {
    case Enum$CiRunnerAccessLevel.NOT_PROTECTED:
      return r'NOT_PROTECTED';
    case Enum$CiRunnerAccessLevel.REF_PROTECTED:
      return r'REF_PROTECTED';
    case Enum$CiRunnerAccessLevel.$unknown:
      return r'$unknown';
  }
}

Enum$CiRunnerAccessLevel fromJson$Enum$CiRunnerAccessLevel(String value) {
  switch (value) {
    case r'NOT_PROTECTED':
      return Enum$CiRunnerAccessLevel.NOT_PROTECTED;
    case r'REF_PROTECTED':
      return Enum$CiRunnerAccessLevel.REF_PROTECTED;
    default:
      return Enum$CiRunnerAccessLevel.$unknown;
  }
}

enum Enum$CiRunnerSort {
  CONTACTED_ASC,
  CONTACTED_DESC,
  CREATED_ASC,
  CREATED_DESC,
  TOKEN_EXPIRES_AT_ASC,
  TOKEN_EXPIRES_AT_DESC,
  $unknown
}

String toJson$Enum$CiRunnerSort(Enum$CiRunnerSort e) {
  switch (e) {
    case Enum$CiRunnerSort.CONTACTED_ASC:
      return r'CONTACTED_ASC';
    case Enum$CiRunnerSort.CONTACTED_DESC:
      return r'CONTACTED_DESC';
    case Enum$CiRunnerSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$CiRunnerSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$CiRunnerSort.TOKEN_EXPIRES_AT_ASC:
      return r'TOKEN_EXPIRES_AT_ASC';
    case Enum$CiRunnerSort.TOKEN_EXPIRES_AT_DESC:
      return r'TOKEN_EXPIRES_AT_DESC';
    case Enum$CiRunnerSort.$unknown:
      return r'$unknown';
  }
}

Enum$CiRunnerSort fromJson$Enum$CiRunnerSort(String value) {
  switch (value) {
    case r'CONTACTED_ASC':
      return Enum$CiRunnerSort.CONTACTED_ASC;
    case r'CONTACTED_DESC':
      return Enum$CiRunnerSort.CONTACTED_DESC;
    case r'CREATED_ASC':
      return Enum$CiRunnerSort.CREATED_ASC;
    case r'CREATED_DESC':
      return Enum$CiRunnerSort.CREATED_DESC;
    case r'TOKEN_EXPIRES_AT_ASC':
      return Enum$CiRunnerSort.TOKEN_EXPIRES_AT_ASC;
    case r'TOKEN_EXPIRES_AT_DESC':
      return Enum$CiRunnerSort.TOKEN_EXPIRES_AT_DESC;
    default:
      return Enum$CiRunnerSort.$unknown;
  }
}

enum Enum$CiRunnerStatus {
  ACTIVE,
  PAUSED,
  ONLINE,
  OFFLINE,
  STALE,
  NEVER_CONTACTED,
  $unknown
}

String toJson$Enum$CiRunnerStatus(Enum$CiRunnerStatus e) {
  switch (e) {
    case Enum$CiRunnerStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$CiRunnerStatus.PAUSED:
      return r'PAUSED';
    case Enum$CiRunnerStatus.ONLINE:
      return r'ONLINE';
    case Enum$CiRunnerStatus.OFFLINE:
      return r'OFFLINE';
    case Enum$CiRunnerStatus.STALE:
      return r'STALE';
    case Enum$CiRunnerStatus.NEVER_CONTACTED:
      return r'NEVER_CONTACTED';
    case Enum$CiRunnerStatus.$unknown:
      return r'$unknown';
  }
}

Enum$CiRunnerStatus fromJson$Enum$CiRunnerStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$CiRunnerStatus.ACTIVE;
    case r'PAUSED':
      return Enum$CiRunnerStatus.PAUSED;
    case r'ONLINE':
      return Enum$CiRunnerStatus.ONLINE;
    case r'OFFLINE':
      return Enum$CiRunnerStatus.OFFLINE;
    case r'STALE':
      return Enum$CiRunnerStatus.STALE;
    case r'NEVER_CONTACTED':
      return Enum$CiRunnerStatus.NEVER_CONTACTED;
    default:
      return Enum$CiRunnerStatus.$unknown;
  }
}

enum Enum$CiRunnerType { INSTANCE_TYPE, GROUP_TYPE, PROJECT_TYPE, $unknown }

String toJson$Enum$CiRunnerType(Enum$CiRunnerType e) {
  switch (e) {
    case Enum$CiRunnerType.INSTANCE_TYPE:
      return r'INSTANCE_TYPE';
    case Enum$CiRunnerType.GROUP_TYPE:
      return r'GROUP_TYPE';
    case Enum$CiRunnerType.PROJECT_TYPE:
      return r'PROJECT_TYPE';
    case Enum$CiRunnerType.$unknown:
      return r'$unknown';
  }
}

Enum$CiRunnerType fromJson$Enum$CiRunnerType(String value) {
  switch (value) {
    case r'INSTANCE_TYPE':
      return Enum$CiRunnerType.INSTANCE_TYPE;
    case r'GROUP_TYPE':
      return Enum$CiRunnerType.GROUP_TYPE;
    case r'PROJECT_TYPE':
      return Enum$CiRunnerType.PROJECT_TYPE;
    default:
      return Enum$CiRunnerType.$unknown;
  }
}

enum Enum$CiRunnerUpgradeStatus {
  INVALID,
  NOT_AVAILABLE,
  AVAILABLE,
  RECOMMENDED,
  $unknown
}

String toJson$Enum$CiRunnerUpgradeStatus(Enum$CiRunnerUpgradeStatus e) {
  switch (e) {
    case Enum$CiRunnerUpgradeStatus.INVALID:
      return r'INVALID';
    case Enum$CiRunnerUpgradeStatus.NOT_AVAILABLE:
      return r'NOT_AVAILABLE';
    case Enum$CiRunnerUpgradeStatus.AVAILABLE:
      return r'AVAILABLE';
    case Enum$CiRunnerUpgradeStatus.RECOMMENDED:
      return r'RECOMMENDED';
    case Enum$CiRunnerUpgradeStatus.$unknown:
      return r'$unknown';
  }
}

Enum$CiRunnerUpgradeStatus fromJson$Enum$CiRunnerUpgradeStatus(String value) {
  switch (value) {
    case r'INVALID':
      return Enum$CiRunnerUpgradeStatus.INVALID;
    case r'NOT_AVAILABLE':
      return Enum$CiRunnerUpgradeStatus.NOT_AVAILABLE;
    case r'AVAILABLE':
      return Enum$CiRunnerUpgradeStatus.AVAILABLE;
    case r'RECOMMENDED':
      return Enum$CiRunnerUpgradeStatus.RECOMMENDED;
    default:
      return Enum$CiRunnerUpgradeStatus.$unknown;
  }
}

enum Enum$CiVariableType { ENV_VAR, FILE, $unknown }

String toJson$Enum$CiVariableType(Enum$CiVariableType e) {
  switch (e) {
    case Enum$CiVariableType.ENV_VAR:
      return r'ENV_VAR';
    case Enum$CiVariableType.FILE:
      return r'FILE';
    case Enum$CiVariableType.$unknown:
      return r'$unknown';
  }
}

Enum$CiVariableType fromJson$Enum$CiVariableType(String value) {
  switch (value) {
    case r'ENV_VAR':
      return Enum$CiVariableType.ENV_VAR;
    case r'FILE':
      return Enum$CiVariableType.FILE;
    default:
      return Enum$CiVariableType.$unknown;
  }
}

enum Enum$CodeQualityDegradationSeverity {
  BLOCKER,
  CRITICAL,
  MAJOR,
  MINOR,
  INFO,
  UNKNOWN,
  $unknown
}

String toJson$Enum$CodeQualityDegradationSeverity(
    Enum$CodeQualityDegradationSeverity e) {
  switch (e) {
    case Enum$CodeQualityDegradationSeverity.BLOCKER:
      return r'BLOCKER';
    case Enum$CodeQualityDegradationSeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$CodeQualityDegradationSeverity.MAJOR:
      return r'MAJOR';
    case Enum$CodeQualityDegradationSeverity.MINOR:
      return r'MINOR';
    case Enum$CodeQualityDegradationSeverity.INFO:
      return r'INFO';
    case Enum$CodeQualityDegradationSeverity.UNKNOWN:
      return r'UNKNOWN';
    case Enum$CodeQualityDegradationSeverity.$unknown:
      return r'$unknown';
  }
}

Enum$CodeQualityDegradationSeverity
    fromJson$Enum$CodeQualityDegradationSeverity(String value) {
  switch (value) {
    case r'BLOCKER':
      return Enum$CodeQualityDegradationSeverity.BLOCKER;
    case r'CRITICAL':
      return Enum$CodeQualityDegradationSeverity.CRITICAL;
    case r'MAJOR':
      return Enum$CodeQualityDegradationSeverity.MAJOR;
    case r'MINOR':
      return Enum$CodeQualityDegradationSeverity.MINOR;
    case r'INFO':
      return Enum$CodeQualityDegradationSeverity.INFO;
    case r'UNKNOWN':
      return Enum$CodeQualityDegradationSeverity.UNKNOWN;
    default:
      return Enum$CodeQualityDegradationSeverity.$unknown;
  }
}

enum Enum$CommitActionMode { CREATE, DELETE, MOVE, UPDATE, CHMOD, $unknown }

String toJson$Enum$CommitActionMode(Enum$CommitActionMode e) {
  switch (e) {
    case Enum$CommitActionMode.CREATE:
      return r'CREATE';
    case Enum$CommitActionMode.DELETE:
      return r'DELETE';
    case Enum$CommitActionMode.MOVE:
      return r'MOVE';
    case Enum$CommitActionMode.UPDATE:
      return r'UPDATE';
    case Enum$CommitActionMode.CHMOD:
      return r'CHMOD';
    case Enum$CommitActionMode.$unknown:
      return r'$unknown';
  }
}

Enum$CommitActionMode fromJson$Enum$CommitActionMode(String value) {
  switch (value) {
    case r'CREATE':
      return Enum$CommitActionMode.CREATE;
    case r'DELETE':
      return Enum$CommitActionMode.DELETE;
    case r'MOVE':
      return Enum$CommitActionMode.MOVE;
    case r'UPDATE':
      return Enum$CommitActionMode.UPDATE;
    case r'CHMOD':
      return Enum$CommitActionMode.CHMOD;
    default:
      return Enum$CommitActionMode.$unknown;
  }
}

enum Enum$CommitEncoding { TEXT, BASE64, $unknown }

String toJson$Enum$CommitEncoding(Enum$CommitEncoding e) {
  switch (e) {
    case Enum$CommitEncoding.TEXT:
      return r'TEXT';
    case Enum$CommitEncoding.BASE64:
      return r'BASE64';
    case Enum$CommitEncoding.$unknown:
      return r'$unknown';
  }
}

Enum$CommitEncoding fromJson$Enum$CommitEncoding(String value) {
  switch (value) {
    case r'TEXT':
      return Enum$CommitEncoding.TEXT;
    case r'BASE64':
      return Enum$CommitEncoding.BASE64;
    default:
      return Enum$CommitEncoding.$unknown;
  }
}

enum Enum$ComplianceViolationReason {
  APPROVED_BY_MERGE_REQUEST_AUTHOR,
  APPROVED_BY_COMMITTER,
  APPROVED_BY_INSUFFICIENT_USERS,
  $unknown
}

String toJson$Enum$ComplianceViolationReason(Enum$ComplianceViolationReason e) {
  switch (e) {
    case Enum$ComplianceViolationReason.APPROVED_BY_MERGE_REQUEST_AUTHOR:
      return r'APPROVED_BY_MERGE_REQUEST_AUTHOR';
    case Enum$ComplianceViolationReason.APPROVED_BY_COMMITTER:
      return r'APPROVED_BY_COMMITTER';
    case Enum$ComplianceViolationReason.APPROVED_BY_INSUFFICIENT_USERS:
      return r'APPROVED_BY_INSUFFICIENT_USERS';
    case Enum$ComplianceViolationReason.$unknown:
      return r'$unknown';
  }
}

Enum$ComplianceViolationReason fromJson$Enum$ComplianceViolationReason(
    String value) {
  switch (value) {
    case r'APPROVED_BY_MERGE_REQUEST_AUTHOR':
      return Enum$ComplianceViolationReason.APPROVED_BY_MERGE_REQUEST_AUTHOR;
    case r'APPROVED_BY_COMMITTER':
      return Enum$ComplianceViolationReason.APPROVED_BY_COMMITTER;
    case r'APPROVED_BY_INSUFFICIENT_USERS':
      return Enum$ComplianceViolationReason.APPROVED_BY_INSUFFICIENT_USERS;
    default:
      return Enum$ComplianceViolationReason.$unknown;
  }
}

enum Enum$ComplianceViolationSeverity {
  INFO,
  LOW,
  MEDIUM,
  HIGH,
  CRITICAL,
  $unknown
}

String toJson$Enum$ComplianceViolationSeverity(
    Enum$ComplianceViolationSeverity e) {
  switch (e) {
    case Enum$ComplianceViolationSeverity.INFO:
      return r'INFO';
    case Enum$ComplianceViolationSeverity.LOW:
      return r'LOW';
    case Enum$ComplianceViolationSeverity.MEDIUM:
      return r'MEDIUM';
    case Enum$ComplianceViolationSeverity.HIGH:
      return r'HIGH';
    case Enum$ComplianceViolationSeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$ComplianceViolationSeverity.$unknown:
      return r'$unknown';
  }
}

Enum$ComplianceViolationSeverity fromJson$Enum$ComplianceViolationSeverity(
    String value) {
  switch (value) {
    case r'INFO':
      return Enum$ComplianceViolationSeverity.INFO;
    case r'LOW':
      return Enum$ComplianceViolationSeverity.LOW;
    case r'MEDIUM':
      return Enum$ComplianceViolationSeverity.MEDIUM;
    case r'HIGH':
      return Enum$ComplianceViolationSeverity.HIGH;
    case r'CRITICAL':
      return Enum$ComplianceViolationSeverity.CRITICAL;
    default:
      return Enum$ComplianceViolationSeverity.$unknown;
  }
}

enum Enum$ComplianceViolationSort {
  SEVERITY_LEVEL_DESC,
  SEVERITY_LEVEL_ASC,
  VIOLATION_REASON_DESC,
  VIOLATION_REASON_ASC,
  MERGE_REQUEST_TITLE_DESC,
  MERGE_REQUEST_TITLE_ASC,
  MERGED_AT_DESC,
  MERGED_AT_ASC,
  $unknown
}

String toJson$Enum$ComplianceViolationSort(Enum$ComplianceViolationSort e) {
  switch (e) {
    case Enum$ComplianceViolationSort.SEVERITY_LEVEL_DESC:
      return r'SEVERITY_LEVEL_DESC';
    case Enum$ComplianceViolationSort.SEVERITY_LEVEL_ASC:
      return r'SEVERITY_LEVEL_ASC';
    case Enum$ComplianceViolationSort.VIOLATION_REASON_DESC:
      return r'VIOLATION_REASON_DESC';
    case Enum$ComplianceViolationSort.VIOLATION_REASON_ASC:
      return r'VIOLATION_REASON_ASC';
    case Enum$ComplianceViolationSort.MERGE_REQUEST_TITLE_DESC:
      return r'MERGE_REQUEST_TITLE_DESC';
    case Enum$ComplianceViolationSort.MERGE_REQUEST_TITLE_ASC:
      return r'MERGE_REQUEST_TITLE_ASC';
    case Enum$ComplianceViolationSort.MERGED_AT_DESC:
      return r'MERGED_AT_DESC';
    case Enum$ComplianceViolationSort.MERGED_AT_ASC:
      return r'MERGED_AT_ASC';
    case Enum$ComplianceViolationSort.$unknown:
      return r'$unknown';
  }
}

Enum$ComplianceViolationSort fromJson$Enum$ComplianceViolationSort(
    String value) {
  switch (value) {
    case r'SEVERITY_LEVEL_DESC':
      return Enum$ComplianceViolationSort.SEVERITY_LEVEL_DESC;
    case r'SEVERITY_LEVEL_ASC':
      return Enum$ComplianceViolationSort.SEVERITY_LEVEL_ASC;
    case r'VIOLATION_REASON_DESC':
      return Enum$ComplianceViolationSort.VIOLATION_REASON_DESC;
    case r'VIOLATION_REASON_ASC':
      return Enum$ComplianceViolationSort.VIOLATION_REASON_ASC;
    case r'MERGE_REQUEST_TITLE_DESC':
      return Enum$ComplianceViolationSort.MERGE_REQUEST_TITLE_DESC;
    case r'MERGE_REQUEST_TITLE_ASC':
      return Enum$ComplianceViolationSort.MERGE_REQUEST_TITLE_ASC;
    case r'MERGED_AT_DESC':
      return Enum$ComplianceViolationSort.MERGED_AT_DESC;
    case r'MERGED_AT_ASC':
      return Enum$ComplianceViolationSort.MERGED_AT_ASC;
    default:
      return Enum$ComplianceViolationSort.$unknown;
  }
}

enum Enum$ConanMetadatumFileTypeEnum { RECIPE_FILE, PACKAGE_FILE, $unknown }

String toJson$Enum$ConanMetadatumFileTypeEnum(
    Enum$ConanMetadatumFileTypeEnum e) {
  switch (e) {
    case Enum$ConanMetadatumFileTypeEnum.RECIPE_FILE:
      return r'RECIPE_FILE';
    case Enum$ConanMetadatumFileTypeEnum.PACKAGE_FILE:
      return r'PACKAGE_FILE';
    case Enum$ConanMetadatumFileTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ConanMetadatumFileTypeEnum fromJson$Enum$ConanMetadatumFileTypeEnum(
    String value) {
  switch (value) {
    case r'RECIPE_FILE':
      return Enum$ConanMetadatumFileTypeEnum.RECIPE_FILE;
    case r'PACKAGE_FILE':
      return Enum$ConanMetadatumFileTypeEnum.PACKAGE_FILE;
    default:
      return Enum$ConanMetadatumFileTypeEnum.$unknown;
  }
}

enum Enum$ContactSort {
  FIRST_NAME_ASC,
  FIRST_NAME_DESC,
  LAST_NAME_ASC,
  LAST_NAME_DESC,
  EMAIL_ASC,
  EMAIL_DESC,
  PHONE_ASC,
  PHONE_DESC,
  DESCRIPTION_ASC,
  DESCRIPTION_DESC,
  ORGANIZATION_ASC,
  ORGANIZATION_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$ContactSort(Enum$ContactSort e) {
  switch (e) {
    case Enum$ContactSort.FIRST_NAME_ASC:
      return r'FIRST_NAME_ASC';
    case Enum$ContactSort.FIRST_NAME_DESC:
      return r'FIRST_NAME_DESC';
    case Enum$ContactSort.LAST_NAME_ASC:
      return r'LAST_NAME_ASC';
    case Enum$ContactSort.LAST_NAME_DESC:
      return r'LAST_NAME_DESC';
    case Enum$ContactSort.EMAIL_ASC:
      return r'EMAIL_ASC';
    case Enum$ContactSort.EMAIL_DESC:
      return r'EMAIL_DESC';
    case Enum$ContactSort.PHONE_ASC:
      return r'PHONE_ASC';
    case Enum$ContactSort.PHONE_DESC:
      return r'PHONE_DESC';
    case Enum$ContactSort.DESCRIPTION_ASC:
      return r'DESCRIPTION_ASC';
    case Enum$ContactSort.DESCRIPTION_DESC:
      return r'DESCRIPTION_DESC';
    case Enum$ContactSort.ORGANIZATION_ASC:
      return r'ORGANIZATION_ASC';
    case Enum$ContactSort.ORGANIZATION_DESC:
      return r'ORGANIZATION_DESC';
    case Enum$ContactSort.updated_desc:
      return r'updated_desc';
    case Enum$ContactSort.updated_asc:
      return r'updated_asc';
    case Enum$ContactSort.created_desc:
      return r'created_desc';
    case Enum$ContactSort.created_asc:
      return r'created_asc';
    case Enum$ContactSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$ContactSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$ContactSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$ContactSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$ContactSort.$unknown:
      return r'$unknown';
  }
}

Enum$ContactSort fromJson$Enum$ContactSort(String value) {
  switch (value) {
    case r'FIRST_NAME_ASC':
      return Enum$ContactSort.FIRST_NAME_ASC;
    case r'FIRST_NAME_DESC':
      return Enum$ContactSort.FIRST_NAME_DESC;
    case r'LAST_NAME_ASC':
      return Enum$ContactSort.LAST_NAME_ASC;
    case r'LAST_NAME_DESC':
      return Enum$ContactSort.LAST_NAME_DESC;
    case r'EMAIL_ASC':
      return Enum$ContactSort.EMAIL_ASC;
    case r'EMAIL_DESC':
      return Enum$ContactSort.EMAIL_DESC;
    case r'PHONE_ASC':
      return Enum$ContactSort.PHONE_ASC;
    case r'PHONE_DESC':
      return Enum$ContactSort.PHONE_DESC;
    case r'DESCRIPTION_ASC':
      return Enum$ContactSort.DESCRIPTION_ASC;
    case r'DESCRIPTION_DESC':
      return Enum$ContactSort.DESCRIPTION_DESC;
    case r'ORGANIZATION_ASC':
      return Enum$ContactSort.ORGANIZATION_ASC;
    case r'ORGANIZATION_DESC':
      return Enum$ContactSort.ORGANIZATION_DESC;
    case r'updated_desc':
      return Enum$ContactSort.updated_desc;
    case r'updated_asc':
      return Enum$ContactSort.updated_asc;
    case r'created_desc':
      return Enum$ContactSort.created_desc;
    case r'created_asc':
      return Enum$ContactSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$ContactSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$ContactSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$ContactSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$ContactSort.CREATED_ASC;
    default:
      return Enum$ContactSort.$unknown;
  }
}

enum Enum$ContainerExpirationPolicyCadenceEnum {
  EVERY_DAY,
  EVERY_WEEK,
  EVERY_TWO_WEEKS,
  EVERY_MONTH,
  EVERY_THREE_MONTHS,
  $unknown
}

String toJson$Enum$ContainerExpirationPolicyCadenceEnum(
    Enum$ContainerExpirationPolicyCadenceEnum e) {
  switch (e) {
    case Enum$ContainerExpirationPolicyCadenceEnum.EVERY_DAY:
      return r'EVERY_DAY';
    case Enum$ContainerExpirationPolicyCadenceEnum.EVERY_WEEK:
      return r'EVERY_WEEK';
    case Enum$ContainerExpirationPolicyCadenceEnum.EVERY_TWO_WEEKS:
      return r'EVERY_TWO_WEEKS';
    case Enum$ContainerExpirationPolicyCadenceEnum.EVERY_MONTH:
      return r'EVERY_MONTH';
    case Enum$ContainerExpirationPolicyCadenceEnum.EVERY_THREE_MONTHS:
      return r'EVERY_THREE_MONTHS';
    case Enum$ContainerExpirationPolicyCadenceEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerExpirationPolicyCadenceEnum
    fromJson$Enum$ContainerExpirationPolicyCadenceEnum(String value) {
  switch (value) {
    case r'EVERY_DAY':
      return Enum$ContainerExpirationPolicyCadenceEnum.EVERY_DAY;
    case r'EVERY_WEEK':
      return Enum$ContainerExpirationPolicyCadenceEnum.EVERY_WEEK;
    case r'EVERY_TWO_WEEKS':
      return Enum$ContainerExpirationPolicyCadenceEnum.EVERY_TWO_WEEKS;
    case r'EVERY_MONTH':
      return Enum$ContainerExpirationPolicyCadenceEnum.EVERY_MONTH;
    case r'EVERY_THREE_MONTHS':
      return Enum$ContainerExpirationPolicyCadenceEnum.EVERY_THREE_MONTHS;
    default:
      return Enum$ContainerExpirationPolicyCadenceEnum.$unknown;
  }
}

enum Enum$ContainerExpirationPolicyKeepEnum {
  ONE_TAG,
  FIVE_TAGS,
  TEN_TAGS,
  TWENTY_FIVE_TAGS,
  FIFTY_TAGS,
  ONE_HUNDRED_TAGS,
  $unknown
}

String toJson$Enum$ContainerExpirationPolicyKeepEnum(
    Enum$ContainerExpirationPolicyKeepEnum e) {
  switch (e) {
    case Enum$ContainerExpirationPolicyKeepEnum.ONE_TAG:
      return r'ONE_TAG';
    case Enum$ContainerExpirationPolicyKeepEnum.FIVE_TAGS:
      return r'FIVE_TAGS';
    case Enum$ContainerExpirationPolicyKeepEnum.TEN_TAGS:
      return r'TEN_TAGS';
    case Enum$ContainerExpirationPolicyKeepEnum.TWENTY_FIVE_TAGS:
      return r'TWENTY_FIVE_TAGS';
    case Enum$ContainerExpirationPolicyKeepEnum.FIFTY_TAGS:
      return r'FIFTY_TAGS';
    case Enum$ContainerExpirationPolicyKeepEnum.ONE_HUNDRED_TAGS:
      return r'ONE_HUNDRED_TAGS';
    case Enum$ContainerExpirationPolicyKeepEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerExpirationPolicyKeepEnum
    fromJson$Enum$ContainerExpirationPolicyKeepEnum(String value) {
  switch (value) {
    case r'ONE_TAG':
      return Enum$ContainerExpirationPolicyKeepEnum.ONE_TAG;
    case r'FIVE_TAGS':
      return Enum$ContainerExpirationPolicyKeepEnum.FIVE_TAGS;
    case r'TEN_TAGS':
      return Enum$ContainerExpirationPolicyKeepEnum.TEN_TAGS;
    case r'TWENTY_FIVE_TAGS':
      return Enum$ContainerExpirationPolicyKeepEnum.TWENTY_FIVE_TAGS;
    case r'FIFTY_TAGS':
      return Enum$ContainerExpirationPolicyKeepEnum.FIFTY_TAGS;
    case r'ONE_HUNDRED_TAGS':
      return Enum$ContainerExpirationPolicyKeepEnum.ONE_HUNDRED_TAGS;
    default:
      return Enum$ContainerExpirationPolicyKeepEnum.$unknown;
  }
}

enum Enum$ContainerExpirationPolicyOlderThanEnum {
  SEVEN_DAYS,
  FOURTEEN_DAYS,
  THIRTY_DAYS,
  SIXTY_DAYS,
  NINETY_DAYS,
  $unknown
}

String toJson$Enum$ContainerExpirationPolicyOlderThanEnum(
    Enum$ContainerExpirationPolicyOlderThanEnum e) {
  switch (e) {
    case Enum$ContainerExpirationPolicyOlderThanEnum.SEVEN_DAYS:
      return r'SEVEN_DAYS';
    case Enum$ContainerExpirationPolicyOlderThanEnum.FOURTEEN_DAYS:
      return r'FOURTEEN_DAYS';
    case Enum$ContainerExpirationPolicyOlderThanEnum.THIRTY_DAYS:
      return r'THIRTY_DAYS';
    case Enum$ContainerExpirationPolicyOlderThanEnum.SIXTY_DAYS:
      return r'SIXTY_DAYS';
    case Enum$ContainerExpirationPolicyOlderThanEnum.NINETY_DAYS:
      return r'NINETY_DAYS';
    case Enum$ContainerExpirationPolicyOlderThanEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerExpirationPolicyOlderThanEnum
    fromJson$Enum$ContainerExpirationPolicyOlderThanEnum(String value) {
  switch (value) {
    case r'SEVEN_DAYS':
      return Enum$ContainerExpirationPolicyOlderThanEnum.SEVEN_DAYS;
    case r'FOURTEEN_DAYS':
      return Enum$ContainerExpirationPolicyOlderThanEnum.FOURTEEN_DAYS;
    case r'THIRTY_DAYS':
      return Enum$ContainerExpirationPolicyOlderThanEnum.THIRTY_DAYS;
    case r'SIXTY_DAYS':
      return Enum$ContainerExpirationPolicyOlderThanEnum.SIXTY_DAYS;
    case r'NINETY_DAYS':
      return Enum$ContainerExpirationPolicyOlderThanEnum.NINETY_DAYS;
    default:
      return Enum$ContainerExpirationPolicyOlderThanEnum.$unknown;
  }
}

enum Enum$ContainerRepositoryCleanupStatus {
  UNSCHEDULED,
  SCHEDULED,
  UNFINISHED,
  ONGOING,
  $unknown
}

String toJson$Enum$ContainerRepositoryCleanupStatus(
    Enum$ContainerRepositoryCleanupStatus e) {
  switch (e) {
    case Enum$ContainerRepositoryCleanupStatus.UNSCHEDULED:
      return r'UNSCHEDULED';
    case Enum$ContainerRepositoryCleanupStatus.SCHEDULED:
      return r'SCHEDULED';
    case Enum$ContainerRepositoryCleanupStatus.UNFINISHED:
      return r'UNFINISHED';
    case Enum$ContainerRepositoryCleanupStatus.ONGOING:
      return r'ONGOING';
    case Enum$ContainerRepositoryCleanupStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerRepositoryCleanupStatus
    fromJson$Enum$ContainerRepositoryCleanupStatus(String value) {
  switch (value) {
    case r'UNSCHEDULED':
      return Enum$ContainerRepositoryCleanupStatus.UNSCHEDULED;
    case r'SCHEDULED':
      return Enum$ContainerRepositoryCleanupStatus.SCHEDULED;
    case r'UNFINISHED':
      return Enum$ContainerRepositoryCleanupStatus.UNFINISHED;
    case r'ONGOING':
      return Enum$ContainerRepositoryCleanupStatus.ONGOING;
    default:
      return Enum$ContainerRepositoryCleanupStatus.$unknown;
  }
}

enum Enum$ContainerRepositorySort {
  NAME_ASC,
  NAME_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$ContainerRepositorySort(Enum$ContainerRepositorySort e) {
  switch (e) {
    case Enum$ContainerRepositorySort.NAME_ASC:
      return r'NAME_ASC';
    case Enum$ContainerRepositorySort.NAME_DESC:
      return r'NAME_DESC';
    case Enum$ContainerRepositorySort.updated_desc:
      return r'updated_desc';
    case Enum$ContainerRepositorySort.updated_asc:
      return r'updated_asc';
    case Enum$ContainerRepositorySort.created_desc:
      return r'created_desc';
    case Enum$ContainerRepositorySort.created_asc:
      return r'created_asc';
    case Enum$ContainerRepositorySort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$ContainerRepositorySort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$ContainerRepositorySort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$ContainerRepositorySort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$ContainerRepositorySort.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerRepositorySort fromJson$Enum$ContainerRepositorySort(
    String value) {
  switch (value) {
    case r'NAME_ASC':
      return Enum$ContainerRepositorySort.NAME_ASC;
    case r'NAME_DESC':
      return Enum$ContainerRepositorySort.NAME_DESC;
    case r'updated_desc':
      return Enum$ContainerRepositorySort.updated_desc;
    case r'updated_asc':
      return Enum$ContainerRepositorySort.updated_asc;
    case r'created_desc':
      return Enum$ContainerRepositorySort.created_desc;
    case r'created_asc':
      return Enum$ContainerRepositorySort.created_asc;
    case r'UPDATED_DESC':
      return Enum$ContainerRepositorySort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$ContainerRepositorySort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$ContainerRepositorySort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$ContainerRepositorySort.CREATED_ASC;
    default:
      return Enum$ContainerRepositorySort.$unknown;
  }
}

enum Enum$ContainerRepositoryStatus {
  DELETE_SCHEDULED,
  DELETE_FAILED,
  $unknown
}

String toJson$Enum$ContainerRepositoryStatus(Enum$ContainerRepositoryStatus e) {
  switch (e) {
    case Enum$ContainerRepositoryStatus.DELETE_SCHEDULED:
      return r'DELETE_SCHEDULED';
    case Enum$ContainerRepositoryStatus.DELETE_FAILED:
      return r'DELETE_FAILED';
    case Enum$ContainerRepositoryStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerRepositoryStatus fromJson$Enum$ContainerRepositoryStatus(
    String value) {
  switch (value) {
    case r'DELETE_SCHEDULED':
      return Enum$ContainerRepositoryStatus.DELETE_SCHEDULED;
    case r'DELETE_FAILED':
      return Enum$ContainerRepositoryStatus.DELETE_FAILED;
    default:
      return Enum$ContainerRepositoryStatus.$unknown;
  }
}

enum Enum$ContainerRepositoryTagSort { NAME_ASC, NAME_DESC, $unknown }

String toJson$Enum$ContainerRepositoryTagSort(
    Enum$ContainerRepositoryTagSort e) {
  switch (e) {
    case Enum$ContainerRepositoryTagSort.NAME_ASC:
      return r'NAME_ASC';
    case Enum$ContainerRepositoryTagSort.NAME_DESC:
      return r'NAME_DESC';
    case Enum$ContainerRepositoryTagSort.$unknown:
      return r'$unknown';
  }
}

Enum$ContainerRepositoryTagSort fromJson$Enum$ContainerRepositoryTagSort(
    String value) {
  switch (value) {
    case r'NAME_ASC':
      return Enum$ContainerRepositoryTagSort.NAME_ASC;
    case r'NAME_DESC':
      return Enum$ContainerRepositoryTagSort.NAME_DESC;
    default:
      return Enum$ContainerRepositoryTagSort.$unknown;
  }
}

enum Enum$CustomerRelationsContactState { all, active, inactive, $unknown }

String toJson$Enum$CustomerRelationsContactState(
    Enum$CustomerRelationsContactState e) {
  switch (e) {
    case Enum$CustomerRelationsContactState.all:
      return r'all';
    case Enum$CustomerRelationsContactState.active:
      return r'active';
    case Enum$CustomerRelationsContactState.inactive:
      return r'inactive';
    case Enum$CustomerRelationsContactState.$unknown:
      return r'$unknown';
  }
}

Enum$CustomerRelationsContactState fromJson$Enum$CustomerRelationsContactState(
    String value) {
  switch (value) {
    case r'all':
      return Enum$CustomerRelationsContactState.all;
    case r'active':
      return Enum$CustomerRelationsContactState.active;
    case r'inactive':
      return Enum$CustomerRelationsContactState.inactive;
    default:
      return Enum$CustomerRelationsContactState.$unknown;
  }
}

enum Enum$CustomerRelationsOrganizationState { all, active, inactive, $unknown }

String toJson$Enum$CustomerRelationsOrganizationState(
    Enum$CustomerRelationsOrganizationState e) {
  switch (e) {
    case Enum$CustomerRelationsOrganizationState.all:
      return r'all';
    case Enum$CustomerRelationsOrganizationState.active:
      return r'active';
    case Enum$CustomerRelationsOrganizationState.inactive:
      return r'inactive';
    case Enum$CustomerRelationsOrganizationState.$unknown:
      return r'$unknown';
  }
}

Enum$CustomerRelationsOrganizationState
    fromJson$Enum$CustomerRelationsOrganizationState(String value) {
  switch (value) {
    case r'all':
      return Enum$CustomerRelationsOrganizationState.all;
    case r'active':
      return Enum$CustomerRelationsOrganizationState.active;
    case r'inactive':
      return Enum$CustomerRelationsOrganizationState.inactive;
    default:
      return Enum$CustomerRelationsOrganizationState.$unknown;
  }
}

enum Enum$DastProfileCadenceUnit { DAY, WEEK, MONTH, YEAR, $unknown }

String toJson$Enum$DastProfileCadenceUnit(Enum$DastProfileCadenceUnit e) {
  switch (e) {
    case Enum$DastProfileCadenceUnit.DAY:
      return r'DAY';
    case Enum$DastProfileCadenceUnit.WEEK:
      return r'WEEK';
    case Enum$DastProfileCadenceUnit.MONTH:
      return r'MONTH';
    case Enum$DastProfileCadenceUnit.YEAR:
      return r'YEAR';
    case Enum$DastProfileCadenceUnit.$unknown:
      return r'$unknown';
  }
}

Enum$DastProfileCadenceUnit fromJson$Enum$DastProfileCadenceUnit(String value) {
  switch (value) {
    case r'DAY':
      return Enum$DastProfileCadenceUnit.DAY;
    case r'WEEK':
      return Enum$DastProfileCadenceUnit.WEEK;
    case r'MONTH':
      return Enum$DastProfileCadenceUnit.MONTH;
    case r'YEAR':
      return Enum$DastProfileCadenceUnit.YEAR;
    default:
      return Enum$DastProfileCadenceUnit.$unknown;
  }
}

enum Enum$DastScanMethodType {
  WEBSITE,
  OPENAPI,
  HAR,
  POSTMAN_COLLECTION,
  $unknown
}

String toJson$Enum$DastScanMethodType(Enum$DastScanMethodType e) {
  switch (e) {
    case Enum$DastScanMethodType.WEBSITE:
      return r'WEBSITE';
    case Enum$DastScanMethodType.OPENAPI:
      return r'OPENAPI';
    case Enum$DastScanMethodType.HAR:
      return r'HAR';
    case Enum$DastScanMethodType.POSTMAN_COLLECTION:
      return r'POSTMAN_COLLECTION';
    case Enum$DastScanMethodType.$unknown:
      return r'$unknown';
  }
}

Enum$DastScanMethodType fromJson$Enum$DastScanMethodType(String value) {
  switch (value) {
    case r'WEBSITE':
      return Enum$DastScanMethodType.WEBSITE;
    case r'OPENAPI':
      return Enum$DastScanMethodType.OPENAPI;
    case r'HAR':
      return Enum$DastScanMethodType.HAR;
    case r'POSTMAN_COLLECTION':
      return Enum$DastScanMethodType.POSTMAN_COLLECTION;
    default:
      return Enum$DastScanMethodType.$unknown;
  }
}

enum Enum$DastScanTypeEnum { PASSIVE, ACTIVE, $unknown }

String toJson$Enum$DastScanTypeEnum(Enum$DastScanTypeEnum e) {
  switch (e) {
    case Enum$DastScanTypeEnum.PASSIVE:
      return r'PASSIVE';
    case Enum$DastScanTypeEnum.ACTIVE:
      return r'ACTIVE';
    case Enum$DastScanTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DastScanTypeEnum fromJson$Enum$DastScanTypeEnum(String value) {
  switch (value) {
    case r'PASSIVE':
      return Enum$DastScanTypeEnum.PASSIVE;
    case r'ACTIVE':
      return Enum$DastScanTypeEnum.ACTIVE;
    default:
      return Enum$DastScanTypeEnum.$unknown;
  }
}

enum Enum$DastSiteProfileValidationStatusEnum {
  NONE,
  PENDING_VALIDATION,
  INPROGRESS_VALIDATION,
  PASSED_VALIDATION,
  FAILED_VALIDATION,
  $unknown
}

String toJson$Enum$DastSiteProfileValidationStatusEnum(
    Enum$DastSiteProfileValidationStatusEnum e) {
  switch (e) {
    case Enum$DastSiteProfileValidationStatusEnum.NONE:
      return r'NONE';
    case Enum$DastSiteProfileValidationStatusEnum.PENDING_VALIDATION:
      return r'PENDING_VALIDATION';
    case Enum$DastSiteProfileValidationStatusEnum.INPROGRESS_VALIDATION:
      return r'INPROGRESS_VALIDATION';
    case Enum$DastSiteProfileValidationStatusEnum.PASSED_VALIDATION:
      return r'PASSED_VALIDATION';
    case Enum$DastSiteProfileValidationStatusEnum.FAILED_VALIDATION:
      return r'FAILED_VALIDATION';
    case Enum$DastSiteProfileValidationStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DastSiteProfileValidationStatusEnum
    fromJson$Enum$DastSiteProfileValidationStatusEnum(String value) {
  switch (value) {
    case r'NONE':
      return Enum$DastSiteProfileValidationStatusEnum.NONE;
    case r'PENDING_VALIDATION':
      return Enum$DastSiteProfileValidationStatusEnum.PENDING_VALIDATION;
    case r'INPROGRESS_VALIDATION':
      return Enum$DastSiteProfileValidationStatusEnum.INPROGRESS_VALIDATION;
    case r'PASSED_VALIDATION':
      return Enum$DastSiteProfileValidationStatusEnum.PASSED_VALIDATION;
    case r'FAILED_VALIDATION':
      return Enum$DastSiteProfileValidationStatusEnum.FAILED_VALIDATION;
    default:
      return Enum$DastSiteProfileValidationStatusEnum.$unknown;
  }
}

enum Enum$DastSiteValidationStatusEnum {
  PENDING_VALIDATION,
  INPROGRESS_VALIDATION,
  PASSED_VALIDATION,
  FAILED_VALIDATION,
  $unknown
}

String toJson$Enum$DastSiteValidationStatusEnum(
    Enum$DastSiteValidationStatusEnum e) {
  switch (e) {
    case Enum$DastSiteValidationStatusEnum.PENDING_VALIDATION:
      return r'PENDING_VALIDATION';
    case Enum$DastSiteValidationStatusEnum.INPROGRESS_VALIDATION:
      return r'INPROGRESS_VALIDATION';
    case Enum$DastSiteValidationStatusEnum.PASSED_VALIDATION:
      return r'PASSED_VALIDATION';
    case Enum$DastSiteValidationStatusEnum.FAILED_VALIDATION:
      return r'FAILED_VALIDATION';
    case Enum$DastSiteValidationStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DastSiteValidationStatusEnum fromJson$Enum$DastSiteValidationStatusEnum(
    String value) {
  switch (value) {
    case r'PENDING_VALIDATION':
      return Enum$DastSiteValidationStatusEnum.PENDING_VALIDATION;
    case r'INPROGRESS_VALIDATION':
      return Enum$DastSiteValidationStatusEnum.INPROGRESS_VALIDATION;
    case r'PASSED_VALIDATION':
      return Enum$DastSiteValidationStatusEnum.PASSED_VALIDATION;
    case r'FAILED_VALIDATION':
      return Enum$DastSiteValidationStatusEnum.FAILED_VALIDATION;
    default:
      return Enum$DastSiteValidationStatusEnum.$unknown;
  }
}

enum Enum$DastSiteValidationStrategyEnum {
  TEXT_FILE,
  HEADER,
  META_TAG,
  $unknown
}

String toJson$Enum$DastSiteValidationStrategyEnum(
    Enum$DastSiteValidationStrategyEnum e) {
  switch (e) {
    case Enum$DastSiteValidationStrategyEnum.TEXT_FILE:
      return r'TEXT_FILE';
    case Enum$DastSiteValidationStrategyEnum.HEADER:
      return r'HEADER';
    case Enum$DastSiteValidationStrategyEnum.META_TAG:
      return r'META_TAG';
    case Enum$DastSiteValidationStrategyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DastSiteValidationStrategyEnum
    fromJson$Enum$DastSiteValidationStrategyEnum(String value) {
  switch (value) {
    case r'TEXT_FILE':
      return Enum$DastSiteValidationStrategyEnum.TEXT_FILE;
    case r'HEADER':
      return Enum$DastSiteValidationStrategyEnum.HEADER;
    case r'META_TAG':
      return Enum$DastSiteValidationStrategyEnum.META_TAG;
    default:
      return Enum$DastSiteValidationStrategyEnum.$unknown;
  }
}

enum Enum$DastTargetTypeEnum { WEBSITE, API, $unknown }

String toJson$Enum$DastTargetTypeEnum(Enum$DastTargetTypeEnum e) {
  switch (e) {
    case Enum$DastTargetTypeEnum.WEBSITE:
      return r'WEBSITE';
    case Enum$DastTargetTypeEnum.API:
      return r'API';
    case Enum$DastTargetTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DastTargetTypeEnum fromJson$Enum$DastTargetTypeEnum(String value) {
  switch (value) {
    case r'WEBSITE':
      return Enum$DastTargetTypeEnum.WEBSITE;
    case r'API':
      return Enum$DastTargetTypeEnum.API;
    default:
      return Enum$DastTargetTypeEnum.$unknown;
  }
}

enum Enum$DataVisualizationColorEnum {
  BLUE,
  ORANGE,
  AQUA,
  GREEN,
  MAGENTA,
  $unknown
}

String toJson$Enum$DataVisualizationColorEnum(
    Enum$DataVisualizationColorEnum e) {
  switch (e) {
    case Enum$DataVisualizationColorEnum.BLUE:
      return r'BLUE';
    case Enum$DataVisualizationColorEnum.ORANGE:
      return r'ORANGE';
    case Enum$DataVisualizationColorEnum.AQUA:
      return r'AQUA';
    case Enum$DataVisualizationColorEnum.GREEN:
      return r'GREEN';
    case Enum$DataVisualizationColorEnum.MAGENTA:
      return r'MAGENTA';
    case Enum$DataVisualizationColorEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DataVisualizationColorEnum fromJson$Enum$DataVisualizationColorEnum(
    String value) {
  switch (value) {
    case r'BLUE':
      return Enum$DataVisualizationColorEnum.BLUE;
    case r'ORANGE':
      return Enum$DataVisualizationColorEnum.ORANGE;
    case r'AQUA':
      return Enum$DataVisualizationColorEnum.AQUA;
    case r'GREEN':
      return Enum$DataVisualizationColorEnum.GREEN;
    case r'MAGENTA':
      return Enum$DataVisualizationColorEnum.MAGENTA;
    default:
      return Enum$DataVisualizationColorEnum.$unknown;
  }
}

enum Enum$DataVisualizationWeightEnum {
  WEIGHT_50,
  WEIGHT_100,
  WEIGHT_200,
  WEIGHT_300,
  WEIGHT_400,
  WEIGHT_500,
  WEIGHT_600,
  WEIGHT_700,
  WEIGHT_800,
  WEIGHT_900,
  WEIGHT_950,
  $unknown
}

String toJson$Enum$DataVisualizationWeightEnum(
    Enum$DataVisualizationWeightEnum e) {
  switch (e) {
    case Enum$DataVisualizationWeightEnum.WEIGHT_50:
      return r'WEIGHT_50';
    case Enum$DataVisualizationWeightEnum.WEIGHT_100:
      return r'WEIGHT_100';
    case Enum$DataVisualizationWeightEnum.WEIGHT_200:
      return r'WEIGHT_200';
    case Enum$DataVisualizationWeightEnum.WEIGHT_300:
      return r'WEIGHT_300';
    case Enum$DataVisualizationWeightEnum.WEIGHT_400:
      return r'WEIGHT_400';
    case Enum$DataVisualizationWeightEnum.WEIGHT_500:
      return r'WEIGHT_500';
    case Enum$DataVisualizationWeightEnum.WEIGHT_600:
      return r'WEIGHT_600';
    case Enum$DataVisualizationWeightEnum.WEIGHT_700:
      return r'WEIGHT_700';
    case Enum$DataVisualizationWeightEnum.WEIGHT_800:
      return r'WEIGHT_800';
    case Enum$DataVisualizationWeightEnum.WEIGHT_900:
      return r'WEIGHT_900';
    case Enum$DataVisualizationWeightEnum.WEIGHT_950:
      return r'WEIGHT_950';
    case Enum$DataVisualizationWeightEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DataVisualizationWeightEnum fromJson$Enum$DataVisualizationWeightEnum(
    String value) {
  switch (value) {
    case r'WEIGHT_50':
      return Enum$DataVisualizationWeightEnum.WEIGHT_50;
    case r'WEIGHT_100':
      return Enum$DataVisualizationWeightEnum.WEIGHT_100;
    case r'WEIGHT_200':
      return Enum$DataVisualizationWeightEnum.WEIGHT_200;
    case r'WEIGHT_300':
      return Enum$DataVisualizationWeightEnum.WEIGHT_300;
    case r'WEIGHT_400':
      return Enum$DataVisualizationWeightEnum.WEIGHT_400;
    case r'WEIGHT_500':
      return Enum$DataVisualizationWeightEnum.WEIGHT_500;
    case r'WEIGHT_600':
      return Enum$DataVisualizationWeightEnum.WEIGHT_600;
    case r'WEIGHT_700':
      return Enum$DataVisualizationWeightEnum.WEIGHT_700;
    case r'WEIGHT_800':
      return Enum$DataVisualizationWeightEnum.WEIGHT_800;
    case r'WEIGHT_900':
      return Enum$DataVisualizationWeightEnum.WEIGHT_900;
    case r'WEIGHT_950':
      return Enum$DataVisualizationWeightEnum.WEIGHT_950;
    default:
      return Enum$DataVisualizationWeightEnum.$unknown;
  }
}

enum Enum$DependencyProxyManifestStatus {
  DEFAULT,
  PENDING_DESTRUCTION,
  PROCESSING,
  ERROR,
  $unknown
}

String toJson$Enum$DependencyProxyManifestStatus(
    Enum$DependencyProxyManifestStatus e) {
  switch (e) {
    case Enum$DependencyProxyManifestStatus.DEFAULT:
      return r'DEFAULT';
    case Enum$DependencyProxyManifestStatus.PENDING_DESTRUCTION:
      return r'PENDING_DESTRUCTION';
    case Enum$DependencyProxyManifestStatus.PROCESSING:
      return r'PROCESSING';
    case Enum$DependencyProxyManifestStatus.ERROR:
      return r'ERROR';
    case Enum$DependencyProxyManifestStatus.$unknown:
      return r'$unknown';
  }
}

Enum$DependencyProxyManifestStatus fromJson$Enum$DependencyProxyManifestStatus(
    String value) {
  switch (value) {
    case r'DEFAULT':
      return Enum$DependencyProxyManifestStatus.DEFAULT;
    case r'PENDING_DESTRUCTION':
      return Enum$DependencyProxyManifestStatus.PENDING_DESTRUCTION;
    case r'PROCESSING':
      return Enum$DependencyProxyManifestStatus.PROCESSING;
    case r'ERROR':
      return Enum$DependencyProxyManifestStatus.ERROR;
    default:
      return Enum$DependencyProxyManifestStatus.$unknown;
  }
}

enum Enum$DeploymentStatus {
  CREATED,
  RUNNING,
  SUCCESS,
  FAILED,
  CANCELED,
  SKIPPED,
  BLOCKED,
  $unknown
}

String toJson$Enum$DeploymentStatus(Enum$DeploymentStatus e) {
  switch (e) {
    case Enum$DeploymentStatus.CREATED:
      return r'CREATED';
    case Enum$DeploymentStatus.RUNNING:
      return r'RUNNING';
    case Enum$DeploymentStatus.SUCCESS:
      return r'SUCCESS';
    case Enum$DeploymentStatus.FAILED:
      return r'FAILED';
    case Enum$DeploymentStatus.CANCELED:
      return r'CANCELED';
    case Enum$DeploymentStatus.SKIPPED:
      return r'SKIPPED';
    case Enum$DeploymentStatus.BLOCKED:
      return r'BLOCKED';
    case Enum$DeploymentStatus.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentStatus fromJson$Enum$DeploymentStatus(String value) {
  switch (value) {
    case r'CREATED':
      return Enum$DeploymentStatus.CREATED;
    case r'RUNNING':
      return Enum$DeploymentStatus.RUNNING;
    case r'SUCCESS':
      return Enum$DeploymentStatus.SUCCESS;
    case r'FAILED':
      return Enum$DeploymentStatus.FAILED;
    case r'CANCELED':
      return Enum$DeploymentStatus.CANCELED;
    case r'SKIPPED':
      return Enum$DeploymentStatus.SKIPPED;
    case r'BLOCKED':
      return Enum$DeploymentStatus.BLOCKED;
    default:
      return Enum$DeploymentStatus.$unknown;
  }
}

enum Enum$DeploymentTier {
  PRODUCTION,
  STAGING,
  TESTING,
  DEVELOPMENT,
  OTHER,
  $unknown
}

String toJson$Enum$DeploymentTier(Enum$DeploymentTier e) {
  switch (e) {
    case Enum$DeploymentTier.PRODUCTION:
      return r'PRODUCTION';
    case Enum$DeploymentTier.STAGING:
      return r'STAGING';
    case Enum$DeploymentTier.TESTING:
      return r'TESTING';
    case Enum$DeploymentTier.DEVELOPMENT:
      return r'DEVELOPMENT';
    case Enum$DeploymentTier.OTHER:
      return r'OTHER';
    case Enum$DeploymentTier.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentTier fromJson$Enum$DeploymentTier(String value) {
  switch (value) {
    case r'PRODUCTION':
      return Enum$DeploymentTier.PRODUCTION;
    case r'STAGING':
      return Enum$DeploymentTier.STAGING;
    case r'TESTING':
      return Enum$DeploymentTier.TESTING;
    case r'DEVELOPMENT':
      return Enum$DeploymentTier.DEVELOPMENT;
    case r'OTHER':
      return Enum$DeploymentTier.OTHER;
    default:
      return Enum$DeploymentTier.$unknown;
  }
}

enum Enum$DesignCollectionCopyState { READY, IN_PROGRESS, ERROR, $unknown }

String toJson$Enum$DesignCollectionCopyState(Enum$DesignCollectionCopyState e) {
  switch (e) {
    case Enum$DesignCollectionCopyState.READY:
      return r'READY';
    case Enum$DesignCollectionCopyState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DesignCollectionCopyState.ERROR:
      return r'ERROR';
    case Enum$DesignCollectionCopyState.$unknown:
      return r'$unknown';
  }
}

Enum$DesignCollectionCopyState fromJson$Enum$DesignCollectionCopyState(
    String value) {
  switch (value) {
    case r'READY':
      return Enum$DesignCollectionCopyState.READY;
    case r'IN_PROGRESS':
      return Enum$DesignCollectionCopyState.IN_PROGRESS;
    case r'ERROR':
      return Enum$DesignCollectionCopyState.ERROR;
    default:
      return Enum$DesignCollectionCopyState.$unknown;
  }
}

enum Enum$DesignVersionEvent {
  NONE,
  CREATION,
  MODIFICATION,
  DELETION,
  $unknown
}

String toJson$Enum$DesignVersionEvent(Enum$DesignVersionEvent e) {
  switch (e) {
    case Enum$DesignVersionEvent.NONE:
      return r'NONE';
    case Enum$DesignVersionEvent.CREATION:
      return r'CREATION';
    case Enum$DesignVersionEvent.MODIFICATION:
      return r'MODIFICATION';
    case Enum$DesignVersionEvent.DELETION:
      return r'DELETION';
    case Enum$DesignVersionEvent.$unknown:
      return r'$unknown';
  }
}

Enum$DesignVersionEvent fromJson$Enum$DesignVersionEvent(String value) {
  switch (value) {
    case r'NONE':
      return Enum$DesignVersionEvent.NONE;
    case r'CREATION':
      return Enum$DesignVersionEvent.CREATION;
    case r'MODIFICATION':
      return Enum$DesignVersionEvent.MODIFICATION;
    case r'DELETION':
      return Enum$DesignVersionEvent.DELETION;
    default:
      return Enum$DesignVersionEvent.$unknown;
  }
}

enum Enum$DetailedMergeStatus {
  UNCHECKED,
  CHECKING,
  MERGEABLE,
  BROKEN_STATUS,
  CI_MUST_PASS,
  DISCUSSIONS_NOT_RESOLVED,
  DRAFT_STATUS,
  NOT_OPEN,
  NOT_APPROVED,
  BLOCKED_STATUS,
  POLICIES_DENIED,
  $unknown
}

String toJson$Enum$DetailedMergeStatus(Enum$DetailedMergeStatus e) {
  switch (e) {
    case Enum$DetailedMergeStatus.UNCHECKED:
      return r'UNCHECKED';
    case Enum$DetailedMergeStatus.CHECKING:
      return r'CHECKING';
    case Enum$DetailedMergeStatus.MERGEABLE:
      return r'MERGEABLE';
    case Enum$DetailedMergeStatus.BROKEN_STATUS:
      return r'BROKEN_STATUS';
    case Enum$DetailedMergeStatus.CI_MUST_PASS:
      return r'CI_MUST_PASS';
    case Enum$DetailedMergeStatus.DISCUSSIONS_NOT_RESOLVED:
      return r'DISCUSSIONS_NOT_RESOLVED';
    case Enum$DetailedMergeStatus.DRAFT_STATUS:
      return r'DRAFT_STATUS';
    case Enum$DetailedMergeStatus.NOT_OPEN:
      return r'NOT_OPEN';
    case Enum$DetailedMergeStatus.NOT_APPROVED:
      return r'NOT_APPROVED';
    case Enum$DetailedMergeStatus.BLOCKED_STATUS:
      return r'BLOCKED_STATUS';
    case Enum$DetailedMergeStatus.POLICIES_DENIED:
      return r'POLICIES_DENIED';
    case Enum$DetailedMergeStatus.$unknown:
      return r'$unknown';
  }
}

Enum$DetailedMergeStatus fromJson$Enum$DetailedMergeStatus(String value) {
  switch (value) {
    case r'UNCHECKED':
      return Enum$DetailedMergeStatus.UNCHECKED;
    case r'CHECKING':
      return Enum$DetailedMergeStatus.CHECKING;
    case r'MERGEABLE':
      return Enum$DetailedMergeStatus.MERGEABLE;
    case r'BROKEN_STATUS':
      return Enum$DetailedMergeStatus.BROKEN_STATUS;
    case r'CI_MUST_PASS':
      return Enum$DetailedMergeStatus.CI_MUST_PASS;
    case r'DISCUSSIONS_NOT_RESOLVED':
      return Enum$DetailedMergeStatus.DISCUSSIONS_NOT_RESOLVED;
    case r'DRAFT_STATUS':
      return Enum$DetailedMergeStatus.DRAFT_STATUS;
    case r'NOT_OPEN':
      return Enum$DetailedMergeStatus.NOT_OPEN;
    case r'NOT_APPROVED':
      return Enum$DetailedMergeStatus.NOT_APPROVED;
    case r'BLOCKED_STATUS':
      return Enum$DetailedMergeStatus.BLOCKED_STATUS;
    case r'POLICIES_DENIED':
      return Enum$DetailedMergeStatus.POLICIES_DENIED;
    default:
      return Enum$DetailedMergeStatus.$unknown;
  }
}

enum Enum$DiffPositionType { text, image, $unknown }

String toJson$Enum$DiffPositionType(Enum$DiffPositionType e) {
  switch (e) {
    case Enum$DiffPositionType.text:
      return r'text';
    case Enum$DiffPositionType.image:
      return r'image';
    case Enum$DiffPositionType.$unknown:
      return r'$unknown';
  }
}

Enum$DiffPositionType fromJson$Enum$DiffPositionType(String value) {
  switch (value) {
    case r'text':
      return Enum$DiffPositionType.text;
    case r'image':
      return Enum$DiffPositionType.image;
    default:
      return Enum$DiffPositionType.$unknown;
  }
}

enum Enum$DoraMetricBucketingInterval { ALL, MONTHLY, DAILY, $unknown }

String toJson$Enum$DoraMetricBucketingInterval(
    Enum$DoraMetricBucketingInterval e) {
  switch (e) {
    case Enum$DoraMetricBucketingInterval.ALL:
      return r'ALL';
    case Enum$DoraMetricBucketingInterval.MONTHLY:
      return r'MONTHLY';
    case Enum$DoraMetricBucketingInterval.DAILY:
      return r'DAILY';
    case Enum$DoraMetricBucketingInterval.$unknown:
      return r'$unknown';
  }
}

Enum$DoraMetricBucketingInterval fromJson$Enum$DoraMetricBucketingInterval(
    String value) {
  switch (value) {
    case r'ALL':
      return Enum$DoraMetricBucketingInterval.ALL;
    case r'MONTHLY':
      return Enum$DoraMetricBucketingInterval.MONTHLY;
    case r'DAILY':
      return Enum$DoraMetricBucketingInterval.DAILY;
    default:
      return Enum$DoraMetricBucketingInterval.$unknown;
  }
}

enum Enum$DoraMetricType {
  DEPLOYMENT_FREQUENCY,
  LEAD_TIME_FOR_CHANGES,
  TIME_TO_RESTORE_SERVICE,
  CHANGE_FAILURE_RATE,
  $unknown
}

String toJson$Enum$DoraMetricType(Enum$DoraMetricType e) {
  switch (e) {
    case Enum$DoraMetricType.DEPLOYMENT_FREQUENCY:
      return r'DEPLOYMENT_FREQUENCY';
    case Enum$DoraMetricType.LEAD_TIME_FOR_CHANGES:
      return r'LEAD_TIME_FOR_CHANGES';
    case Enum$DoraMetricType.TIME_TO_RESTORE_SERVICE:
      return r'TIME_TO_RESTORE_SERVICE';
    case Enum$DoraMetricType.CHANGE_FAILURE_RATE:
      return r'CHANGE_FAILURE_RATE';
    case Enum$DoraMetricType.$unknown:
      return r'$unknown';
  }
}

Enum$DoraMetricType fromJson$Enum$DoraMetricType(String value) {
  switch (value) {
    case r'DEPLOYMENT_FREQUENCY':
      return Enum$DoraMetricType.DEPLOYMENT_FREQUENCY;
    case r'LEAD_TIME_FOR_CHANGES':
      return Enum$DoraMetricType.LEAD_TIME_FOR_CHANGES;
    case r'TIME_TO_RESTORE_SERVICE':
      return Enum$DoraMetricType.TIME_TO_RESTORE_SERVICE;
    case r'CHANGE_FAILURE_RATE':
      return Enum$DoraMetricType.CHANGE_FAILURE_RATE;
    default:
      return Enum$DoraMetricType.$unknown;
  }
}

enum Enum$EntryType { tree, blob, commit, $unknown }

String toJson$Enum$EntryType(Enum$EntryType e) {
  switch (e) {
    case Enum$EntryType.tree:
      return r'tree';
    case Enum$EntryType.blob:
      return r'blob';
    case Enum$EntryType.commit:
      return r'commit';
    case Enum$EntryType.$unknown:
      return r'$unknown';
  }
}

Enum$EntryType fromJson$Enum$EntryType(String value) {
  switch (value) {
    case r'tree':
      return Enum$EntryType.tree;
    case r'blob':
      return Enum$EntryType.blob;
    case r'commit':
      return Enum$EntryType.commit;
    default:
      return Enum$EntryType.$unknown;
  }
}

enum Enum$EpicSort {
  start_date_desc,
  start_date_asc,
  end_date_desc,
  end_date_asc,
  START_DATE_DESC,
  START_DATE_ASC,
  END_DATE_DESC,
  END_DATE_ASC,
  TITLE_DESC,
  TITLE_ASC,
  CREATED_AT_ASC,
  CREATED_AT_DESC,
  UPDATED_AT_ASC,
  UPDATED_AT_DESC,
  $unknown
}

String toJson$Enum$EpicSort(Enum$EpicSort e) {
  switch (e) {
    case Enum$EpicSort.start_date_desc:
      return r'start_date_desc';
    case Enum$EpicSort.start_date_asc:
      return r'start_date_asc';
    case Enum$EpicSort.end_date_desc:
      return r'end_date_desc';
    case Enum$EpicSort.end_date_asc:
      return r'end_date_asc';
    case Enum$EpicSort.START_DATE_DESC:
      return r'START_DATE_DESC';
    case Enum$EpicSort.START_DATE_ASC:
      return r'START_DATE_ASC';
    case Enum$EpicSort.END_DATE_DESC:
      return r'END_DATE_DESC';
    case Enum$EpicSort.END_DATE_ASC:
      return r'END_DATE_ASC';
    case Enum$EpicSort.TITLE_DESC:
      return r'TITLE_DESC';
    case Enum$EpicSort.TITLE_ASC:
      return r'TITLE_ASC';
    case Enum$EpicSort.CREATED_AT_ASC:
      return r'CREATED_AT_ASC';
    case Enum$EpicSort.CREATED_AT_DESC:
      return r'CREATED_AT_DESC';
    case Enum$EpicSort.UPDATED_AT_ASC:
      return r'UPDATED_AT_ASC';
    case Enum$EpicSort.UPDATED_AT_DESC:
      return r'UPDATED_AT_DESC';
    case Enum$EpicSort.$unknown:
      return r'$unknown';
  }
}

Enum$EpicSort fromJson$Enum$EpicSort(String value) {
  switch (value) {
    case r'start_date_desc':
      return Enum$EpicSort.start_date_desc;
    case r'start_date_asc':
      return Enum$EpicSort.start_date_asc;
    case r'end_date_desc':
      return Enum$EpicSort.end_date_desc;
    case r'end_date_asc':
      return Enum$EpicSort.end_date_asc;
    case r'START_DATE_DESC':
      return Enum$EpicSort.START_DATE_DESC;
    case r'START_DATE_ASC':
      return Enum$EpicSort.START_DATE_ASC;
    case r'END_DATE_DESC':
      return Enum$EpicSort.END_DATE_DESC;
    case r'END_DATE_ASC':
      return Enum$EpicSort.END_DATE_ASC;
    case r'TITLE_DESC':
      return Enum$EpicSort.TITLE_DESC;
    case r'TITLE_ASC':
      return Enum$EpicSort.TITLE_ASC;
    case r'CREATED_AT_ASC':
      return Enum$EpicSort.CREATED_AT_ASC;
    case r'CREATED_AT_DESC':
      return Enum$EpicSort.CREATED_AT_DESC;
    case r'UPDATED_AT_ASC':
      return Enum$EpicSort.UPDATED_AT_ASC;
    case r'UPDATED_AT_DESC':
      return Enum$EpicSort.UPDATED_AT_DESC;
    default:
      return Enum$EpicSort.$unknown;
  }
}

enum Enum$EpicState { all, opened, closed, $unknown }

String toJson$Enum$EpicState(Enum$EpicState e) {
  switch (e) {
    case Enum$EpicState.all:
      return r'all';
    case Enum$EpicState.opened:
      return r'opened';
    case Enum$EpicState.closed:
      return r'closed';
    case Enum$EpicState.$unknown:
      return r'$unknown';
  }
}

Enum$EpicState fromJson$Enum$EpicState(String value) {
  switch (value) {
    case r'all':
      return Enum$EpicState.all;
    case r'opened':
      return Enum$EpicState.opened;
    case r'closed':
      return Enum$EpicState.closed;
    default:
      return Enum$EpicState.$unknown;
  }
}

enum Enum$EpicStateEvent { REOPEN, CLOSE, $unknown }

String toJson$Enum$EpicStateEvent(Enum$EpicStateEvent e) {
  switch (e) {
    case Enum$EpicStateEvent.REOPEN:
      return r'REOPEN';
    case Enum$EpicStateEvent.CLOSE:
      return r'CLOSE';
    case Enum$EpicStateEvent.$unknown:
      return r'$unknown';
  }
}

Enum$EpicStateEvent fromJson$Enum$EpicStateEvent(String value) {
  switch (value) {
    case r'REOPEN':
      return Enum$EpicStateEvent.REOPEN;
    case r'CLOSE':
      return Enum$EpicStateEvent.CLOSE;
    default:
      return Enum$EpicStateEvent.$unknown;
  }
}

enum Enum$EpicWildcardId { NONE, ANY, $unknown }

String toJson$Enum$EpicWildcardId(Enum$EpicWildcardId e) {
  switch (e) {
    case Enum$EpicWildcardId.NONE:
      return r'NONE';
    case Enum$EpicWildcardId.ANY:
      return r'ANY';
    case Enum$EpicWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$EpicWildcardId fromJson$Enum$EpicWildcardId(String value) {
  switch (value) {
    case r'NONE':
      return Enum$EpicWildcardId.NONE;
    case r'ANY':
      return Enum$EpicWildcardId.ANY;
    default:
      return Enum$EpicWildcardId.$unknown;
  }
}

enum Enum$EscalationRuleStatus { ACKNOWLEDGED, RESOLVED, $unknown }

String toJson$Enum$EscalationRuleStatus(Enum$EscalationRuleStatus e) {
  switch (e) {
    case Enum$EscalationRuleStatus.ACKNOWLEDGED:
      return r'ACKNOWLEDGED';
    case Enum$EscalationRuleStatus.RESOLVED:
      return r'RESOLVED';
    case Enum$EscalationRuleStatus.$unknown:
      return r'$unknown';
  }
}

Enum$EscalationRuleStatus fromJson$Enum$EscalationRuleStatus(String value) {
  switch (value) {
    case r'ACKNOWLEDGED':
      return Enum$EscalationRuleStatus.ACKNOWLEDGED;
    case r'RESOLVED':
      return Enum$EscalationRuleStatus.RESOLVED;
    default:
      return Enum$EscalationRuleStatus.$unknown;
  }
}

enum Enum$EventAction {
  CREATED,
  UPDATED,
  CLOSED,
  REOPENED,
  PUSHED,
  COMMENTED,
  MERGED,
  JOINED,
  LEFT,
  DESTROYED,
  EXPIRED,
  APPROVED,
  $unknown
}

String toJson$Enum$EventAction(Enum$EventAction e) {
  switch (e) {
    case Enum$EventAction.CREATED:
      return r'CREATED';
    case Enum$EventAction.UPDATED:
      return r'UPDATED';
    case Enum$EventAction.CLOSED:
      return r'CLOSED';
    case Enum$EventAction.REOPENED:
      return r'REOPENED';
    case Enum$EventAction.PUSHED:
      return r'PUSHED';
    case Enum$EventAction.COMMENTED:
      return r'COMMENTED';
    case Enum$EventAction.MERGED:
      return r'MERGED';
    case Enum$EventAction.JOINED:
      return r'JOINED';
    case Enum$EventAction.LEFT:
      return r'LEFT';
    case Enum$EventAction.DESTROYED:
      return r'DESTROYED';
    case Enum$EventAction.EXPIRED:
      return r'EXPIRED';
    case Enum$EventAction.APPROVED:
      return r'APPROVED';
    case Enum$EventAction.$unknown:
      return r'$unknown';
  }
}

Enum$EventAction fromJson$Enum$EventAction(String value) {
  switch (value) {
    case r'CREATED':
      return Enum$EventAction.CREATED;
    case r'UPDATED':
      return Enum$EventAction.UPDATED;
    case r'CLOSED':
      return Enum$EventAction.CLOSED;
    case r'REOPENED':
      return Enum$EventAction.REOPENED;
    case r'PUSHED':
      return Enum$EventAction.PUSHED;
    case r'COMMENTED':
      return Enum$EventAction.COMMENTED;
    case r'MERGED':
      return Enum$EventAction.MERGED;
    case r'JOINED':
      return Enum$EventAction.JOINED;
    case r'LEFT':
      return Enum$EventAction.LEFT;
    case r'DESTROYED':
      return Enum$EventAction.DESTROYED;
    case r'EXPIRED':
      return Enum$EventAction.EXPIRED;
    case r'APPROVED':
      return Enum$EventAction.APPROVED;
    default:
      return Enum$EventAction.$unknown;
  }
}

enum Enum$GroupMemberRelation {
  DIRECT,
  INHERITED,
  DESCENDANTS,
  SHARED_FROM_GROUPS,
  $unknown
}

String toJson$Enum$GroupMemberRelation(Enum$GroupMemberRelation e) {
  switch (e) {
    case Enum$GroupMemberRelation.DIRECT:
      return r'DIRECT';
    case Enum$GroupMemberRelation.INHERITED:
      return r'INHERITED';
    case Enum$GroupMemberRelation.DESCENDANTS:
      return r'DESCENDANTS';
    case Enum$GroupMemberRelation.SHARED_FROM_GROUPS:
      return r'SHARED_FROM_GROUPS';
    case Enum$GroupMemberRelation.$unknown:
      return r'$unknown';
  }
}

Enum$GroupMemberRelation fromJson$Enum$GroupMemberRelation(String value) {
  switch (value) {
    case r'DIRECT':
      return Enum$GroupMemberRelation.DIRECT;
    case r'INHERITED':
      return Enum$GroupMemberRelation.INHERITED;
    case r'DESCENDANTS':
      return Enum$GroupMemberRelation.DESCENDANTS;
    case r'SHARED_FROM_GROUPS':
      return Enum$GroupMemberRelation.SHARED_FROM_GROUPS;
    default:
      return Enum$GroupMemberRelation.$unknown;
  }
}

enum Enum$GroupPermission { CREATE_PROJECTS, TRANSFER_PROJECTS, $unknown }

String toJson$Enum$GroupPermission(Enum$GroupPermission e) {
  switch (e) {
    case Enum$GroupPermission.CREATE_PROJECTS:
      return r'CREATE_PROJECTS';
    case Enum$GroupPermission.TRANSFER_PROJECTS:
      return r'TRANSFER_PROJECTS';
    case Enum$GroupPermission.$unknown:
      return r'$unknown';
  }
}

Enum$GroupPermission fromJson$Enum$GroupPermission(String value) {
  switch (value) {
    case r'CREATE_PROJECTS':
      return Enum$GroupPermission.CREATE_PROJECTS;
    case r'TRANSFER_PROJECTS':
      return Enum$GroupPermission.TRANSFER_PROJECTS;
    default:
      return Enum$GroupPermission.$unknown;
  }
}

enum Enum$HealthStatus { onTrack, needsAttention, atRisk, $unknown }

String toJson$Enum$HealthStatus(Enum$HealthStatus e) {
  switch (e) {
    case Enum$HealthStatus.onTrack:
      return r'onTrack';
    case Enum$HealthStatus.needsAttention:
      return r'needsAttention';
    case Enum$HealthStatus.atRisk:
      return r'atRisk';
    case Enum$HealthStatus.$unknown:
      return r'$unknown';
  }
}

Enum$HealthStatus fromJson$Enum$HealthStatus(String value) {
  switch (value) {
    case r'onTrack':
      return Enum$HealthStatus.onTrack;
    case r'needsAttention':
      return Enum$HealthStatus.needsAttention;
    case r'atRisk':
      return Enum$HealthStatus.atRisk;
    default:
      return Enum$HealthStatus.$unknown;
  }
}

enum Enum$IssuableResourceLinkType { general, zoom, slack, $unknown }

String toJson$Enum$IssuableResourceLinkType(Enum$IssuableResourceLinkType e) {
  switch (e) {
    case Enum$IssuableResourceLinkType.general:
      return r'general';
    case Enum$IssuableResourceLinkType.zoom:
      return r'zoom';
    case Enum$IssuableResourceLinkType.slack:
      return r'slack';
    case Enum$IssuableResourceLinkType.$unknown:
      return r'$unknown';
  }
}

Enum$IssuableResourceLinkType fromJson$Enum$IssuableResourceLinkType(
    String value) {
  switch (value) {
    case r'general':
      return Enum$IssuableResourceLinkType.general;
    case r'zoom':
      return Enum$IssuableResourceLinkType.zoom;
    case r'slack':
      return Enum$IssuableResourceLinkType.slack;
    default:
      return Enum$IssuableResourceLinkType.$unknown;
  }
}

enum Enum$IssuableSearchableField { TITLE, DESCRIPTION, $unknown }

String toJson$Enum$IssuableSearchableField(Enum$IssuableSearchableField e) {
  switch (e) {
    case Enum$IssuableSearchableField.TITLE:
      return r'TITLE';
    case Enum$IssuableSearchableField.DESCRIPTION:
      return r'DESCRIPTION';
    case Enum$IssuableSearchableField.$unknown:
      return r'$unknown';
  }
}

Enum$IssuableSearchableField fromJson$Enum$IssuableSearchableField(
    String value) {
  switch (value) {
    case r'TITLE':
      return Enum$IssuableSearchableField.TITLE;
    case r'DESCRIPTION':
      return Enum$IssuableSearchableField.DESCRIPTION;
    default:
      return Enum$IssuableSearchableField.$unknown;
  }
}

enum Enum$IssuableSeverity { UNKNOWN, LOW, MEDIUM, HIGH, CRITICAL, $unknown }

String toJson$Enum$IssuableSeverity(Enum$IssuableSeverity e) {
  switch (e) {
    case Enum$IssuableSeverity.UNKNOWN:
      return r'UNKNOWN';
    case Enum$IssuableSeverity.LOW:
      return r'LOW';
    case Enum$IssuableSeverity.MEDIUM:
      return r'MEDIUM';
    case Enum$IssuableSeverity.HIGH:
      return r'HIGH';
    case Enum$IssuableSeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$IssuableSeverity.$unknown:
      return r'$unknown';
  }
}

Enum$IssuableSeverity fromJson$Enum$IssuableSeverity(String value) {
  switch (value) {
    case r'UNKNOWN':
      return Enum$IssuableSeverity.UNKNOWN;
    case r'LOW':
      return Enum$IssuableSeverity.LOW;
    case r'MEDIUM':
      return Enum$IssuableSeverity.MEDIUM;
    case r'HIGH':
      return Enum$IssuableSeverity.HIGH;
    case r'CRITICAL':
      return Enum$IssuableSeverity.CRITICAL;
    default:
      return Enum$IssuableSeverity.$unknown;
  }
}

enum Enum$IssuableState { opened, closed, locked, all, $unknown }

String toJson$Enum$IssuableState(Enum$IssuableState e) {
  switch (e) {
    case Enum$IssuableState.opened:
      return r'opened';
    case Enum$IssuableState.closed:
      return r'closed';
    case Enum$IssuableState.locked:
      return r'locked';
    case Enum$IssuableState.all:
      return r'all';
    case Enum$IssuableState.$unknown:
      return r'$unknown';
  }
}

Enum$IssuableState fromJson$Enum$IssuableState(String value) {
  switch (value) {
    case r'opened':
      return Enum$IssuableState.opened;
    case r'closed':
      return Enum$IssuableState.closed;
    case r'locked':
      return Enum$IssuableState.locked;
    case r'all':
      return Enum$IssuableState.all;
    default:
      return Enum$IssuableState.$unknown;
  }
}

enum Enum$IssueCreationIterationWildcardId { CURRENT, $unknown }

String toJson$Enum$IssueCreationIterationWildcardId(
    Enum$IssueCreationIterationWildcardId e) {
  switch (e) {
    case Enum$IssueCreationIterationWildcardId.CURRENT:
      return r'CURRENT';
    case Enum$IssueCreationIterationWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$IssueCreationIterationWildcardId
    fromJson$Enum$IssueCreationIterationWildcardId(String value) {
  switch (value) {
    case r'CURRENT':
      return Enum$IssueCreationIterationWildcardId.CURRENT;
    default:
      return Enum$IssueCreationIterationWildcardId.$unknown;
  }
}

enum Enum$IssueEscalationStatus {
  TRIGGERED,
  ACKNOWLEDGED,
  RESOLVED,
  IGNORED,
  $unknown
}

String toJson$Enum$IssueEscalationStatus(Enum$IssueEscalationStatus e) {
  switch (e) {
    case Enum$IssueEscalationStatus.TRIGGERED:
      return r'TRIGGERED';
    case Enum$IssueEscalationStatus.ACKNOWLEDGED:
      return r'ACKNOWLEDGED';
    case Enum$IssueEscalationStatus.RESOLVED:
      return r'RESOLVED';
    case Enum$IssueEscalationStatus.IGNORED:
      return r'IGNORED';
    case Enum$IssueEscalationStatus.$unknown:
      return r'$unknown';
  }
}

Enum$IssueEscalationStatus fromJson$Enum$IssueEscalationStatus(String value) {
  switch (value) {
    case r'TRIGGERED':
      return Enum$IssueEscalationStatus.TRIGGERED;
    case r'ACKNOWLEDGED':
      return Enum$IssueEscalationStatus.ACKNOWLEDGED;
    case r'RESOLVED':
      return Enum$IssueEscalationStatus.RESOLVED;
    case r'IGNORED':
      return Enum$IssueEscalationStatus.IGNORED;
    default:
      return Enum$IssueEscalationStatus.$unknown;
  }
}

enum Enum$IssueSort {
  DUE_DATE_ASC,
  DUE_DATE_DESC,
  RELATIVE_POSITION_ASC,
  SEVERITY_ASC,
  SEVERITY_DESC,
  TITLE_ASC,
  TITLE_DESC,
  POPULARITY_ASC,
  POPULARITY_DESC,
  ESCALATION_STATUS_ASC,
  ESCALATION_STATUS_DESC,
  CLOSED_AT_ASC,
  CLOSED_AT_DESC,
  WEIGHT_ASC,
  WEIGHT_DESC,
  PUBLISHED_ASC,
  PUBLISHED_DESC,
  SLA_DUE_AT_ASC,
  SLA_DUE_AT_DESC,
  BLOCKING_ISSUES_ASC,
  BLOCKING_ISSUES_DESC,
  PRIORITY_ASC,
  PRIORITY_DESC,
  LABEL_PRIORITY_ASC,
  LABEL_PRIORITY_DESC,
  MILESTONE_DUE_ASC,
  MILESTONE_DUE_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$IssueSort(Enum$IssueSort e) {
  switch (e) {
    case Enum$IssueSort.DUE_DATE_ASC:
      return r'DUE_DATE_ASC';
    case Enum$IssueSort.DUE_DATE_DESC:
      return r'DUE_DATE_DESC';
    case Enum$IssueSort.RELATIVE_POSITION_ASC:
      return r'RELATIVE_POSITION_ASC';
    case Enum$IssueSort.SEVERITY_ASC:
      return r'SEVERITY_ASC';
    case Enum$IssueSort.SEVERITY_DESC:
      return r'SEVERITY_DESC';
    case Enum$IssueSort.TITLE_ASC:
      return r'TITLE_ASC';
    case Enum$IssueSort.TITLE_DESC:
      return r'TITLE_DESC';
    case Enum$IssueSort.POPULARITY_ASC:
      return r'POPULARITY_ASC';
    case Enum$IssueSort.POPULARITY_DESC:
      return r'POPULARITY_DESC';
    case Enum$IssueSort.ESCALATION_STATUS_ASC:
      return r'ESCALATION_STATUS_ASC';
    case Enum$IssueSort.ESCALATION_STATUS_DESC:
      return r'ESCALATION_STATUS_DESC';
    case Enum$IssueSort.CLOSED_AT_ASC:
      return r'CLOSED_AT_ASC';
    case Enum$IssueSort.CLOSED_AT_DESC:
      return r'CLOSED_AT_DESC';
    case Enum$IssueSort.WEIGHT_ASC:
      return r'WEIGHT_ASC';
    case Enum$IssueSort.WEIGHT_DESC:
      return r'WEIGHT_DESC';
    case Enum$IssueSort.PUBLISHED_ASC:
      return r'PUBLISHED_ASC';
    case Enum$IssueSort.PUBLISHED_DESC:
      return r'PUBLISHED_DESC';
    case Enum$IssueSort.SLA_DUE_AT_ASC:
      return r'SLA_DUE_AT_ASC';
    case Enum$IssueSort.SLA_DUE_AT_DESC:
      return r'SLA_DUE_AT_DESC';
    case Enum$IssueSort.BLOCKING_ISSUES_ASC:
      return r'BLOCKING_ISSUES_ASC';
    case Enum$IssueSort.BLOCKING_ISSUES_DESC:
      return r'BLOCKING_ISSUES_DESC';
    case Enum$IssueSort.PRIORITY_ASC:
      return r'PRIORITY_ASC';
    case Enum$IssueSort.PRIORITY_DESC:
      return r'PRIORITY_DESC';
    case Enum$IssueSort.LABEL_PRIORITY_ASC:
      return r'LABEL_PRIORITY_ASC';
    case Enum$IssueSort.LABEL_PRIORITY_DESC:
      return r'LABEL_PRIORITY_DESC';
    case Enum$IssueSort.MILESTONE_DUE_ASC:
      return r'MILESTONE_DUE_ASC';
    case Enum$IssueSort.MILESTONE_DUE_DESC:
      return r'MILESTONE_DUE_DESC';
    case Enum$IssueSort.updated_desc:
      return r'updated_desc';
    case Enum$IssueSort.updated_asc:
      return r'updated_asc';
    case Enum$IssueSort.created_desc:
      return r'created_desc';
    case Enum$IssueSort.created_asc:
      return r'created_asc';
    case Enum$IssueSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$IssueSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$IssueSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$IssueSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$IssueSort.$unknown:
      return r'$unknown';
  }
}

Enum$IssueSort fromJson$Enum$IssueSort(String value) {
  switch (value) {
    case r'DUE_DATE_ASC':
      return Enum$IssueSort.DUE_DATE_ASC;
    case r'DUE_DATE_DESC':
      return Enum$IssueSort.DUE_DATE_DESC;
    case r'RELATIVE_POSITION_ASC':
      return Enum$IssueSort.RELATIVE_POSITION_ASC;
    case r'SEVERITY_ASC':
      return Enum$IssueSort.SEVERITY_ASC;
    case r'SEVERITY_DESC':
      return Enum$IssueSort.SEVERITY_DESC;
    case r'TITLE_ASC':
      return Enum$IssueSort.TITLE_ASC;
    case r'TITLE_DESC':
      return Enum$IssueSort.TITLE_DESC;
    case r'POPULARITY_ASC':
      return Enum$IssueSort.POPULARITY_ASC;
    case r'POPULARITY_DESC':
      return Enum$IssueSort.POPULARITY_DESC;
    case r'ESCALATION_STATUS_ASC':
      return Enum$IssueSort.ESCALATION_STATUS_ASC;
    case r'ESCALATION_STATUS_DESC':
      return Enum$IssueSort.ESCALATION_STATUS_DESC;
    case r'CLOSED_AT_ASC':
      return Enum$IssueSort.CLOSED_AT_ASC;
    case r'CLOSED_AT_DESC':
      return Enum$IssueSort.CLOSED_AT_DESC;
    case r'WEIGHT_ASC':
      return Enum$IssueSort.WEIGHT_ASC;
    case r'WEIGHT_DESC':
      return Enum$IssueSort.WEIGHT_DESC;
    case r'PUBLISHED_ASC':
      return Enum$IssueSort.PUBLISHED_ASC;
    case r'PUBLISHED_DESC':
      return Enum$IssueSort.PUBLISHED_DESC;
    case r'SLA_DUE_AT_ASC':
      return Enum$IssueSort.SLA_DUE_AT_ASC;
    case r'SLA_DUE_AT_DESC':
      return Enum$IssueSort.SLA_DUE_AT_DESC;
    case r'BLOCKING_ISSUES_ASC':
      return Enum$IssueSort.BLOCKING_ISSUES_ASC;
    case r'BLOCKING_ISSUES_DESC':
      return Enum$IssueSort.BLOCKING_ISSUES_DESC;
    case r'PRIORITY_ASC':
      return Enum$IssueSort.PRIORITY_ASC;
    case r'PRIORITY_DESC':
      return Enum$IssueSort.PRIORITY_DESC;
    case r'LABEL_PRIORITY_ASC':
      return Enum$IssueSort.LABEL_PRIORITY_ASC;
    case r'LABEL_PRIORITY_DESC':
      return Enum$IssueSort.LABEL_PRIORITY_DESC;
    case r'MILESTONE_DUE_ASC':
      return Enum$IssueSort.MILESTONE_DUE_ASC;
    case r'MILESTONE_DUE_DESC':
      return Enum$IssueSort.MILESTONE_DUE_DESC;
    case r'updated_desc':
      return Enum$IssueSort.updated_desc;
    case r'updated_asc':
      return Enum$IssueSort.updated_asc;
    case r'created_desc':
      return Enum$IssueSort.created_desc;
    case r'created_asc':
      return Enum$IssueSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$IssueSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$IssueSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$IssueSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$IssueSort.CREATED_ASC;
    default:
      return Enum$IssueSort.$unknown;
  }
}

enum Enum$IssueState { opened, closed, locked, all, $unknown }

String toJson$Enum$IssueState(Enum$IssueState e) {
  switch (e) {
    case Enum$IssueState.opened:
      return r'opened';
    case Enum$IssueState.closed:
      return r'closed';
    case Enum$IssueState.locked:
      return r'locked';
    case Enum$IssueState.all:
      return r'all';
    case Enum$IssueState.$unknown:
      return r'$unknown';
  }
}

Enum$IssueState fromJson$Enum$IssueState(String value) {
  switch (value) {
    case r'opened':
      return Enum$IssueState.opened;
    case r'closed':
      return Enum$IssueState.closed;
    case r'locked':
      return Enum$IssueState.locked;
    case r'all':
      return Enum$IssueState.all;
    default:
      return Enum$IssueState.$unknown;
  }
}

enum Enum$IssueStateEvent { REOPEN, CLOSE, $unknown }

String toJson$Enum$IssueStateEvent(Enum$IssueStateEvent e) {
  switch (e) {
    case Enum$IssueStateEvent.REOPEN:
      return r'REOPEN';
    case Enum$IssueStateEvent.CLOSE:
      return r'CLOSE';
    case Enum$IssueStateEvent.$unknown:
      return r'$unknown';
  }
}

Enum$IssueStateEvent fromJson$Enum$IssueStateEvent(String value) {
  switch (value) {
    case r'REOPEN':
      return Enum$IssueStateEvent.REOPEN;
    case r'CLOSE':
      return Enum$IssueStateEvent.CLOSE;
    default:
      return Enum$IssueStateEvent.$unknown;
  }
}

enum Enum$IssueType { ISSUE, INCIDENT, TEST_CASE, REQUIREMENT, TASK, $unknown }

String toJson$Enum$IssueType(Enum$IssueType e) {
  switch (e) {
    case Enum$IssueType.ISSUE:
      return r'ISSUE';
    case Enum$IssueType.INCIDENT:
      return r'INCIDENT';
    case Enum$IssueType.TEST_CASE:
      return r'TEST_CASE';
    case Enum$IssueType.REQUIREMENT:
      return r'REQUIREMENT';
    case Enum$IssueType.TASK:
      return r'TASK';
    case Enum$IssueType.$unknown:
      return r'$unknown';
  }
}

Enum$IssueType fromJson$Enum$IssueType(String value) {
  switch (value) {
    case r'ISSUE':
      return Enum$IssueType.ISSUE;
    case r'INCIDENT':
      return Enum$IssueType.INCIDENT;
    case r'TEST_CASE':
      return Enum$IssueType.TEST_CASE;
    case r'REQUIREMENT':
      return Enum$IssueType.REQUIREMENT;
    case r'TASK':
      return Enum$IssueType.TASK;
    default:
      return Enum$IssueType.$unknown;
  }
}

enum Enum$IterationSearchableField { TITLE, CADENCE_TITLE, $unknown }

String toJson$Enum$IterationSearchableField(Enum$IterationSearchableField e) {
  switch (e) {
    case Enum$IterationSearchableField.TITLE:
      return r'TITLE';
    case Enum$IterationSearchableField.CADENCE_TITLE:
      return r'CADENCE_TITLE';
    case Enum$IterationSearchableField.$unknown:
      return r'$unknown';
  }
}

Enum$IterationSearchableField fromJson$Enum$IterationSearchableField(
    String value) {
  switch (value) {
    case r'TITLE':
      return Enum$IterationSearchableField.TITLE;
    case r'CADENCE_TITLE':
      return Enum$IterationSearchableField.CADENCE_TITLE;
    default:
      return Enum$IterationSearchableField.$unknown;
  }
}

enum Enum$IterationSort { CADENCE_AND_DUE_DATE_ASC, $unknown }

String toJson$Enum$IterationSort(Enum$IterationSort e) {
  switch (e) {
    case Enum$IterationSort.CADENCE_AND_DUE_DATE_ASC:
      return r'CADENCE_AND_DUE_DATE_ASC';
    case Enum$IterationSort.$unknown:
      return r'$unknown';
  }
}

Enum$IterationSort fromJson$Enum$IterationSort(String value) {
  switch (value) {
    case r'CADENCE_AND_DUE_DATE_ASC':
      return Enum$IterationSort.CADENCE_AND_DUE_DATE_ASC;
    default:
      return Enum$IterationSort.$unknown;
  }
}

enum Enum$IterationState {
  upcoming,
  started,
  current,
  opened,
  closed,
  all,
  $unknown
}

String toJson$Enum$IterationState(Enum$IterationState e) {
  switch (e) {
    case Enum$IterationState.upcoming:
      return r'upcoming';
    case Enum$IterationState.started:
      return r'started';
    case Enum$IterationState.current:
      return r'current';
    case Enum$IterationState.opened:
      return r'opened';
    case Enum$IterationState.closed:
      return r'closed';
    case Enum$IterationState.all:
      return r'all';
    case Enum$IterationState.$unknown:
      return r'$unknown';
  }
}

Enum$IterationState fromJson$Enum$IterationState(String value) {
  switch (value) {
    case r'upcoming':
      return Enum$IterationState.upcoming;
    case r'started':
      return Enum$IterationState.started;
    case r'current':
      return Enum$IterationState.current;
    case r'opened':
      return Enum$IterationState.opened;
    case r'closed':
      return Enum$IterationState.closed;
    case r'all':
      return Enum$IterationState.all;
    default:
      return Enum$IterationState.$unknown;
  }
}

enum Enum$IterationWildcardId { NONE, ANY, CURRENT, $unknown }

String toJson$Enum$IterationWildcardId(Enum$IterationWildcardId e) {
  switch (e) {
    case Enum$IterationWildcardId.NONE:
      return r'NONE';
    case Enum$IterationWildcardId.ANY:
      return r'ANY';
    case Enum$IterationWildcardId.CURRENT:
      return r'CURRENT';
    case Enum$IterationWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$IterationWildcardId fromJson$Enum$IterationWildcardId(String value) {
  switch (value) {
    case r'NONE':
      return Enum$IterationWildcardId.NONE;
    case r'ANY':
      return Enum$IterationWildcardId.ANY;
    case r'CURRENT':
      return Enum$IterationWildcardId.CURRENT;
    default:
      return Enum$IterationWildcardId.$unknown;
  }
}

enum Enum$JobArtifactFileType {
  ARCHIVE,
  METADATA,
  TRACE,
  JUNIT,
  METRICS,
  METRICS_REFEREE,
  NETWORK_REFEREE,
  DOTENV,
  COBERTURA,
  CLUSTER_APPLICATIONS,
  LSIF,
  CYCLONEDX,
  SAST,
  SECRET_DETECTION,
  DEPENDENCY_SCANNING,
  CONTAINER_SCANNING,
  CLUSTER_IMAGE_SCANNING,
  DAST,
  LICENSE_SCANNING,
  ACCESSIBILITY,
  CODEQUALITY,
  PERFORMANCE,
  BROWSER_PERFORMANCE,
  LOAD_PERFORMANCE,
  TERRAFORM,
  REQUIREMENTS,
  COVERAGE_FUZZING,
  API_FUZZING,
  $unknown
}

String toJson$Enum$JobArtifactFileType(Enum$JobArtifactFileType e) {
  switch (e) {
    case Enum$JobArtifactFileType.ARCHIVE:
      return r'ARCHIVE';
    case Enum$JobArtifactFileType.METADATA:
      return r'METADATA';
    case Enum$JobArtifactFileType.TRACE:
      return r'TRACE';
    case Enum$JobArtifactFileType.JUNIT:
      return r'JUNIT';
    case Enum$JobArtifactFileType.METRICS:
      return r'METRICS';
    case Enum$JobArtifactFileType.METRICS_REFEREE:
      return r'METRICS_REFEREE';
    case Enum$JobArtifactFileType.NETWORK_REFEREE:
      return r'NETWORK_REFEREE';
    case Enum$JobArtifactFileType.DOTENV:
      return r'DOTENV';
    case Enum$JobArtifactFileType.COBERTURA:
      return r'COBERTURA';
    case Enum$JobArtifactFileType.CLUSTER_APPLICATIONS:
      return r'CLUSTER_APPLICATIONS';
    case Enum$JobArtifactFileType.LSIF:
      return r'LSIF';
    case Enum$JobArtifactFileType.CYCLONEDX:
      return r'CYCLONEDX';
    case Enum$JobArtifactFileType.SAST:
      return r'SAST';
    case Enum$JobArtifactFileType.SECRET_DETECTION:
      return r'SECRET_DETECTION';
    case Enum$JobArtifactFileType.DEPENDENCY_SCANNING:
      return r'DEPENDENCY_SCANNING';
    case Enum$JobArtifactFileType.CONTAINER_SCANNING:
      return r'CONTAINER_SCANNING';
    case Enum$JobArtifactFileType.CLUSTER_IMAGE_SCANNING:
      return r'CLUSTER_IMAGE_SCANNING';
    case Enum$JobArtifactFileType.DAST:
      return r'DAST';
    case Enum$JobArtifactFileType.LICENSE_SCANNING:
      return r'LICENSE_SCANNING';
    case Enum$JobArtifactFileType.ACCESSIBILITY:
      return r'ACCESSIBILITY';
    case Enum$JobArtifactFileType.CODEQUALITY:
      return r'CODEQUALITY';
    case Enum$JobArtifactFileType.PERFORMANCE:
      return r'PERFORMANCE';
    case Enum$JobArtifactFileType.BROWSER_PERFORMANCE:
      return r'BROWSER_PERFORMANCE';
    case Enum$JobArtifactFileType.LOAD_PERFORMANCE:
      return r'LOAD_PERFORMANCE';
    case Enum$JobArtifactFileType.TERRAFORM:
      return r'TERRAFORM';
    case Enum$JobArtifactFileType.REQUIREMENTS:
      return r'REQUIREMENTS';
    case Enum$JobArtifactFileType.COVERAGE_FUZZING:
      return r'COVERAGE_FUZZING';
    case Enum$JobArtifactFileType.API_FUZZING:
      return r'API_FUZZING';
    case Enum$JobArtifactFileType.$unknown:
      return r'$unknown';
  }
}

Enum$JobArtifactFileType fromJson$Enum$JobArtifactFileType(String value) {
  switch (value) {
    case r'ARCHIVE':
      return Enum$JobArtifactFileType.ARCHIVE;
    case r'METADATA':
      return Enum$JobArtifactFileType.METADATA;
    case r'TRACE':
      return Enum$JobArtifactFileType.TRACE;
    case r'JUNIT':
      return Enum$JobArtifactFileType.JUNIT;
    case r'METRICS':
      return Enum$JobArtifactFileType.METRICS;
    case r'METRICS_REFEREE':
      return Enum$JobArtifactFileType.METRICS_REFEREE;
    case r'NETWORK_REFEREE':
      return Enum$JobArtifactFileType.NETWORK_REFEREE;
    case r'DOTENV':
      return Enum$JobArtifactFileType.DOTENV;
    case r'COBERTURA':
      return Enum$JobArtifactFileType.COBERTURA;
    case r'CLUSTER_APPLICATIONS':
      return Enum$JobArtifactFileType.CLUSTER_APPLICATIONS;
    case r'LSIF':
      return Enum$JobArtifactFileType.LSIF;
    case r'CYCLONEDX':
      return Enum$JobArtifactFileType.CYCLONEDX;
    case r'SAST':
      return Enum$JobArtifactFileType.SAST;
    case r'SECRET_DETECTION':
      return Enum$JobArtifactFileType.SECRET_DETECTION;
    case r'DEPENDENCY_SCANNING':
      return Enum$JobArtifactFileType.DEPENDENCY_SCANNING;
    case r'CONTAINER_SCANNING':
      return Enum$JobArtifactFileType.CONTAINER_SCANNING;
    case r'CLUSTER_IMAGE_SCANNING':
      return Enum$JobArtifactFileType.CLUSTER_IMAGE_SCANNING;
    case r'DAST':
      return Enum$JobArtifactFileType.DAST;
    case r'LICENSE_SCANNING':
      return Enum$JobArtifactFileType.LICENSE_SCANNING;
    case r'ACCESSIBILITY':
      return Enum$JobArtifactFileType.ACCESSIBILITY;
    case r'CODEQUALITY':
      return Enum$JobArtifactFileType.CODEQUALITY;
    case r'PERFORMANCE':
      return Enum$JobArtifactFileType.PERFORMANCE;
    case r'BROWSER_PERFORMANCE':
      return Enum$JobArtifactFileType.BROWSER_PERFORMANCE;
    case r'LOAD_PERFORMANCE':
      return Enum$JobArtifactFileType.LOAD_PERFORMANCE;
    case r'TERRAFORM':
      return Enum$JobArtifactFileType.TERRAFORM;
    case r'REQUIREMENTS':
      return Enum$JobArtifactFileType.REQUIREMENTS;
    case r'COVERAGE_FUZZING':
      return Enum$JobArtifactFileType.COVERAGE_FUZZING;
    case r'API_FUZZING':
      return Enum$JobArtifactFileType.API_FUZZING;
    default:
      return Enum$JobArtifactFileType.$unknown;
  }
}

enum Enum$ListLimitMetric { all_metrics, issue_count, issue_weights, $unknown }

String toJson$Enum$ListLimitMetric(Enum$ListLimitMetric e) {
  switch (e) {
    case Enum$ListLimitMetric.all_metrics:
      return r'all_metrics';
    case Enum$ListLimitMetric.issue_count:
      return r'issue_count';
    case Enum$ListLimitMetric.issue_weights:
      return r'issue_weights';
    case Enum$ListLimitMetric.$unknown:
      return r'$unknown';
  }
}

Enum$ListLimitMetric fromJson$Enum$ListLimitMetric(String value) {
  switch (value) {
    case r'all_metrics':
      return Enum$ListLimitMetric.all_metrics;
    case r'issue_count':
      return Enum$ListLimitMetric.issue_count;
    case r'issue_weights':
      return Enum$ListLimitMetric.issue_weights;
    default:
      return Enum$ListLimitMetric.$unknown;
  }
}

enum Enum$MeasurementIdentifier {
  PROJECTS,
  USERS,
  ISSUES,
  MERGE_REQUESTS,
  GROUPS,
  PIPELINES,
  PIPELINES_SUCCEEDED,
  PIPELINES_FAILED,
  PIPELINES_CANCELED,
  PIPELINES_SKIPPED,
  $unknown
}

String toJson$Enum$MeasurementIdentifier(Enum$MeasurementIdentifier e) {
  switch (e) {
    case Enum$MeasurementIdentifier.PROJECTS:
      return r'PROJECTS';
    case Enum$MeasurementIdentifier.USERS:
      return r'USERS';
    case Enum$MeasurementIdentifier.ISSUES:
      return r'ISSUES';
    case Enum$MeasurementIdentifier.MERGE_REQUESTS:
      return r'MERGE_REQUESTS';
    case Enum$MeasurementIdentifier.GROUPS:
      return r'GROUPS';
    case Enum$MeasurementIdentifier.PIPELINES:
      return r'PIPELINES';
    case Enum$MeasurementIdentifier.PIPELINES_SUCCEEDED:
      return r'PIPELINES_SUCCEEDED';
    case Enum$MeasurementIdentifier.PIPELINES_FAILED:
      return r'PIPELINES_FAILED';
    case Enum$MeasurementIdentifier.PIPELINES_CANCELED:
      return r'PIPELINES_CANCELED';
    case Enum$MeasurementIdentifier.PIPELINES_SKIPPED:
      return r'PIPELINES_SKIPPED';
    case Enum$MeasurementIdentifier.$unknown:
      return r'$unknown';
  }
}

Enum$MeasurementIdentifier fromJson$Enum$MeasurementIdentifier(String value) {
  switch (value) {
    case r'PROJECTS':
      return Enum$MeasurementIdentifier.PROJECTS;
    case r'USERS':
      return Enum$MeasurementIdentifier.USERS;
    case r'ISSUES':
      return Enum$MeasurementIdentifier.ISSUES;
    case r'MERGE_REQUESTS':
      return Enum$MeasurementIdentifier.MERGE_REQUESTS;
    case r'GROUPS':
      return Enum$MeasurementIdentifier.GROUPS;
    case r'PIPELINES':
      return Enum$MeasurementIdentifier.PIPELINES;
    case r'PIPELINES_SUCCEEDED':
      return Enum$MeasurementIdentifier.PIPELINES_SUCCEEDED;
    case r'PIPELINES_FAILED':
      return Enum$MeasurementIdentifier.PIPELINES_FAILED;
    case r'PIPELINES_CANCELED':
      return Enum$MeasurementIdentifier.PIPELINES_CANCELED;
    case r'PIPELINES_SKIPPED':
      return Enum$MeasurementIdentifier.PIPELINES_SKIPPED;
    default:
      return Enum$MeasurementIdentifier.$unknown;
  }
}

enum Enum$MergeRequestNewState { OPEN, CLOSED, $unknown }

String toJson$Enum$MergeRequestNewState(Enum$MergeRequestNewState e) {
  switch (e) {
    case Enum$MergeRequestNewState.OPEN:
      return r'OPEN';
    case Enum$MergeRequestNewState.CLOSED:
      return r'CLOSED';
    case Enum$MergeRequestNewState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeRequestNewState fromJson$Enum$MergeRequestNewState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$MergeRequestNewState.OPEN;
    case r'CLOSED':
      return Enum$MergeRequestNewState.CLOSED;
    default:
      return Enum$MergeRequestNewState.$unknown;
  }
}

enum Enum$MergeRequestReviewState { UNREVIEWED, REVIEWED, $unknown }

String toJson$Enum$MergeRequestReviewState(Enum$MergeRequestReviewState e) {
  switch (e) {
    case Enum$MergeRequestReviewState.UNREVIEWED:
      return r'UNREVIEWED';
    case Enum$MergeRequestReviewState.REVIEWED:
      return r'REVIEWED';
    case Enum$MergeRequestReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeRequestReviewState fromJson$Enum$MergeRequestReviewState(
    String value) {
  switch (value) {
    case r'UNREVIEWED':
      return Enum$MergeRequestReviewState.UNREVIEWED;
    case r'REVIEWED':
      return Enum$MergeRequestReviewState.REVIEWED;
    default:
      return Enum$MergeRequestReviewState.$unknown;
  }
}

enum Enum$MergeRequestSort {
  MERGED_AT_ASC,
  MERGED_AT_DESC,
  CLOSED_AT_ASC,
  CLOSED_AT_DESC,
  TITLE_ASC,
  TITLE_DESC,
  PRIORITY_ASC,
  PRIORITY_DESC,
  LABEL_PRIORITY_ASC,
  LABEL_PRIORITY_DESC,
  MILESTONE_DUE_ASC,
  MILESTONE_DUE_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$MergeRequestSort(Enum$MergeRequestSort e) {
  switch (e) {
    case Enum$MergeRequestSort.MERGED_AT_ASC:
      return r'MERGED_AT_ASC';
    case Enum$MergeRequestSort.MERGED_AT_DESC:
      return r'MERGED_AT_DESC';
    case Enum$MergeRequestSort.CLOSED_AT_ASC:
      return r'CLOSED_AT_ASC';
    case Enum$MergeRequestSort.CLOSED_AT_DESC:
      return r'CLOSED_AT_DESC';
    case Enum$MergeRequestSort.TITLE_ASC:
      return r'TITLE_ASC';
    case Enum$MergeRequestSort.TITLE_DESC:
      return r'TITLE_DESC';
    case Enum$MergeRequestSort.PRIORITY_ASC:
      return r'PRIORITY_ASC';
    case Enum$MergeRequestSort.PRIORITY_DESC:
      return r'PRIORITY_DESC';
    case Enum$MergeRequestSort.LABEL_PRIORITY_ASC:
      return r'LABEL_PRIORITY_ASC';
    case Enum$MergeRequestSort.LABEL_PRIORITY_DESC:
      return r'LABEL_PRIORITY_DESC';
    case Enum$MergeRequestSort.MILESTONE_DUE_ASC:
      return r'MILESTONE_DUE_ASC';
    case Enum$MergeRequestSort.MILESTONE_DUE_DESC:
      return r'MILESTONE_DUE_DESC';
    case Enum$MergeRequestSort.updated_desc:
      return r'updated_desc';
    case Enum$MergeRequestSort.updated_asc:
      return r'updated_asc';
    case Enum$MergeRequestSort.created_desc:
      return r'created_desc';
    case Enum$MergeRequestSort.created_asc:
      return r'created_asc';
    case Enum$MergeRequestSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$MergeRequestSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$MergeRequestSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$MergeRequestSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$MergeRequestSort.$unknown:
      return r'$unknown';
  }
}

Enum$MergeRequestSort fromJson$Enum$MergeRequestSort(String value) {
  switch (value) {
    case r'MERGED_AT_ASC':
      return Enum$MergeRequestSort.MERGED_AT_ASC;
    case r'MERGED_AT_DESC':
      return Enum$MergeRequestSort.MERGED_AT_DESC;
    case r'CLOSED_AT_ASC':
      return Enum$MergeRequestSort.CLOSED_AT_ASC;
    case r'CLOSED_AT_DESC':
      return Enum$MergeRequestSort.CLOSED_AT_DESC;
    case r'TITLE_ASC':
      return Enum$MergeRequestSort.TITLE_ASC;
    case r'TITLE_DESC':
      return Enum$MergeRequestSort.TITLE_DESC;
    case r'PRIORITY_ASC':
      return Enum$MergeRequestSort.PRIORITY_ASC;
    case r'PRIORITY_DESC':
      return Enum$MergeRequestSort.PRIORITY_DESC;
    case r'LABEL_PRIORITY_ASC':
      return Enum$MergeRequestSort.LABEL_PRIORITY_ASC;
    case r'LABEL_PRIORITY_DESC':
      return Enum$MergeRequestSort.LABEL_PRIORITY_DESC;
    case r'MILESTONE_DUE_ASC':
      return Enum$MergeRequestSort.MILESTONE_DUE_ASC;
    case r'MILESTONE_DUE_DESC':
      return Enum$MergeRequestSort.MILESTONE_DUE_DESC;
    case r'updated_desc':
      return Enum$MergeRequestSort.updated_desc;
    case r'updated_asc':
      return Enum$MergeRequestSort.updated_asc;
    case r'created_desc':
      return Enum$MergeRequestSort.created_desc;
    case r'created_asc':
      return Enum$MergeRequestSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$MergeRequestSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$MergeRequestSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$MergeRequestSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$MergeRequestSort.CREATED_ASC;
    default:
      return Enum$MergeRequestSort.$unknown;
  }
}

enum Enum$MergeRequestState { merged, opened, closed, locked, all, $unknown }

String toJson$Enum$MergeRequestState(Enum$MergeRequestState e) {
  switch (e) {
    case Enum$MergeRequestState.merged:
      return r'merged';
    case Enum$MergeRequestState.opened:
      return r'opened';
    case Enum$MergeRequestState.closed:
      return r'closed';
    case Enum$MergeRequestState.locked:
      return r'locked';
    case Enum$MergeRequestState.all:
      return r'all';
    case Enum$MergeRequestState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeRequestState fromJson$Enum$MergeRequestState(String value) {
  switch (value) {
    case r'merged':
      return Enum$MergeRequestState.merged;
    case r'opened':
      return Enum$MergeRequestState.opened;
    case r'closed':
      return Enum$MergeRequestState.closed;
    case r'locked':
      return Enum$MergeRequestState.locked;
    case r'all':
      return Enum$MergeRequestState.all;
    default:
      return Enum$MergeRequestState.$unknown;
  }
}

enum Enum$MergeStatus {
  UNCHECKED,
  CHECKING,
  CAN_BE_MERGED,
  CANNOT_BE_MERGED,
  CANNOT_BE_MERGED_RECHECK,
  $unknown
}

String toJson$Enum$MergeStatus(Enum$MergeStatus e) {
  switch (e) {
    case Enum$MergeStatus.UNCHECKED:
      return r'UNCHECKED';
    case Enum$MergeStatus.CHECKING:
      return r'CHECKING';
    case Enum$MergeStatus.CAN_BE_MERGED:
      return r'CAN_BE_MERGED';
    case Enum$MergeStatus.CANNOT_BE_MERGED:
      return r'CANNOT_BE_MERGED';
    case Enum$MergeStatus.CANNOT_BE_MERGED_RECHECK:
      return r'CANNOT_BE_MERGED_RECHECK';
    case Enum$MergeStatus.$unknown:
      return r'$unknown';
  }
}

Enum$MergeStatus fromJson$Enum$MergeStatus(String value) {
  switch (value) {
    case r'UNCHECKED':
      return Enum$MergeStatus.UNCHECKED;
    case r'CHECKING':
      return Enum$MergeStatus.CHECKING;
    case r'CAN_BE_MERGED':
      return Enum$MergeStatus.CAN_BE_MERGED;
    case r'CANNOT_BE_MERGED':
      return Enum$MergeStatus.CANNOT_BE_MERGED;
    case r'CANNOT_BE_MERGED_RECHECK':
      return Enum$MergeStatus.CANNOT_BE_MERGED_RECHECK;
    default:
      return Enum$MergeStatus.$unknown;
  }
}

enum Enum$MergeStrategyEnum {
  MERGE_TRAIN,
  ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS,
  MERGE_WHEN_PIPELINE_SUCCEEDS,
  $unknown
}

String toJson$Enum$MergeStrategyEnum(Enum$MergeStrategyEnum e) {
  switch (e) {
    case Enum$MergeStrategyEnum.MERGE_TRAIN:
      return r'MERGE_TRAIN';
    case Enum$MergeStrategyEnum.ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS:
      return r'ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS';
    case Enum$MergeStrategyEnum.MERGE_WHEN_PIPELINE_SUCCEEDS:
      return r'MERGE_WHEN_PIPELINE_SUCCEEDS';
    case Enum$MergeStrategyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$MergeStrategyEnum fromJson$Enum$MergeStrategyEnum(String value) {
  switch (value) {
    case r'MERGE_TRAIN':
      return Enum$MergeStrategyEnum.MERGE_TRAIN;
    case r'ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS':
      return Enum$MergeStrategyEnum.ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS;
    case r'MERGE_WHEN_PIPELINE_SUCCEEDS':
      return Enum$MergeStrategyEnum.MERGE_WHEN_PIPELINE_SUCCEEDS;
    default:
      return Enum$MergeStrategyEnum.$unknown;
  }
}

enum Enum$MilestoneSort {
  DUE_DATE_ASC,
  DUE_DATE_DESC,
  EXPIRED_LAST_DUE_DATE_ASC,
  EXPIRED_LAST_DUE_DATE_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$MilestoneSort(Enum$MilestoneSort e) {
  switch (e) {
    case Enum$MilestoneSort.DUE_DATE_ASC:
      return r'DUE_DATE_ASC';
    case Enum$MilestoneSort.DUE_DATE_DESC:
      return r'DUE_DATE_DESC';
    case Enum$MilestoneSort.EXPIRED_LAST_DUE_DATE_ASC:
      return r'EXPIRED_LAST_DUE_DATE_ASC';
    case Enum$MilestoneSort.EXPIRED_LAST_DUE_DATE_DESC:
      return r'EXPIRED_LAST_DUE_DATE_DESC';
    case Enum$MilestoneSort.updated_desc:
      return r'updated_desc';
    case Enum$MilestoneSort.updated_asc:
      return r'updated_asc';
    case Enum$MilestoneSort.created_desc:
      return r'created_desc';
    case Enum$MilestoneSort.created_asc:
      return r'created_asc';
    case Enum$MilestoneSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$MilestoneSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$MilestoneSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$MilestoneSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$MilestoneSort.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneSort fromJson$Enum$MilestoneSort(String value) {
  switch (value) {
    case r'DUE_DATE_ASC':
      return Enum$MilestoneSort.DUE_DATE_ASC;
    case r'DUE_DATE_DESC':
      return Enum$MilestoneSort.DUE_DATE_DESC;
    case r'EXPIRED_LAST_DUE_DATE_ASC':
      return Enum$MilestoneSort.EXPIRED_LAST_DUE_DATE_ASC;
    case r'EXPIRED_LAST_DUE_DATE_DESC':
      return Enum$MilestoneSort.EXPIRED_LAST_DUE_DATE_DESC;
    case r'updated_desc':
      return Enum$MilestoneSort.updated_desc;
    case r'updated_asc':
      return Enum$MilestoneSort.updated_asc;
    case r'created_desc':
      return Enum$MilestoneSort.created_desc;
    case r'created_asc':
      return Enum$MilestoneSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$MilestoneSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$MilestoneSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$MilestoneSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$MilestoneSort.CREATED_ASC;
    default:
      return Enum$MilestoneSort.$unknown;
  }
}

enum Enum$MilestoneStateEnum { active, closed, $unknown }

String toJson$Enum$MilestoneStateEnum(Enum$MilestoneStateEnum e) {
  switch (e) {
    case Enum$MilestoneStateEnum.active:
      return r'active';
    case Enum$MilestoneStateEnum.closed:
      return r'closed';
    case Enum$MilestoneStateEnum.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneStateEnum fromJson$Enum$MilestoneStateEnum(String value) {
  switch (value) {
    case r'active':
      return Enum$MilestoneStateEnum.active;
    case r'closed':
      return Enum$MilestoneStateEnum.closed;
    default:
      return Enum$MilestoneStateEnum.$unknown;
  }
}

enum Enum$MilestoneWildcardId { NONE, ANY, STARTED, UPCOMING, $unknown }

String toJson$Enum$MilestoneWildcardId(Enum$MilestoneWildcardId e) {
  switch (e) {
    case Enum$MilestoneWildcardId.NONE:
      return r'NONE';
    case Enum$MilestoneWildcardId.ANY:
      return r'ANY';
    case Enum$MilestoneWildcardId.STARTED:
      return r'STARTED';
    case Enum$MilestoneWildcardId.UPCOMING:
      return r'UPCOMING';
    case Enum$MilestoneWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneWildcardId fromJson$Enum$MilestoneWildcardId(String value) {
  switch (value) {
    case r'NONE':
      return Enum$MilestoneWildcardId.NONE;
    case r'ANY':
      return Enum$MilestoneWildcardId.ANY;
    case r'STARTED':
      return Enum$MilestoneWildcardId.STARTED;
    case r'UPCOMING':
      return Enum$MilestoneWildcardId.UPCOMING;
    default:
      return Enum$MilestoneWildcardId.$unknown;
  }
}

enum Enum$MoveType { before, after, $unknown }

String toJson$Enum$MoveType(Enum$MoveType e) {
  switch (e) {
    case Enum$MoveType.before:
      return r'before';
    case Enum$MoveType.after:
      return r'after';
    case Enum$MoveType.$unknown:
      return r'$unknown';
  }
}

Enum$MoveType fromJson$Enum$MoveType(String value) {
  switch (value) {
    case r'before':
      return Enum$MoveType.before;
    case r'after':
      return Enum$MoveType.after;
    default:
      return Enum$MoveType.$unknown;
  }
}

enum Enum$MutationOperationMode { REPLACE, APPEND, REMOVE, $unknown }

String toJson$Enum$MutationOperationMode(Enum$MutationOperationMode e) {
  switch (e) {
    case Enum$MutationOperationMode.REPLACE:
      return r'REPLACE';
    case Enum$MutationOperationMode.APPEND:
      return r'APPEND';
    case Enum$MutationOperationMode.REMOVE:
      return r'REMOVE';
    case Enum$MutationOperationMode.$unknown:
      return r'$unknown';
  }
}

Enum$MutationOperationMode fromJson$Enum$MutationOperationMode(String value) {
  switch (value) {
    case r'REPLACE':
      return Enum$MutationOperationMode.REPLACE;
    case r'APPEND':
      return Enum$MutationOperationMode.APPEND;
    case r'REMOVE':
      return Enum$MutationOperationMode.REMOVE;
    default:
      return Enum$MutationOperationMode.$unknown;
  }
}

enum Enum$NamespaceProjectSort { SIMILARITY, STORAGE, $unknown }

String toJson$Enum$NamespaceProjectSort(Enum$NamespaceProjectSort e) {
  switch (e) {
    case Enum$NamespaceProjectSort.SIMILARITY:
      return r'SIMILARITY';
    case Enum$NamespaceProjectSort.STORAGE:
      return r'STORAGE';
    case Enum$NamespaceProjectSort.$unknown:
      return r'$unknown';
  }
}

Enum$NamespaceProjectSort fromJson$Enum$NamespaceProjectSort(String value) {
  switch (value) {
    case r'SIMILARITY':
      return Enum$NamespaceProjectSort.SIMILARITY;
    case r'STORAGE':
      return Enum$NamespaceProjectSort.STORAGE;
    default:
      return Enum$NamespaceProjectSort.$unknown;
  }
}

enum Enum$NegatedIterationWildcardId { CURRENT, $unknown }

String toJson$Enum$NegatedIterationWildcardId(
    Enum$NegatedIterationWildcardId e) {
  switch (e) {
    case Enum$NegatedIterationWildcardId.CURRENT:
      return r'CURRENT';
    case Enum$NegatedIterationWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$NegatedIterationWildcardId fromJson$Enum$NegatedIterationWildcardId(
    String value) {
  switch (value) {
    case r'CURRENT':
      return Enum$NegatedIterationWildcardId.CURRENT;
    default:
      return Enum$NegatedIterationWildcardId.$unknown;
  }
}

enum Enum$NegatedMilestoneWildcardId { STARTED, UPCOMING, $unknown }

String toJson$Enum$NegatedMilestoneWildcardId(
    Enum$NegatedMilestoneWildcardId e) {
  switch (e) {
    case Enum$NegatedMilestoneWildcardId.STARTED:
      return r'STARTED';
    case Enum$NegatedMilestoneWildcardId.UPCOMING:
      return r'UPCOMING';
    case Enum$NegatedMilestoneWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$NegatedMilestoneWildcardId fromJson$Enum$NegatedMilestoneWildcardId(
    String value) {
  switch (value) {
    case r'STARTED':
      return Enum$NegatedMilestoneWildcardId.STARTED;
    case r'UPCOMING':
      return Enum$NegatedMilestoneWildcardId.UPCOMING;
    default:
      return Enum$NegatedMilestoneWildcardId.$unknown;
  }
}

enum Enum$NetworkPolicyKind { CiliumNetworkPolicy, NetworkPolicy, $unknown }

String toJson$Enum$NetworkPolicyKind(Enum$NetworkPolicyKind e) {
  switch (e) {
    case Enum$NetworkPolicyKind.CiliumNetworkPolicy:
      return r'CiliumNetworkPolicy';
    case Enum$NetworkPolicyKind.NetworkPolicy:
      return r'NetworkPolicy';
    case Enum$NetworkPolicyKind.$unknown:
      return r'$unknown';
  }
}

Enum$NetworkPolicyKind fromJson$Enum$NetworkPolicyKind(String value) {
  switch (value) {
    case r'CiliumNetworkPolicy':
      return Enum$NetworkPolicyKind.CiliumNetworkPolicy;
    case r'NetworkPolicy':
      return Enum$NetworkPolicyKind.NetworkPolicy;
    default:
      return Enum$NetworkPolicyKind.$unknown;
  }
}

enum Enum$OncallRotationUnitEnum { HOURS, DAYS, WEEKS, $unknown }

String toJson$Enum$OncallRotationUnitEnum(Enum$OncallRotationUnitEnum e) {
  switch (e) {
    case Enum$OncallRotationUnitEnum.HOURS:
      return r'HOURS';
    case Enum$OncallRotationUnitEnum.DAYS:
      return r'DAYS';
    case Enum$OncallRotationUnitEnum.WEEKS:
      return r'WEEKS';
    case Enum$OncallRotationUnitEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OncallRotationUnitEnum fromJson$Enum$OncallRotationUnitEnum(String value) {
  switch (value) {
    case r'HOURS':
      return Enum$OncallRotationUnitEnum.HOURS;
    case r'DAYS':
      return Enum$OncallRotationUnitEnum.DAYS;
    case r'WEEKS':
      return Enum$OncallRotationUnitEnum.WEEKS;
    default:
      return Enum$OncallRotationUnitEnum.$unknown;
  }
}

enum Enum$OrganizationSort {
  NAME_ASC,
  NAME_DESC,
  DESCRIPTION_ASC,
  DESCRIPTION_DESC,
  DEFAULT_RATE_ASC,
  DEFAULT_RATE_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$OrganizationSort(Enum$OrganizationSort e) {
  switch (e) {
    case Enum$OrganizationSort.NAME_ASC:
      return r'NAME_ASC';
    case Enum$OrganizationSort.NAME_DESC:
      return r'NAME_DESC';
    case Enum$OrganizationSort.DESCRIPTION_ASC:
      return r'DESCRIPTION_ASC';
    case Enum$OrganizationSort.DESCRIPTION_DESC:
      return r'DESCRIPTION_DESC';
    case Enum$OrganizationSort.DEFAULT_RATE_ASC:
      return r'DEFAULT_RATE_ASC';
    case Enum$OrganizationSort.DEFAULT_RATE_DESC:
      return r'DEFAULT_RATE_DESC';
    case Enum$OrganizationSort.updated_desc:
      return r'updated_desc';
    case Enum$OrganizationSort.updated_asc:
      return r'updated_asc';
    case Enum$OrganizationSort.created_desc:
      return r'created_desc';
    case Enum$OrganizationSort.created_asc:
      return r'created_asc';
    case Enum$OrganizationSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$OrganizationSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$OrganizationSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$OrganizationSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$OrganizationSort.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationSort fromJson$Enum$OrganizationSort(String value) {
  switch (value) {
    case r'NAME_ASC':
      return Enum$OrganizationSort.NAME_ASC;
    case r'NAME_DESC':
      return Enum$OrganizationSort.NAME_DESC;
    case r'DESCRIPTION_ASC':
      return Enum$OrganizationSort.DESCRIPTION_ASC;
    case r'DESCRIPTION_DESC':
      return Enum$OrganizationSort.DESCRIPTION_DESC;
    case r'DEFAULT_RATE_ASC':
      return Enum$OrganizationSort.DEFAULT_RATE_ASC;
    case r'DEFAULT_RATE_DESC':
      return Enum$OrganizationSort.DEFAULT_RATE_DESC;
    case r'updated_desc':
      return Enum$OrganizationSort.updated_desc;
    case r'updated_asc':
      return Enum$OrganizationSort.updated_asc;
    case r'created_desc':
      return Enum$OrganizationSort.created_desc;
    case r'created_asc':
      return Enum$OrganizationSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$OrganizationSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$OrganizationSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$OrganizationSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$OrganizationSort.CREATED_ASC;
    default:
      return Enum$OrganizationSort.$unknown;
  }
}

enum Enum$PackageDependencyType {
  DEPENDENCIES,
  DEV_DEPENDENCIES,
  BUNDLE_DEPENDENCIES,
  PEER_DEPENDENCIES,
  $unknown
}

String toJson$Enum$PackageDependencyType(Enum$PackageDependencyType e) {
  switch (e) {
    case Enum$PackageDependencyType.DEPENDENCIES:
      return r'DEPENDENCIES';
    case Enum$PackageDependencyType.DEV_DEPENDENCIES:
      return r'DEV_DEPENDENCIES';
    case Enum$PackageDependencyType.BUNDLE_DEPENDENCIES:
      return r'BUNDLE_DEPENDENCIES';
    case Enum$PackageDependencyType.PEER_DEPENDENCIES:
      return r'PEER_DEPENDENCIES';
    case Enum$PackageDependencyType.$unknown:
      return r'$unknown';
  }
}

Enum$PackageDependencyType fromJson$Enum$PackageDependencyType(String value) {
  switch (value) {
    case r'DEPENDENCIES':
      return Enum$PackageDependencyType.DEPENDENCIES;
    case r'DEV_DEPENDENCIES':
      return Enum$PackageDependencyType.DEV_DEPENDENCIES;
    case r'BUNDLE_DEPENDENCIES':
      return Enum$PackageDependencyType.BUNDLE_DEPENDENCIES;
    case r'PEER_DEPENDENCIES':
      return Enum$PackageDependencyType.PEER_DEPENDENCIES;
    default:
      return Enum$PackageDependencyType.$unknown;
  }
}

enum Enum$PackageGroupSort {
  PROJECT_PATH_DESC,
  PROJECT_PATH_ASC,
  CREATED_DESC,
  CREATED_ASC,
  NAME_DESC,
  NAME_ASC,
  VERSION_DESC,
  VERSION_ASC,
  TYPE_DESC,
  TYPE_ASC,
  $unknown
}

String toJson$Enum$PackageGroupSort(Enum$PackageGroupSort e) {
  switch (e) {
    case Enum$PackageGroupSort.PROJECT_PATH_DESC:
      return r'PROJECT_PATH_DESC';
    case Enum$PackageGroupSort.PROJECT_PATH_ASC:
      return r'PROJECT_PATH_ASC';
    case Enum$PackageGroupSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$PackageGroupSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$PackageGroupSort.NAME_DESC:
      return r'NAME_DESC';
    case Enum$PackageGroupSort.NAME_ASC:
      return r'NAME_ASC';
    case Enum$PackageGroupSort.VERSION_DESC:
      return r'VERSION_DESC';
    case Enum$PackageGroupSort.VERSION_ASC:
      return r'VERSION_ASC';
    case Enum$PackageGroupSort.TYPE_DESC:
      return r'TYPE_DESC';
    case Enum$PackageGroupSort.TYPE_ASC:
      return r'TYPE_ASC';
    case Enum$PackageGroupSort.$unknown:
      return r'$unknown';
  }
}

Enum$PackageGroupSort fromJson$Enum$PackageGroupSort(String value) {
  switch (value) {
    case r'PROJECT_PATH_DESC':
      return Enum$PackageGroupSort.PROJECT_PATH_DESC;
    case r'PROJECT_PATH_ASC':
      return Enum$PackageGroupSort.PROJECT_PATH_ASC;
    case r'CREATED_DESC':
      return Enum$PackageGroupSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$PackageGroupSort.CREATED_ASC;
    case r'NAME_DESC':
      return Enum$PackageGroupSort.NAME_DESC;
    case r'NAME_ASC':
      return Enum$PackageGroupSort.NAME_ASC;
    case r'VERSION_DESC':
      return Enum$PackageGroupSort.VERSION_DESC;
    case r'VERSION_ASC':
      return Enum$PackageGroupSort.VERSION_ASC;
    case r'TYPE_DESC':
      return Enum$PackageGroupSort.TYPE_DESC;
    case r'TYPE_ASC':
      return Enum$PackageGroupSort.TYPE_ASC;
    default:
      return Enum$PackageGroupSort.$unknown;
  }
}

enum Enum$PackageSort {
  CREATED_DESC,
  CREATED_ASC,
  NAME_DESC,
  NAME_ASC,
  VERSION_DESC,
  VERSION_ASC,
  TYPE_DESC,
  TYPE_ASC,
  $unknown
}

String toJson$Enum$PackageSort(Enum$PackageSort e) {
  switch (e) {
    case Enum$PackageSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$PackageSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$PackageSort.NAME_DESC:
      return r'NAME_DESC';
    case Enum$PackageSort.NAME_ASC:
      return r'NAME_ASC';
    case Enum$PackageSort.VERSION_DESC:
      return r'VERSION_DESC';
    case Enum$PackageSort.VERSION_ASC:
      return r'VERSION_ASC';
    case Enum$PackageSort.TYPE_DESC:
      return r'TYPE_DESC';
    case Enum$PackageSort.TYPE_ASC:
      return r'TYPE_ASC';
    case Enum$PackageSort.$unknown:
      return r'$unknown';
  }
}

Enum$PackageSort fromJson$Enum$PackageSort(String value) {
  switch (value) {
    case r'CREATED_DESC':
      return Enum$PackageSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$PackageSort.CREATED_ASC;
    case r'NAME_DESC':
      return Enum$PackageSort.NAME_DESC;
    case r'NAME_ASC':
      return Enum$PackageSort.NAME_ASC;
    case r'VERSION_DESC':
      return Enum$PackageSort.VERSION_DESC;
    case r'VERSION_ASC':
      return Enum$PackageSort.VERSION_ASC;
    case r'TYPE_DESC':
      return Enum$PackageSort.TYPE_DESC;
    case r'TYPE_ASC':
      return Enum$PackageSort.TYPE_ASC;
    default:
      return Enum$PackageSort.$unknown;
  }
}

enum Enum$PackageStatus {
  DEFAULT,
  HIDDEN,
  PROCESSING,
  ERROR,
  PENDING_DESTRUCTION,
  $unknown
}

String toJson$Enum$PackageStatus(Enum$PackageStatus e) {
  switch (e) {
    case Enum$PackageStatus.DEFAULT:
      return r'DEFAULT';
    case Enum$PackageStatus.HIDDEN:
      return r'HIDDEN';
    case Enum$PackageStatus.PROCESSING:
      return r'PROCESSING';
    case Enum$PackageStatus.ERROR:
      return r'ERROR';
    case Enum$PackageStatus.PENDING_DESTRUCTION:
      return r'PENDING_DESTRUCTION';
    case Enum$PackageStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PackageStatus fromJson$Enum$PackageStatus(String value) {
  switch (value) {
    case r'DEFAULT':
      return Enum$PackageStatus.DEFAULT;
    case r'HIDDEN':
      return Enum$PackageStatus.HIDDEN;
    case r'PROCESSING':
      return Enum$PackageStatus.PROCESSING;
    case r'ERROR':
      return Enum$PackageStatus.ERROR;
    case r'PENDING_DESTRUCTION':
      return Enum$PackageStatus.PENDING_DESTRUCTION;
    default:
      return Enum$PackageStatus.$unknown;
  }
}

enum Enum$PackageTypeEnum {
  MAVEN,
  NPM,
  CONAN,
  NUGET,
  PYPI,
  COMPOSER,
  GENERIC,
  GOLANG,
  DEBIAN,
  RUBYGEMS,
  HELM,
  TERRAFORM_MODULE,
  $unknown
}

String toJson$Enum$PackageTypeEnum(Enum$PackageTypeEnum e) {
  switch (e) {
    case Enum$PackageTypeEnum.MAVEN:
      return r'MAVEN';
    case Enum$PackageTypeEnum.NPM:
      return r'NPM';
    case Enum$PackageTypeEnum.CONAN:
      return r'CONAN';
    case Enum$PackageTypeEnum.NUGET:
      return r'NUGET';
    case Enum$PackageTypeEnum.PYPI:
      return r'PYPI';
    case Enum$PackageTypeEnum.COMPOSER:
      return r'COMPOSER';
    case Enum$PackageTypeEnum.GENERIC:
      return r'GENERIC';
    case Enum$PackageTypeEnum.GOLANG:
      return r'GOLANG';
    case Enum$PackageTypeEnum.DEBIAN:
      return r'DEBIAN';
    case Enum$PackageTypeEnum.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$PackageTypeEnum.HELM:
      return r'HELM';
    case Enum$PackageTypeEnum.TERRAFORM_MODULE:
      return r'TERRAFORM_MODULE';
    case Enum$PackageTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PackageTypeEnum fromJson$Enum$PackageTypeEnum(String value) {
  switch (value) {
    case r'MAVEN':
      return Enum$PackageTypeEnum.MAVEN;
    case r'NPM':
      return Enum$PackageTypeEnum.NPM;
    case r'CONAN':
      return Enum$PackageTypeEnum.CONAN;
    case r'NUGET':
      return Enum$PackageTypeEnum.NUGET;
    case r'PYPI':
      return Enum$PackageTypeEnum.PYPI;
    case r'COMPOSER':
      return Enum$PackageTypeEnum.COMPOSER;
    case r'GENERIC':
      return Enum$PackageTypeEnum.GENERIC;
    case r'GOLANG':
      return Enum$PackageTypeEnum.GOLANG;
    case r'DEBIAN':
      return Enum$PackageTypeEnum.DEBIAN;
    case r'RUBYGEMS':
      return Enum$PackageTypeEnum.RUBYGEMS;
    case r'HELM':
      return Enum$PackageTypeEnum.HELM;
    case r'TERRAFORM_MODULE':
      return Enum$PackageTypeEnum.TERRAFORM_MODULE;
    default:
      return Enum$PackageTypeEnum.$unknown;
  }
}

enum Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum {
  ALL_PACKAGE_FILES,
  ONE_PACKAGE_FILE,
  TEN_PACKAGE_FILES,
  TWENTY_PACKAGE_FILES,
  THIRTY_PACKAGE_FILES,
  FORTY_PACKAGE_FILES,
  FIFTY_PACKAGE_FILES,
  $unknown
}

String toJson$Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum(
    Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum e) {
  switch (e) {
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.ALL_PACKAGE_FILES:
      return r'ALL_PACKAGE_FILES';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.ONE_PACKAGE_FILE:
      return r'ONE_PACKAGE_FILE';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.TEN_PACKAGE_FILES:
      return r'TEN_PACKAGE_FILES';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
        .TWENTY_PACKAGE_FILES:
      return r'TWENTY_PACKAGE_FILES';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
        .THIRTY_PACKAGE_FILES:
      return r'THIRTY_PACKAGE_FILES';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.FORTY_PACKAGE_FILES:
      return r'FORTY_PACKAGE_FILES';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.FIFTY_PACKAGE_FILES:
      return r'FIFTY_PACKAGE_FILES';
    case Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
    fromJson$Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum(String value) {
  switch (value) {
    case r'ALL_PACKAGE_FILES':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .ALL_PACKAGE_FILES;
    case r'ONE_PACKAGE_FILE':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .ONE_PACKAGE_FILE;
    case r'TEN_PACKAGE_FILES':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .TEN_PACKAGE_FILES;
    case r'TWENTY_PACKAGE_FILES':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .TWENTY_PACKAGE_FILES;
    case r'THIRTY_PACKAGE_FILES':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .THIRTY_PACKAGE_FILES;
    case r'FORTY_PACKAGE_FILES':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .FORTY_PACKAGE_FILES;
    case r'FIFTY_PACKAGE_FILES':
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum
          .FIFTY_PACKAGE_FILES;
    default:
      return Enum$PackagesCleanupKeepDuplicatedPackageFilesEnum.$unknown;
  }
}

enum Enum$PipelineConfigSourceEnum {
  UNKNOWN_SOURCE,
  REPOSITORY_SOURCE,
  AUTO_DEVOPS_SOURCE,
  WEBIDE_SOURCE,
  REMOTE_SOURCE,
  EXTERNAL_PROJECT_SOURCE,
  BRIDGE_SOURCE,
  PARAMETER_SOURCE,
  COMPLIANCE_SOURCE,
  $unknown
}

String toJson$Enum$PipelineConfigSourceEnum(Enum$PipelineConfigSourceEnum e) {
  switch (e) {
    case Enum$PipelineConfigSourceEnum.UNKNOWN_SOURCE:
      return r'UNKNOWN_SOURCE';
    case Enum$PipelineConfigSourceEnum.REPOSITORY_SOURCE:
      return r'REPOSITORY_SOURCE';
    case Enum$PipelineConfigSourceEnum.AUTO_DEVOPS_SOURCE:
      return r'AUTO_DEVOPS_SOURCE';
    case Enum$PipelineConfigSourceEnum.WEBIDE_SOURCE:
      return r'WEBIDE_SOURCE';
    case Enum$PipelineConfigSourceEnum.REMOTE_SOURCE:
      return r'REMOTE_SOURCE';
    case Enum$PipelineConfigSourceEnum.EXTERNAL_PROJECT_SOURCE:
      return r'EXTERNAL_PROJECT_SOURCE';
    case Enum$PipelineConfigSourceEnum.BRIDGE_SOURCE:
      return r'BRIDGE_SOURCE';
    case Enum$PipelineConfigSourceEnum.PARAMETER_SOURCE:
      return r'PARAMETER_SOURCE';
    case Enum$PipelineConfigSourceEnum.COMPLIANCE_SOURCE:
      return r'COMPLIANCE_SOURCE';
    case Enum$PipelineConfigSourceEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PipelineConfigSourceEnum fromJson$Enum$PipelineConfigSourceEnum(
    String value) {
  switch (value) {
    case r'UNKNOWN_SOURCE':
      return Enum$PipelineConfigSourceEnum.UNKNOWN_SOURCE;
    case r'REPOSITORY_SOURCE':
      return Enum$PipelineConfigSourceEnum.REPOSITORY_SOURCE;
    case r'AUTO_DEVOPS_SOURCE':
      return Enum$PipelineConfigSourceEnum.AUTO_DEVOPS_SOURCE;
    case r'WEBIDE_SOURCE':
      return Enum$PipelineConfigSourceEnum.WEBIDE_SOURCE;
    case r'REMOTE_SOURCE':
      return Enum$PipelineConfigSourceEnum.REMOTE_SOURCE;
    case r'EXTERNAL_PROJECT_SOURCE':
      return Enum$PipelineConfigSourceEnum.EXTERNAL_PROJECT_SOURCE;
    case r'BRIDGE_SOURCE':
      return Enum$PipelineConfigSourceEnum.BRIDGE_SOURCE;
    case r'PARAMETER_SOURCE':
      return Enum$PipelineConfigSourceEnum.PARAMETER_SOURCE;
    case r'COMPLIANCE_SOURCE':
      return Enum$PipelineConfigSourceEnum.COMPLIANCE_SOURCE;
    default:
      return Enum$PipelineConfigSourceEnum.$unknown;
  }
}

enum Enum$PipelineMergeRequestEventType {
  MERGED_RESULT,
  DETACHED,
  MERGE_TRAIN,
  $unknown
}

String toJson$Enum$PipelineMergeRequestEventType(
    Enum$PipelineMergeRequestEventType e) {
  switch (e) {
    case Enum$PipelineMergeRequestEventType.MERGED_RESULT:
      return r'MERGED_RESULT';
    case Enum$PipelineMergeRequestEventType.DETACHED:
      return r'DETACHED';
    case Enum$PipelineMergeRequestEventType.MERGE_TRAIN:
      return r'MERGE_TRAIN';
    case Enum$PipelineMergeRequestEventType.$unknown:
      return r'$unknown';
  }
}

Enum$PipelineMergeRequestEventType fromJson$Enum$PipelineMergeRequestEventType(
    String value) {
  switch (value) {
    case r'MERGED_RESULT':
      return Enum$PipelineMergeRequestEventType.MERGED_RESULT;
    case r'DETACHED':
      return Enum$PipelineMergeRequestEventType.DETACHED;
    case r'MERGE_TRAIN':
      return Enum$PipelineMergeRequestEventType.MERGE_TRAIN;
    default:
      return Enum$PipelineMergeRequestEventType.$unknown;
  }
}

enum Enum$PipelineScopeEnum {
  RUNNING,
  PENDING,
  FINISHED,
  BRANCHES,
  TAGS,
  $unknown
}

String toJson$Enum$PipelineScopeEnum(Enum$PipelineScopeEnum e) {
  switch (e) {
    case Enum$PipelineScopeEnum.RUNNING:
      return r'RUNNING';
    case Enum$PipelineScopeEnum.PENDING:
      return r'PENDING';
    case Enum$PipelineScopeEnum.FINISHED:
      return r'FINISHED';
    case Enum$PipelineScopeEnum.BRANCHES:
      return r'BRANCHES';
    case Enum$PipelineScopeEnum.TAGS:
      return r'TAGS';
    case Enum$PipelineScopeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PipelineScopeEnum fromJson$Enum$PipelineScopeEnum(String value) {
  switch (value) {
    case r'RUNNING':
      return Enum$PipelineScopeEnum.RUNNING;
    case r'PENDING':
      return Enum$PipelineScopeEnum.PENDING;
    case r'FINISHED':
      return Enum$PipelineScopeEnum.FINISHED;
    case r'BRANCHES':
      return Enum$PipelineScopeEnum.BRANCHES;
    case r'TAGS':
      return Enum$PipelineScopeEnum.TAGS;
    default:
      return Enum$PipelineScopeEnum.$unknown;
  }
}

enum Enum$PipelineStatusEnum {
  CREATED,
  WAITING_FOR_RESOURCE,
  PREPARING,
  PENDING,
  RUNNING,
  FAILED,
  SUCCESS,
  CANCELED,
  SKIPPED,
  MANUAL,
  SCHEDULED,
  $unknown
}

String toJson$Enum$PipelineStatusEnum(Enum$PipelineStatusEnum e) {
  switch (e) {
    case Enum$PipelineStatusEnum.CREATED:
      return r'CREATED';
    case Enum$PipelineStatusEnum.WAITING_FOR_RESOURCE:
      return r'WAITING_FOR_RESOURCE';
    case Enum$PipelineStatusEnum.PREPARING:
      return r'PREPARING';
    case Enum$PipelineStatusEnum.PENDING:
      return r'PENDING';
    case Enum$PipelineStatusEnum.RUNNING:
      return r'RUNNING';
    case Enum$PipelineStatusEnum.FAILED:
      return r'FAILED';
    case Enum$PipelineStatusEnum.SUCCESS:
      return r'SUCCESS';
    case Enum$PipelineStatusEnum.CANCELED:
      return r'CANCELED';
    case Enum$PipelineStatusEnum.SKIPPED:
      return r'SKIPPED';
    case Enum$PipelineStatusEnum.MANUAL:
      return r'MANUAL';
    case Enum$PipelineStatusEnum.SCHEDULED:
      return r'SCHEDULED';
    case Enum$PipelineStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PipelineStatusEnum fromJson$Enum$PipelineStatusEnum(String value) {
  switch (value) {
    case r'CREATED':
      return Enum$PipelineStatusEnum.CREATED;
    case r'WAITING_FOR_RESOURCE':
      return Enum$PipelineStatusEnum.WAITING_FOR_RESOURCE;
    case r'PREPARING':
      return Enum$PipelineStatusEnum.PREPARING;
    case r'PENDING':
      return Enum$PipelineStatusEnum.PENDING;
    case r'RUNNING':
      return Enum$PipelineStatusEnum.RUNNING;
    case r'FAILED':
      return Enum$PipelineStatusEnum.FAILED;
    case r'SUCCESS':
      return Enum$PipelineStatusEnum.SUCCESS;
    case r'CANCELED':
      return Enum$PipelineStatusEnum.CANCELED;
    case r'SKIPPED':
      return Enum$PipelineStatusEnum.SKIPPED;
    case r'MANUAL':
      return Enum$PipelineStatusEnum.MANUAL;
    case r'SCHEDULED':
      return Enum$PipelineStatusEnum.SCHEDULED;
    default:
      return Enum$PipelineStatusEnum.$unknown;
  }
}

enum Enum$ProjectMemberRelation {
  DIRECT,
  INHERITED,
  DESCENDANTS,
  INVITED_GROUPS,
  $unknown
}

String toJson$Enum$ProjectMemberRelation(Enum$ProjectMemberRelation e) {
  switch (e) {
    case Enum$ProjectMemberRelation.DIRECT:
      return r'DIRECT';
    case Enum$ProjectMemberRelation.INHERITED:
      return r'INHERITED';
    case Enum$ProjectMemberRelation.DESCENDANTS:
      return r'DESCENDANTS';
    case Enum$ProjectMemberRelation.INVITED_GROUPS:
      return r'INVITED_GROUPS';
    case Enum$ProjectMemberRelation.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectMemberRelation fromJson$Enum$ProjectMemberRelation(String value) {
  switch (value) {
    case r'DIRECT':
      return Enum$ProjectMemberRelation.DIRECT;
    case r'INHERITED':
      return Enum$ProjectMemberRelation.INHERITED;
    case r'DESCENDANTS':
      return Enum$ProjectMemberRelation.DESCENDANTS;
    case r'INVITED_GROUPS':
      return Enum$ProjectMemberRelation.INVITED_GROUPS;
    default:
      return Enum$ProjectMemberRelation.$unknown;
  }
}

enum Enum$RegistryState { PENDING, STARTED, SYNCED, FAILED, $unknown }

String toJson$Enum$RegistryState(Enum$RegistryState e) {
  switch (e) {
    case Enum$RegistryState.PENDING:
      return r'PENDING';
    case Enum$RegistryState.STARTED:
      return r'STARTED';
    case Enum$RegistryState.SYNCED:
      return r'SYNCED';
    case Enum$RegistryState.FAILED:
      return r'FAILED';
    case Enum$RegistryState.$unknown:
      return r'$unknown';
  }
}

Enum$RegistryState fromJson$Enum$RegistryState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$RegistryState.PENDING;
    case r'STARTED':
      return Enum$RegistryState.STARTED;
    case r'SYNCED':
      return Enum$RegistryState.SYNCED;
    case r'FAILED':
      return Enum$RegistryState.FAILED;
    default:
      return Enum$RegistryState.$unknown;
  }
}

enum Enum$ReleaseAssetLinkType { OTHER, RUNBOOK, PACKAGE, IMAGE, $unknown }

String toJson$Enum$ReleaseAssetLinkType(Enum$ReleaseAssetLinkType e) {
  switch (e) {
    case Enum$ReleaseAssetLinkType.OTHER:
      return r'OTHER';
    case Enum$ReleaseAssetLinkType.RUNBOOK:
      return r'RUNBOOK';
    case Enum$ReleaseAssetLinkType.PACKAGE:
      return r'PACKAGE';
    case Enum$ReleaseAssetLinkType.IMAGE:
      return r'IMAGE';
    case Enum$ReleaseAssetLinkType.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseAssetLinkType fromJson$Enum$ReleaseAssetLinkType(String value) {
  switch (value) {
    case r'OTHER':
      return Enum$ReleaseAssetLinkType.OTHER;
    case r'RUNBOOK':
      return Enum$ReleaseAssetLinkType.RUNBOOK;
    case r'PACKAGE':
      return Enum$ReleaseAssetLinkType.PACKAGE;
    case r'IMAGE':
      return Enum$ReleaseAssetLinkType.IMAGE;
    default:
      return Enum$ReleaseAssetLinkType.$unknown;
  }
}

enum Enum$ReleaseSort {
  CREATED_DESC,
  CREATED_ASC,
  RELEASED_AT_DESC,
  RELEASED_AT_ASC,
  $unknown
}

String toJson$Enum$ReleaseSort(Enum$ReleaseSort e) {
  switch (e) {
    case Enum$ReleaseSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$ReleaseSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$ReleaseSort.RELEASED_AT_DESC:
      return r'RELEASED_AT_DESC';
    case Enum$ReleaseSort.RELEASED_AT_ASC:
      return r'RELEASED_AT_ASC';
    case Enum$ReleaseSort.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseSort fromJson$Enum$ReleaseSort(String value) {
  switch (value) {
    case r'CREATED_DESC':
      return Enum$ReleaseSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$ReleaseSort.CREATED_ASC;
    case r'RELEASED_AT_DESC':
      return Enum$ReleaseSort.RELEASED_AT_DESC;
    case r'RELEASED_AT_ASC':
      return Enum$ReleaseSort.RELEASED_AT_ASC;
    default:
      return Enum$ReleaseSort.$unknown;
  }
}

enum Enum$ReleaseTagWildcardId { NONE, ANY, $unknown }

String toJson$Enum$ReleaseTagWildcardId(Enum$ReleaseTagWildcardId e) {
  switch (e) {
    case Enum$ReleaseTagWildcardId.NONE:
      return r'NONE';
    case Enum$ReleaseTagWildcardId.ANY:
      return r'ANY';
    case Enum$ReleaseTagWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseTagWildcardId fromJson$Enum$ReleaseTagWildcardId(String value) {
  switch (value) {
    case r'NONE':
      return Enum$ReleaseTagWildcardId.NONE;
    case r'ANY':
      return Enum$ReleaseTagWildcardId.ANY;
    default:
      return Enum$ReleaseTagWildcardId.$unknown;
  }
}

enum Enum$ReplicationStateEnum { PENDING, STARTED, SYNCED, FAILED, $unknown }

String toJson$Enum$ReplicationStateEnum(Enum$ReplicationStateEnum e) {
  switch (e) {
    case Enum$ReplicationStateEnum.PENDING:
      return r'PENDING';
    case Enum$ReplicationStateEnum.STARTED:
      return r'STARTED';
    case Enum$ReplicationStateEnum.SYNCED:
      return r'SYNCED';
    case Enum$ReplicationStateEnum.FAILED:
      return r'FAILED';
    case Enum$ReplicationStateEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ReplicationStateEnum fromJson$Enum$ReplicationStateEnum(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$ReplicationStateEnum.PENDING;
    case r'STARTED':
      return Enum$ReplicationStateEnum.STARTED;
    case r'SYNCED':
      return Enum$ReplicationStateEnum.SYNCED;
    case r'FAILED':
      return Enum$ReplicationStateEnum.FAILED;
    default:
      return Enum$ReplicationStateEnum.$unknown;
  }
}

enum Enum$RequirementState { OPENED, ARCHIVED, $unknown }

String toJson$Enum$RequirementState(Enum$RequirementState e) {
  switch (e) {
    case Enum$RequirementState.OPENED:
      return r'OPENED';
    case Enum$RequirementState.ARCHIVED:
      return r'ARCHIVED';
    case Enum$RequirementState.$unknown:
      return r'$unknown';
  }
}

Enum$RequirementState fromJson$Enum$RequirementState(String value) {
  switch (value) {
    case r'OPENED':
      return Enum$RequirementState.OPENED;
    case r'ARCHIVED':
      return Enum$RequirementState.ARCHIVED;
    default:
      return Enum$RequirementState.$unknown;
  }
}

enum Enum$RequirementStatusFilter { MISSING, PASSED, FAILED, $unknown }

String toJson$Enum$RequirementStatusFilter(Enum$RequirementStatusFilter e) {
  switch (e) {
    case Enum$RequirementStatusFilter.MISSING:
      return r'MISSING';
    case Enum$RequirementStatusFilter.PASSED:
      return r'PASSED';
    case Enum$RequirementStatusFilter.FAILED:
      return r'FAILED';
    case Enum$RequirementStatusFilter.$unknown:
      return r'$unknown';
  }
}

Enum$RequirementStatusFilter fromJson$Enum$RequirementStatusFilter(
    String value) {
  switch (value) {
    case r'MISSING':
      return Enum$RequirementStatusFilter.MISSING;
    case r'PASSED':
      return Enum$RequirementStatusFilter.PASSED;
    case r'FAILED':
      return Enum$RequirementStatusFilter.FAILED;
    default:
      return Enum$RequirementStatusFilter.$unknown;
  }
}

enum Enum$RunnerMembershipFilter { DIRECT, DESCENDANTS, $unknown }

String toJson$Enum$RunnerMembershipFilter(Enum$RunnerMembershipFilter e) {
  switch (e) {
    case Enum$RunnerMembershipFilter.DIRECT:
      return r'DIRECT';
    case Enum$RunnerMembershipFilter.DESCENDANTS:
      return r'DESCENDANTS';
    case Enum$RunnerMembershipFilter.$unknown:
      return r'$unknown';
  }
}

Enum$RunnerMembershipFilter fromJson$Enum$RunnerMembershipFilter(String value) {
  switch (value) {
    case r'DIRECT':
      return Enum$RunnerMembershipFilter.DIRECT;
    case r'DESCENDANTS':
      return Enum$RunnerMembershipFilter.DESCENDANTS;
    default:
      return Enum$RunnerMembershipFilter.$unknown;
  }
}

enum Enum$SastUiComponentSize { SMALL, MEDIUM, LARGE, $unknown }

String toJson$Enum$SastUiComponentSize(Enum$SastUiComponentSize e) {
  switch (e) {
    case Enum$SastUiComponentSize.SMALL:
      return r'SMALL';
    case Enum$SastUiComponentSize.MEDIUM:
      return r'MEDIUM';
    case Enum$SastUiComponentSize.LARGE:
      return r'LARGE';
    case Enum$SastUiComponentSize.$unknown:
      return r'$unknown';
  }
}

Enum$SastUiComponentSize fromJson$Enum$SastUiComponentSize(String value) {
  switch (value) {
    case r'SMALL':
      return Enum$SastUiComponentSize.SMALL;
    case r'MEDIUM':
      return Enum$SastUiComponentSize.MEDIUM;
    case r'LARGE':
      return Enum$SastUiComponentSize.LARGE;
    default:
      return Enum$SastUiComponentSize.$unknown;
  }
}

enum Enum$ScanStatus {
  CREATED,
  SUCCEEDED,
  JOB_FAILED,
  REPORT_ERROR,
  PREPARING,
  PREPARATION_FAILED,
  PURGED,
  $unknown
}

String toJson$Enum$ScanStatus(Enum$ScanStatus e) {
  switch (e) {
    case Enum$ScanStatus.CREATED:
      return r'CREATED';
    case Enum$ScanStatus.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$ScanStatus.JOB_FAILED:
      return r'JOB_FAILED';
    case Enum$ScanStatus.REPORT_ERROR:
      return r'REPORT_ERROR';
    case Enum$ScanStatus.PREPARING:
      return r'PREPARING';
    case Enum$ScanStatus.PREPARATION_FAILED:
      return r'PREPARATION_FAILED';
    case Enum$ScanStatus.PURGED:
      return r'PURGED';
    case Enum$ScanStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ScanStatus fromJson$Enum$ScanStatus(String value) {
  switch (value) {
    case r'CREATED':
      return Enum$ScanStatus.CREATED;
    case r'SUCCEEDED':
      return Enum$ScanStatus.SUCCEEDED;
    case r'JOB_FAILED':
      return Enum$ScanStatus.JOB_FAILED;
    case r'REPORT_ERROR':
      return Enum$ScanStatus.REPORT_ERROR;
    case r'PREPARING':
      return Enum$ScanStatus.PREPARING;
    case r'PREPARATION_FAILED':
      return Enum$ScanStatus.PREPARATION_FAILED;
    case r'PURGED':
      return Enum$ScanStatus.PURGED;
    default:
      return Enum$ScanStatus.$unknown;
  }
}

enum Enum$SecurityPolicyRelationType {
  DIRECT,
  INHERITED,
  INHERITED_ONLY,
  $unknown
}

String toJson$Enum$SecurityPolicyRelationType(
    Enum$SecurityPolicyRelationType e) {
  switch (e) {
    case Enum$SecurityPolicyRelationType.DIRECT:
      return r'DIRECT';
    case Enum$SecurityPolicyRelationType.INHERITED:
      return r'INHERITED';
    case Enum$SecurityPolicyRelationType.INHERITED_ONLY:
      return r'INHERITED_ONLY';
    case Enum$SecurityPolicyRelationType.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityPolicyRelationType fromJson$Enum$SecurityPolicyRelationType(
    String value) {
  switch (value) {
    case r'DIRECT':
      return Enum$SecurityPolicyRelationType.DIRECT;
    case r'INHERITED':
      return Enum$SecurityPolicyRelationType.INHERITED;
    case r'INHERITED_ONLY':
      return Enum$SecurityPolicyRelationType.INHERITED_ONLY;
    default:
      return Enum$SecurityPolicyRelationType.$unknown;
  }
}

enum Enum$SecurityReportTypeEnum {
  SAST,
  SAST_IAC,
  DAST,
  DEPENDENCY_SCANNING,
  CONTAINER_SCANNING,
  SECRET_DETECTION,
  COVERAGE_FUZZING,
  API_FUZZING,
  CLUSTER_IMAGE_SCANNING,
  $unknown
}

String toJson$Enum$SecurityReportTypeEnum(Enum$SecurityReportTypeEnum e) {
  switch (e) {
    case Enum$SecurityReportTypeEnum.SAST:
      return r'SAST';
    case Enum$SecurityReportTypeEnum.SAST_IAC:
      return r'SAST_IAC';
    case Enum$SecurityReportTypeEnum.DAST:
      return r'DAST';
    case Enum$SecurityReportTypeEnum.DEPENDENCY_SCANNING:
      return r'DEPENDENCY_SCANNING';
    case Enum$SecurityReportTypeEnum.CONTAINER_SCANNING:
      return r'CONTAINER_SCANNING';
    case Enum$SecurityReportTypeEnum.SECRET_DETECTION:
      return r'SECRET_DETECTION';
    case Enum$SecurityReportTypeEnum.COVERAGE_FUZZING:
      return r'COVERAGE_FUZZING';
    case Enum$SecurityReportTypeEnum.API_FUZZING:
      return r'API_FUZZING';
    case Enum$SecurityReportTypeEnum.CLUSTER_IMAGE_SCANNING:
      return r'CLUSTER_IMAGE_SCANNING';
    case Enum$SecurityReportTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityReportTypeEnum fromJson$Enum$SecurityReportTypeEnum(String value) {
  switch (value) {
    case r'SAST':
      return Enum$SecurityReportTypeEnum.SAST;
    case r'SAST_IAC':
      return Enum$SecurityReportTypeEnum.SAST_IAC;
    case r'DAST':
      return Enum$SecurityReportTypeEnum.DAST;
    case r'DEPENDENCY_SCANNING':
      return Enum$SecurityReportTypeEnum.DEPENDENCY_SCANNING;
    case r'CONTAINER_SCANNING':
      return Enum$SecurityReportTypeEnum.CONTAINER_SCANNING;
    case r'SECRET_DETECTION':
      return Enum$SecurityReportTypeEnum.SECRET_DETECTION;
    case r'COVERAGE_FUZZING':
      return Enum$SecurityReportTypeEnum.COVERAGE_FUZZING;
    case r'API_FUZZING':
      return Enum$SecurityReportTypeEnum.API_FUZZING;
    case r'CLUSTER_IMAGE_SCANNING':
      return Enum$SecurityReportTypeEnum.CLUSTER_IMAGE_SCANNING;
    default:
      return Enum$SecurityReportTypeEnum.$unknown;
  }
}

enum Enum$SecurityScannerType {
  SAST,
  SAST_IAC,
  DAST,
  DEPENDENCY_SCANNING,
  CONTAINER_SCANNING,
  SECRET_DETECTION,
  COVERAGE_FUZZING,
  API_FUZZING,
  CLUSTER_IMAGE_SCANNING,
  $unknown
}

String toJson$Enum$SecurityScannerType(Enum$SecurityScannerType e) {
  switch (e) {
    case Enum$SecurityScannerType.SAST:
      return r'SAST';
    case Enum$SecurityScannerType.SAST_IAC:
      return r'SAST_IAC';
    case Enum$SecurityScannerType.DAST:
      return r'DAST';
    case Enum$SecurityScannerType.DEPENDENCY_SCANNING:
      return r'DEPENDENCY_SCANNING';
    case Enum$SecurityScannerType.CONTAINER_SCANNING:
      return r'CONTAINER_SCANNING';
    case Enum$SecurityScannerType.SECRET_DETECTION:
      return r'SECRET_DETECTION';
    case Enum$SecurityScannerType.COVERAGE_FUZZING:
      return r'COVERAGE_FUZZING';
    case Enum$SecurityScannerType.API_FUZZING:
      return r'API_FUZZING';
    case Enum$SecurityScannerType.CLUSTER_IMAGE_SCANNING:
      return r'CLUSTER_IMAGE_SCANNING';
    case Enum$SecurityScannerType.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityScannerType fromJson$Enum$SecurityScannerType(String value) {
  switch (value) {
    case r'SAST':
      return Enum$SecurityScannerType.SAST;
    case r'SAST_IAC':
      return Enum$SecurityScannerType.SAST_IAC;
    case r'DAST':
      return Enum$SecurityScannerType.DAST;
    case r'DEPENDENCY_SCANNING':
      return Enum$SecurityScannerType.DEPENDENCY_SCANNING;
    case r'CONTAINER_SCANNING':
      return Enum$SecurityScannerType.CONTAINER_SCANNING;
    case r'SECRET_DETECTION':
      return Enum$SecurityScannerType.SECRET_DETECTION;
    case r'COVERAGE_FUZZING':
      return Enum$SecurityScannerType.COVERAGE_FUZZING;
    case r'API_FUZZING':
      return Enum$SecurityScannerType.API_FUZZING;
    case r'CLUSTER_IMAGE_SCANNING':
      return Enum$SecurityScannerType.CLUSTER_IMAGE_SCANNING;
    default:
      return Enum$SecurityScannerType.$unknown;
  }
}

enum Enum$SentryErrorStatus {
  RESOLVED,
  RESOLVED_IN_NEXT_RELEASE,
  UNRESOLVED,
  IGNORED,
  $unknown
}

String toJson$Enum$SentryErrorStatus(Enum$SentryErrorStatus e) {
  switch (e) {
    case Enum$SentryErrorStatus.RESOLVED:
      return r'RESOLVED';
    case Enum$SentryErrorStatus.RESOLVED_IN_NEXT_RELEASE:
      return r'RESOLVED_IN_NEXT_RELEASE';
    case Enum$SentryErrorStatus.UNRESOLVED:
      return r'UNRESOLVED';
    case Enum$SentryErrorStatus.IGNORED:
      return r'IGNORED';
    case Enum$SentryErrorStatus.$unknown:
      return r'$unknown';
  }
}

Enum$SentryErrorStatus fromJson$Enum$SentryErrorStatus(String value) {
  switch (value) {
    case r'RESOLVED':
      return Enum$SentryErrorStatus.RESOLVED;
    case r'RESOLVED_IN_NEXT_RELEASE':
      return Enum$SentryErrorStatus.RESOLVED_IN_NEXT_RELEASE;
    case r'UNRESOLVED':
      return Enum$SentryErrorStatus.UNRESOLVED;
    case r'IGNORED':
      return Enum$SentryErrorStatus.IGNORED;
    default:
      return Enum$SentryErrorStatus.$unknown;
  }
}

enum Enum$ServiceType {
  ASANA_SERVICE,
  ASSEMBLA_SERVICE,
  BAMBOO_SERVICE,
  BUGZILLA_SERVICE,
  BUILDKITE_SERVICE,
  CAMPFIRE_SERVICE,
  CONFLUENCE_SERVICE,
  CUSTOM_ISSUE_TRACKER_SERVICE,
  DATADOG_SERVICE,
  DISCORD_SERVICE,
  DRONE_CI_SERVICE,
  EMAILS_ON_PUSH_SERVICE,
  EWM_SERVICE,
  EXTERNAL_WIKI_SERVICE,
  FLOWDOCK_SERVICE,
  GITHUB_SERVICE,
  GITLAB_SLACK_APPLICATION_SERVICE,
  HANGOUTS_CHAT_SERVICE,
  HARBOR_SERVICE,
  IRKER_SERVICE,
  JENKINS_SERVICE,
  JIRA_SERVICE,
  MATTERMOST_SERVICE,
  MATTERMOST_SLASH_COMMANDS_SERVICE,
  MICROSOFT_TEAMS_SERVICE,
  PACKAGIST_SERVICE,
  PIPELINES_EMAIL_SERVICE,
  PIVOTALTRACKER_SERVICE,
  PROMETHEUS_SERVICE,
  PUMBLE_SERVICE,
  PUSHOVER_SERVICE,
  REDMINE_SERVICE,
  SHIMO_SERVICE,
  SLACK_SERVICE,
  SLACK_SLASH_COMMANDS_SERVICE,
  TEAMCITY_SERVICE,
  UNIFY_CIRCUIT_SERVICE,
  WEBEX_TEAMS_SERVICE,
  YOUTRACK_SERVICE,
  ZENTAO_SERVICE,
  $unknown
}

String toJson$Enum$ServiceType(Enum$ServiceType e) {
  switch (e) {
    case Enum$ServiceType.ASANA_SERVICE:
      return r'ASANA_SERVICE';
    case Enum$ServiceType.ASSEMBLA_SERVICE:
      return r'ASSEMBLA_SERVICE';
    case Enum$ServiceType.BAMBOO_SERVICE:
      return r'BAMBOO_SERVICE';
    case Enum$ServiceType.BUGZILLA_SERVICE:
      return r'BUGZILLA_SERVICE';
    case Enum$ServiceType.BUILDKITE_SERVICE:
      return r'BUILDKITE_SERVICE';
    case Enum$ServiceType.CAMPFIRE_SERVICE:
      return r'CAMPFIRE_SERVICE';
    case Enum$ServiceType.CONFLUENCE_SERVICE:
      return r'CONFLUENCE_SERVICE';
    case Enum$ServiceType.CUSTOM_ISSUE_TRACKER_SERVICE:
      return r'CUSTOM_ISSUE_TRACKER_SERVICE';
    case Enum$ServiceType.DATADOG_SERVICE:
      return r'DATADOG_SERVICE';
    case Enum$ServiceType.DISCORD_SERVICE:
      return r'DISCORD_SERVICE';
    case Enum$ServiceType.DRONE_CI_SERVICE:
      return r'DRONE_CI_SERVICE';
    case Enum$ServiceType.EMAILS_ON_PUSH_SERVICE:
      return r'EMAILS_ON_PUSH_SERVICE';
    case Enum$ServiceType.EWM_SERVICE:
      return r'EWM_SERVICE';
    case Enum$ServiceType.EXTERNAL_WIKI_SERVICE:
      return r'EXTERNAL_WIKI_SERVICE';
    case Enum$ServiceType.FLOWDOCK_SERVICE:
      return r'FLOWDOCK_SERVICE';
    case Enum$ServiceType.GITHUB_SERVICE:
      return r'GITHUB_SERVICE';
    case Enum$ServiceType.GITLAB_SLACK_APPLICATION_SERVICE:
      return r'GITLAB_SLACK_APPLICATION_SERVICE';
    case Enum$ServiceType.HANGOUTS_CHAT_SERVICE:
      return r'HANGOUTS_CHAT_SERVICE';
    case Enum$ServiceType.HARBOR_SERVICE:
      return r'HARBOR_SERVICE';
    case Enum$ServiceType.IRKER_SERVICE:
      return r'IRKER_SERVICE';
    case Enum$ServiceType.JENKINS_SERVICE:
      return r'JENKINS_SERVICE';
    case Enum$ServiceType.JIRA_SERVICE:
      return r'JIRA_SERVICE';
    case Enum$ServiceType.MATTERMOST_SERVICE:
      return r'MATTERMOST_SERVICE';
    case Enum$ServiceType.MATTERMOST_SLASH_COMMANDS_SERVICE:
      return r'MATTERMOST_SLASH_COMMANDS_SERVICE';
    case Enum$ServiceType.MICROSOFT_TEAMS_SERVICE:
      return r'MICROSOFT_TEAMS_SERVICE';
    case Enum$ServiceType.PACKAGIST_SERVICE:
      return r'PACKAGIST_SERVICE';
    case Enum$ServiceType.PIPELINES_EMAIL_SERVICE:
      return r'PIPELINES_EMAIL_SERVICE';
    case Enum$ServiceType.PIVOTALTRACKER_SERVICE:
      return r'PIVOTALTRACKER_SERVICE';
    case Enum$ServiceType.PROMETHEUS_SERVICE:
      return r'PROMETHEUS_SERVICE';
    case Enum$ServiceType.PUMBLE_SERVICE:
      return r'PUMBLE_SERVICE';
    case Enum$ServiceType.PUSHOVER_SERVICE:
      return r'PUSHOVER_SERVICE';
    case Enum$ServiceType.REDMINE_SERVICE:
      return r'REDMINE_SERVICE';
    case Enum$ServiceType.SHIMO_SERVICE:
      return r'SHIMO_SERVICE';
    case Enum$ServiceType.SLACK_SERVICE:
      return r'SLACK_SERVICE';
    case Enum$ServiceType.SLACK_SLASH_COMMANDS_SERVICE:
      return r'SLACK_SLASH_COMMANDS_SERVICE';
    case Enum$ServiceType.TEAMCITY_SERVICE:
      return r'TEAMCITY_SERVICE';
    case Enum$ServiceType.UNIFY_CIRCUIT_SERVICE:
      return r'UNIFY_CIRCUIT_SERVICE';
    case Enum$ServiceType.WEBEX_TEAMS_SERVICE:
      return r'WEBEX_TEAMS_SERVICE';
    case Enum$ServiceType.YOUTRACK_SERVICE:
      return r'YOUTRACK_SERVICE';
    case Enum$ServiceType.ZENTAO_SERVICE:
      return r'ZENTAO_SERVICE';
    case Enum$ServiceType.$unknown:
      return r'$unknown';
  }
}

Enum$ServiceType fromJson$Enum$ServiceType(String value) {
  switch (value) {
    case r'ASANA_SERVICE':
      return Enum$ServiceType.ASANA_SERVICE;
    case r'ASSEMBLA_SERVICE':
      return Enum$ServiceType.ASSEMBLA_SERVICE;
    case r'BAMBOO_SERVICE':
      return Enum$ServiceType.BAMBOO_SERVICE;
    case r'BUGZILLA_SERVICE':
      return Enum$ServiceType.BUGZILLA_SERVICE;
    case r'BUILDKITE_SERVICE':
      return Enum$ServiceType.BUILDKITE_SERVICE;
    case r'CAMPFIRE_SERVICE':
      return Enum$ServiceType.CAMPFIRE_SERVICE;
    case r'CONFLUENCE_SERVICE':
      return Enum$ServiceType.CONFLUENCE_SERVICE;
    case r'CUSTOM_ISSUE_TRACKER_SERVICE':
      return Enum$ServiceType.CUSTOM_ISSUE_TRACKER_SERVICE;
    case r'DATADOG_SERVICE':
      return Enum$ServiceType.DATADOG_SERVICE;
    case r'DISCORD_SERVICE':
      return Enum$ServiceType.DISCORD_SERVICE;
    case r'DRONE_CI_SERVICE':
      return Enum$ServiceType.DRONE_CI_SERVICE;
    case r'EMAILS_ON_PUSH_SERVICE':
      return Enum$ServiceType.EMAILS_ON_PUSH_SERVICE;
    case r'EWM_SERVICE':
      return Enum$ServiceType.EWM_SERVICE;
    case r'EXTERNAL_WIKI_SERVICE':
      return Enum$ServiceType.EXTERNAL_WIKI_SERVICE;
    case r'FLOWDOCK_SERVICE':
      return Enum$ServiceType.FLOWDOCK_SERVICE;
    case r'GITHUB_SERVICE':
      return Enum$ServiceType.GITHUB_SERVICE;
    case r'GITLAB_SLACK_APPLICATION_SERVICE':
      return Enum$ServiceType.GITLAB_SLACK_APPLICATION_SERVICE;
    case r'HANGOUTS_CHAT_SERVICE':
      return Enum$ServiceType.HANGOUTS_CHAT_SERVICE;
    case r'HARBOR_SERVICE':
      return Enum$ServiceType.HARBOR_SERVICE;
    case r'IRKER_SERVICE':
      return Enum$ServiceType.IRKER_SERVICE;
    case r'JENKINS_SERVICE':
      return Enum$ServiceType.JENKINS_SERVICE;
    case r'JIRA_SERVICE':
      return Enum$ServiceType.JIRA_SERVICE;
    case r'MATTERMOST_SERVICE':
      return Enum$ServiceType.MATTERMOST_SERVICE;
    case r'MATTERMOST_SLASH_COMMANDS_SERVICE':
      return Enum$ServiceType.MATTERMOST_SLASH_COMMANDS_SERVICE;
    case r'MICROSOFT_TEAMS_SERVICE':
      return Enum$ServiceType.MICROSOFT_TEAMS_SERVICE;
    case r'PACKAGIST_SERVICE':
      return Enum$ServiceType.PACKAGIST_SERVICE;
    case r'PIPELINES_EMAIL_SERVICE':
      return Enum$ServiceType.PIPELINES_EMAIL_SERVICE;
    case r'PIVOTALTRACKER_SERVICE':
      return Enum$ServiceType.PIVOTALTRACKER_SERVICE;
    case r'PROMETHEUS_SERVICE':
      return Enum$ServiceType.PROMETHEUS_SERVICE;
    case r'PUMBLE_SERVICE':
      return Enum$ServiceType.PUMBLE_SERVICE;
    case r'PUSHOVER_SERVICE':
      return Enum$ServiceType.PUSHOVER_SERVICE;
    case r'REDMINE_SERVICE':
      return Enum$ServiceType.REDMINE_SERVICE;
    case r'SHIMO_SERVICE':
      return Enum$ServiceType.SHIMO_SERVICE;
    case r'SLACK_SERVICE':
      return Enum$ServiceType.SLACK_SERVICE;
    case r'SLACK_SLASH_COMMANDS_SERVICE':
      return Enum$ServiceType.SLACK_SLASH_COMMANDS_SERVICE;
    case r'TEAMCITY_SERVICE':
      return Enum$ServiceType.TEAMCITY_SERVICE;
    case r'UNIFY_CIRCUIT_SERVICE':
      return Enum$ServiceType.UNIFY_CIRCUIT_SERVICE;
    case r'WEBEX_TEAMS_SERVICE':
      return Enum$ServiceType.WEBEX_TEAMS_SERVICE;
    case r'YOUTRACK_SERVICE':
      return Enum$ServiceType.YOUTRACK_SERVICE;
    case r'ZENTAO_SERVICE':
      return Enum$ServiceType.ZENTAO_SERVICE;
    default:
      return Enum$ServiceType.$unknown;
  }
}

enum Enum$ShaFormat { SHORT, LONG, $unknown }

String toJson$Enum$ShaFormat(Enum$ShaFormat e) {
  switch (e) {
    case Enum$ShaFormat.SHORT:
      return r'SHORT';
    case Enum$ShaFormat.LONG:
      return r'LONG';
    case Enum$ShaFormat.$unknown:
      return r'$unknown';
  }
}

Enum$ShaFormat fromJson$Enum$ShaFormat(String value) {
  switch (value) {
    case r'SHORT':
      return Enum$ShaFormat.SHORT;
    case r'LONG':
      return Enum$ShaFormat.LONG;
    default:
      return Enum$ShaFormat.$unknown;
  }
}

enum Enum$SharedRunnersSetting {
  DISABLED_AND_UNOVERRIDABLE,
  DISABLED_WITH_OVERRIDE,
  ENABLED,
  $unknown
}

String toJson$Enum$SharedRunnersSetting(Enum$SharedRunnersSetting e) {
  switch (e) {
    case Enum$SharedRunnersSetting.DISABLED_AND_UNOVERRIDABLE:
      return r'DISABLED_AND_UNOVERRIDABLE';
    case Enum$SharedRunnersSetting.DISABLED_WITH_OVERRIDE:
      return r'DISABLED_WITH_OVERRIDE';
    case Enum$SharedRunnersSetting.ENABLED:
      return r'ENABLED';
    case Enum$SharedRunnersSetting.$unknown:
      return r'$unknown';
  }
}

Enum$SharedRunnersSetting fromJson$Enum$SharedRunnersSetting(String value) {
  switch (value) {
    case r'DISABLED_AND_UNOVERRIDABLE':
      return Enum$SharedRunnersSetting.DISABLED_AND_UNOVERRIDABLE;
    case r'DISABLED_WITH_OVERRIDE':
      return Enum$SharedRunnersSetting.DISABLED_WITH_OVERRIDE;
    case r'ENABLED':
      return Enum$SharedRunnersSetting.ENABLED;
    default:
      return Enum$SharedRunnersSetting.$unknown;
  }
}

enum Enum$SnippetBlobActionEnum { create, update, delete, move, $unknown }

String toJson$Enum$SnippetBlobActionEnum(Enum$SnippetBlobActionEnum e) {
  switch (e) {
    case Enum$SnippetBlobActionEnum.create:
      return r'create';
    case Enum$SnippetBlobActionEnum.update:
      return r'update';
    case Enum$SnippetBlobActionEnum.delete:
      return r'delete';
    case Enum$SnippetBlobActionEnum.move:
      return r'move';
    case Enum$SnippetBlobActionEnum.$unknown:
      return r'$unknown';
  }
}

Enum$SnippetBlobActionEnum fromJson$Enum$SnippetBlobActionEnum(String value) {
  switch (value) {
    case r'create':
      return Enum$SnippetBlobActionEnum.create;
    case r'update':
      return Enum$SnippetBlobActionEnum.update;
    case r'delete':
      return Enum$SnippetBlobActionEnum.delete;
    case r'move':
      return Enum$SnippetBlobActionEnum.move;
    default:
      return Enum$SnippetBlobActionEnum.$unknown;
  }
}

enum Enum$Sort {
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$Sort(Enum$Sort e) {
  switch (e) {
    case Enum$Sort.updated_desc:
      return r'updated_desc';
    case Enum$Sort.updated_asc:
      return r'updated_asc';
    case Enum$Sort.created_desc:
      return r'created_desc';
    case Enum$Sort.created_asc:
      return r'created_asc';
    case Enum$Sort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$Sort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$Sort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$Sort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$Sort.$unknown:
      return r'$unknown';
  }
}

Enum$Sort fromJson$Enum$Sort(String value) {
  switch (value) {
    case r'updated_desc':
      return Enum$Sort.updated_desc;
    case r'updated_asc':
      return Enum$Sort.updated_asc;
    case r'created_desc':
      return Enum$Sort.created_desc;
    case r'created_asc':
      return Enum$Sort.created_asc;
    case r'UPDATED_DESC':
      return Enum$Sort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$Sort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$Sort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$Sort.CREATED_ASC;
    default:
      return Enum$Sort.$unknown;
  }
}

enum Enum$SortDirectionEnum { ASC, DESC, $unknown }

String toJson$Enum$SortDirectionEnum(Enum$SortDirectionEnum e) {
  switch (e) {
    case Enum$SortDirectionEnum.ASC:
      return r'ASC';
    case Enum$SortDirectionEnum.DESC:
      return r'DESC';
    case Enum$SortDirectionEnum.$unknown:
      return r'$unknown';
  }
}

Enum$SortDirectionEnum fromJson$Enum$SortDirectionEnum(String value) {
  switch (value) {
    case r'ASC':
      return Enum$SortDirectionEnum.ASC;
    case r'DESC':
      return Enum$SortDirectionEnum.DESC;
    default:
      return Enum$SortDirectionEnum.$unknown;
  }
}

enum Enum$TestCaseStatus { error, failed, success, skipped, $unknown }

String toJson$Enum$TestCaseStatus(Enum$TestCaseStatus e) {
  switch (e) {
    case Enum$TestCaseStatus.error:
      return r'error';
    case Enum$TestCaseStatus.failed:
      return r'failed';
    case Enum$TestCaseStatus.success:
      return r'success';
    case Enum$TestCaseStatus.skipped:
      return r'skipped';
    case Enum$TestCaseStatus.$unknown:
      return r'$unknown';
  }
}

Enum$TestCaseStatus fromJson$Enum$TestCaseStatus(String value) {
  switch (value) {
    case r'error':
      return Enum$TestCaseStatus.error;
    case r'failed':
      return Enum$TestCaseStatus.failed;
    case r'success':
      return Enum$TestCaseStatus.success;
    case r'skipped':
      return Enum$TestCaseStatus.skipped;
    default:
      return Enum$TestCaseStatus.$unknown;
  }
}

enum Enum$TestReportState { PASSED, FAILED, $unknown }

String toJson$Enum$TestReportState(Enum$TestReportState e) {
  switch (e) {
    case Enum$TestReportState.PASSED:
      return r'PASSED';
    case Enum$TestReportState.FAILED:
      return r'FAILED';
    case Enum$TestReportState.$unknown:
      return r'$unknown';
  }
}

Enum$TestReportState fromJson$Enum$TestReportState(String value) {
  switch (value) {
    case r'PASSED':
      return Enum$TestReportState.PASSED;
    case r'FAILED':
      return Enum$TestReportState.FAILED;
    default:
      return Enum$TestReportState.$unknown;
  }
}

enum Enum$TimeboxReportErrorReason {
  UNSUPPORTED,
  MISSING_DATES,
  TOO_MANY_EVENTS,
  PRIORITY_ASC,
  PRIORITY_DESC,
  LABEL_PRIORITY_ASC,
  LABEL_PRIORITY_DESC,
  MILESTONE_DUE_ASC,
  MILESTONE_DUE_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$TimeboxReportErrorReason(Enum$TimeboxReportErrorReason e) {
  switch (e) {
    case Enum$TimeboxReportErrorReason.UNSUPPORTED:
      return r'UNSUPPORTED';
    case Enum$TimeboxReportErrorReason.MISSING_DATES:
      return r'MISSING_DATES';
    case Enum$TimeboxReportErrorReason.TOO_MANY_EVENTS:
      return r'TOO_MANY_EVENTS';
    case Enum$TimeboxReportErrorReason.PRIORITY_ASC:
      return r'PRIORITY_ASC';
    case Enum$TimeboxReportErrorReason.PRIORITY_DESC:
      return r'PRIORITY_DESC';
    case Enum$TimeboxReportErrorReason.LABEL_PRIORITY_ASC:
      return r'LABEL_PRIORITY_ASC';
    case Enum$TimeboxReportErrorReason.LABEL_PRIORITY_DESC:
      return r'LABEL_PRIORITY_DESC';
    case Enum$TimeboxReportErrorReason.MILESTONE_DUE_ASC:
      return r'MILESTONE_DUE_ASC';
    case Enum$TimeboxReportErrorReason.MILESTONE_DUE_DESC:
      return r'MILESTONE_DUE_DESC';
    case Enum$TimeboxReportErrorReason.updated_desc:
      return r'updated_desc';
    case Enum$TimeboxReportErrorReason.updated_asc:
      return r'updated_asc';
    case Enum$TimeboxReportErrorReason.created_desc:
      return r'created_desc';
    case Enum$TimeboxReportErrorReason.created_asc:
      return r'created_asc';
    case Enum$TimeboxReportErrorReason.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$TimeboxReportErrorReason.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$TimeboxReportErrorReason.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$TimeboxReportErrorReason.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$TimeboxReportErrorReason.$unknown:
      return r'$unknown';
  }
}

Enum$TimeboxReportErrorReason fromJson$Enum$TimeboxReportErrorReason(
    String value) {
  switch (value) {
    case r'UNSUPPORTED':
      return Enum$TimeboxReportErrorReason.UNSUPPORTED;
    case r'MISSING_DATES':
      return Enum$TimeboxReportErrorReason.MISSING_DATES;
    case r'TOO_MANY_EVENTS':
      return Enum$TimeboxReportErrorReason.TOO_MANY_EVENTS;
    case r'PRIORITY_ASC':
      return Enum$TimeboxReportErrorReason.PRIORITY_ASC;
    case r'PRIORITY_DESC':
      return Enum$TimeboxReportErrorReason.PRIORITY_DESC;
    case r'LABEL_PRIORITY_ASC':
      return Enum$TimeboxReportErrorReason.LABEL_PRIORITY_ASC;
    case r'LABEL_PRIORITY_DESC':
      return Enum$TimeboxReportErrorReason.LABEL_PRIORITY_DESC;
    case r'MILESTONE_DUE_ASC':
      return Enum$TimeboxReportErrorReason.MILESTONE_DUE_ASC;
    case r'MILESTONE_DUE_DESC':
      return Enum$TimeboxReportErrorReason.MILESTONE_DUE_DESC;
    case r'updated_desc':
      return Enum$TimeboxReportErrorReason.updated_desc;
    case r'updated_asc':
      return Enum$TimeboxReportErrorReason.updated_asc;
    case r'created_desc':
      return Enum$TimeboxReportErrorReason.created_desc;
    case r'created_asc':
      return Enum$TimeboxReportErrorReason.created_asc;
    case r'UPDATED_DESC':
      return Enum$TimeboxReportErrorReason.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$TimeboxReportErrorReason.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$TimeboxReportErrorReason.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$TimeboxReportErrorReason.CREATED_ASC;
    default:
      return Enum$TimeboxReportErrorReason.$unknown;
  }
}

enum Enum$TodoActionEnum {
  assigned,
  mentioned,
  build_failed,
  marked,
  approval_required,
  unmergeable,
  directly_addressed,
  merge_train_removed,
  review_requested,
  $unknown
}

String toJson$Enum$TodoActionEnum(Enum$TodoActionEnum e) {
  switch (e) {
    case Enum$TodoActionEnum.assigned:
      return r'assigned';
    case Enum$TodoActionEnum.mentioned:
      return r'mentioned';
    case Enum$TodoActionEnum.build_failed:
      return r'build_failed';
    case Enum$TodoActionEnum.marked:
      return r'marked';
    case Enum$TodoActionEnum.approval_required:
      return r'approval_required';
    case Enum$TodoActionEnum.unmergeable:
      return r'unmergeable';
    case Enum$TodoActionEnum.directly_addressed:
      return r'directly_addressed';
    case Enum$TodoActionEnum.merge_train_removed:
      return r'merge_train_removed';
    case Enum$TodoActionEnum.review_requested:
      return r'review_requested';
    case Enum$TodoActionEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TodoActionEnum fromJson$Enum$TodoActionEnum(String value) {
  switch (value) {
    case r'assigned':
      return Enum$TodoActionEnum.assigned;
    case r'mentioned':
      return Enum$TodoActionEnum.mentioned;
    case r'build_failed':
      return Enum$TodoActionEnum.build_failed;
    case r'marked':
      return Enum$TodoActionEnum.marked;
    case r'approval_required':
      return Enum$TodoActionEnum.approval_required;
    case r'unmergeable':
      return Enum$TodoActionEnum.unmergeable;
    case r'directly_addressed':
      return Enum$TodoActionEnum.directly_addressed;
    case r'merge_train_removed':
      return Enum$TodoActionEnum.merge_train_removed;
    case r'review_requested':
      return Enum$TodoActionEnum.review_requested;
    default:
      return Enum$TodoActionEnum.$unknown;
  }
}

enum Enum$TodoStateEnum { pending, done, $unknown }

String toJson$Enum$TodoStateEnum(Enum$TodoStateEnum e) {
  switch (e) {
    case Enum$TodoStateEnum.pending:
      return r'pending';
    case Enum$TodoStateEnum.done:
      return r'done';
    case Enum$TodoStateEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TodoStateEnum fromJson$Enum$TodoStateEnum(String value) {
  switch (value) {
    case r'pending':
      return Enum$TodoStateEnum.pending;
    case r'done':
      return Enum$TodoStateEnum.done;
    default:
      return Enum$TodoStateEnum.$unknown;
  }
}

enum Enum$TodoTargetEnum {
  COMMIT,
  ISSUE,
  MERGEREQUEST,
  DESIGN,
  ALERT,
  EPIC,
  $unknown
}

String toJson$Enum$TodoTargetEnum(Enum$TodoTargetEnum e) {
  switch (e) {
    case Enum$TodoTargetEnum.COMMIT:
      return r'COMMIT';
    case Enum$TodoTargetEnum.ISSUE:
      return r'ISSUE';
    case Enum$TodoTargetEnum.MERGEREQUEST:
      return r'MERGEREQUEST';
    case Enum$TodoTargetEnum.DESIGN:
      return r'DESIGN';
    case Enum$TodoTargetEnum.ALERT:
      return r'ALERT';
    case Enum$TodoTargetEnum.EPIC:
      return r'EPIC';
    case Enum$TodoTargetEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TodoTargetEnum fromJson$Enum$TodoTargetEnum(String value) {
  switch (value) {
    case r'COMMIT':
      return Enum$TodoTargetEnum.COMMIT;
    case r'ISSUE':
      return Enum$TodoTargetEnum.ISSUE;
    case r'MERGEREQUEST':
      return Enum$TodoTargetEnum.MERGEREQUEST;
    case r'DESIGN':
      return Enum$TodoTargetEnum.DESIGN;
    case r'ALERT':
      return Enum$TodoTargetEnum.ALERT;
    case r'EPIC':
      return Enum$TodoTargetEnum.EPIC;
    default:
      return Enum$TodoTargetEnum.$unknown;
  }
}

enum Enum$TrainingUrlRequestStatus { PENDING, COMPLETED, $unknown }

String toJson$Enum$TrainingUrlRequestStatus(Enum$TrainingUrlRequestStatus e) {
  switch (e) {
    case Enum$TrainingUrlRequestStatus.PENDING:
      return r'PENDING';
    case Enum$TrainingUrlRequestStatus.COMPLETED:
      return r'COMPLETED';
    case Enum$TrainingUrlRequestStatus.$unknown:
      return r'$unknown';
  }
}

Enum$TrainingUrlRequestStatus fromJson$Enum$TrainingUrlRequestStatus(
    String value) {
  switch (value) {
    case r'PENDING':
      return Enum$TrainingUrlRequestStatus.PENDING;
    case r'COMPLETED':
      return Enum$TrainingUrlRequestStatus.COMPLETED;
    default:
      return Enum$TrainingUrlRequestStatus.$unknown;
  }
}

enum Enum$TypeEnum { personal, project, $unknown }

String toJson$Enum$TypeEnum(Enum$TypeEnum e) {
  switch (e) {
    case Enum$TypeEnum.personal:
      return r'personal';
    case Enum$TypeEnum.project:
      return r'project';
    case Enum$TypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TypeEnum fromJson$Enum$TypeEnum(String value) {
  switch (value) {
    case r'personal':
      return Enum$TypeEnum.personal;
    case r'project':
      return Enum$TypeEnum.project;
    default:
      return Enum$TypeEnum.$unknown;
  }
}

enum Enum$UserCalloutFeatureNameEnum {
  GKE_CLUSTER_INTEGRATION,
  GCP_SIGNUP_OFFER,
  CLUSTER_SECURITY_WARNING,
  ULTIMATE_TRIAL,
  GEO_ENABLE_HASHED_STORAGE,
  GEO_MIGRATE_HASHED_STORAGE,
  CANARY_DEPLOYMENT,
  GOLD_TRIAL_BILLINGS,
  SUGGEST_POPOVER_DISMISSED,
  TABS_POSITION_HIGHLIGHT,
  THREAT_MONITORING_INFO,
  TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK,
  WEB_IDE_ALERT_DISMISSED,
  ACTIVE_USER_COUNT_THRESHOLD,
  BUY_PIPELINE_MINUTES_NOTIFICATION_DOT,
  PERSONAL_ACCESS_TOKEN_EXPIRY,
  SUGGEST_PIPELINE,
  FEATURE_FLAGS_NEW_VERSION,
  REGISTRATION_ENABLED_CALLOUT,
  NEW_USER_SIGNUPS_CAP_REACHED,
  UNFINISHED_TAG_CLEANUP_CALLOUT,
  EOA_BRONZE_PLAN_BANNER,
  PIPELINE_NEEDS_BANNER,
  PIPELINE_NEEDS_HOVER_TIP,
  WEB_IDE_CI_ENVIRONMENTS_GUIDANCE,
  SECURITY_CONFIGURATION_UPGRADE_BANNER,
  CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER,
  TRIAL_STATUS_REMINDER_D14,
  TRIAL_STATUS_REMINDER_D3,
  SECURITY_CONFIGURATION_DEVOPS_ALERT,
  PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY,
  TERRAFORM_NOTIFICATION_DISMISSED,
  SECURITY_NEWSLETTER_CALLOUT,
  VERIFICATION_REMINDER,
  CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD,
  SECURITY_TRAINING_FEATURE_PROMOTION,
  STORAGE_ENFORCEMENT_BANNER_FIRST_ENFORCEMENT_THRESHOLD,
  STORAGE_ENFORCEMENT_BANNER_SECOND_ENFORCEMENT_THRESHOLD,
  STORAGE_ENFORCEMENT_BANNER_THIRD_ENFORCEMENT_THRESHOLD,
  STORAGE_ENFORCEMENT_BANNER_FOURTH_ENFORCEMENT_THRESHOLD,
  PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT,
  USER_REACHED_LIMIT_FREE_PLAN_ALERT,
  SUBMIT_LICENSE_USAGE_DATA_BANNER,
  PERSONAL_PROJECT_LIMITATIONS_BANNER,
  MR_EXPERIENCE_SURVEY,
  NAMESPACE_STORAGE_LIMIT_BANNER_INFO_THRESHOLD,
  NAMESPACE_STORAGE_LIMIT_BANNER_WARNING_THRESHOLD,
  NAMESPACE_STORAGE_LIMIT_BANNER_ALERT_THRESHOLD,
  NAMESPACE_STORAGE_LIMIT_BANNER_ERROR_THRESHOLD,
  PROJECT_QUALITY_SUMMARY_FEEDBACK,
  $unknown
}

String toJson$Enum$UserCalloutFeatureNameEnum(
    Enum$UserCalloutFeatureNameEnum e) {
  switch (e) {
    case Enum$UserCalloutFeatureNameEnum.GKE_CLUSTER_INTEGRATION:
      return r'GKE_CLUSTER_INTEGRATION';
    case Enum$UserCalloutFeatureNameEnum.GCP_SIGNUP_OFFER:
      return r'GCP_SIGNUP_OFFER';
    case Enum$UserCalloutFeatureNameEnum.CLUSTER_SECURITY_WARNING:
      return r'CLUSTER_SECURITY_WARNING';
    case Enum$UserCalloutFeatureNameEnum.ULTIMATE_TRIAL:
      return r'ULTIMATE_TRIAL';
    case Enum$UserCalloutFeatureNameEnum.GEO_ENABLE_HASHED_STORAGE:
      return r'GEO_ENABLE_HASHED_STORAGE';
    case Enum$UserCalloutFeatureNameEnum.GEO_MIGRATE_HASHED_STORAGE:
      return r'GEO_MIGRATE_HASHED_STORAGE';
    case Enum$UserCalloutFeatureNameEnum.CANARY_DEPLOYMENT:
      return r'CANARY_DEPLOYMENT';
    case Enum$UserCalloutFeatureNameEnum.GOLD_TRIAL_BILLINGS:
      return r'GOLD_TRIAL_BILLINGS';
    case Enum$UserCalloutFeatureNameEnum.SUGGEST_POPOVER_DISMISSED:
      return r'SUGGEST_POPOVER_DISMISSED';
    case Enum$UserCalloutFeatureNameEnum.TABS_POSITION_HIGHLIGHT:
      return r'TABS_POSITION_HIGHLIGHT';
    case Enum$UserCalloutFeatureNameEnum.THREAT_MONITORING_INFO:
      return r'THREAT_MONITORING_INFO';
    case Enum$UserCalloutFeatureNameEnum
        .TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK:
      return r'TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK';
    case Enum$UserCalloutFeatureNameEnum.WEB_IDE_ALERT_DISMISSED:
      return r'WEB_IDE_ALERT_DISMISSED';
    case Enum$UserCalloutFeatureNameEnum.ACTIVE_USER_COUNT_THRESHOLD:
      return r'ACTIVE_USER_COUNT_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum.BUY_PIPELINE_MINUTES_NOTIFICATION_DOT:
      return r'BUY_PIPELINE_MINUTES_NOTIFICATION_DOT';
    case Enum$UserCalloutFeatureNameEnum.PERSONAL_ACCESS_TOKEN_EXPIRY:
      return r'PERSONAL_ACCESS_TOKEN_EXPIRY';
    case Enum$UserCalloutFeatureNameEnum.SUGGEST_PIPELINE:
      return r'SUGGEST_PIPELINE';
    case Enum$UserCalloutFeatureNameEnum.FEATURE_FLAGS_NEW_VERSION:
      return r'FEATURE_FLAGS_NEW_VERSION';
    case Enum$UserCalloutFeatureNameEnum.REGISTRATION_ENABLED_CALLOUT:
      return r'REGISTRATION_ENABLED_CALLOUT';
    case Enum$UserCalloutFeatureNameEnum.NEW_USER_SIGNUPS_CAP_REACHED:
      return r'NEW_USER_SIGNUPS_CAP_REACHED';
    case Enum$UserCalloutFeatureNameEnum.UNFINISHED_TAG_CLEANUP_CALLOUT:
      return r'UNFINISHED_TAG_CLEANUP_CALLOUT';
    case Enum$UserCalloutFeatureNameEnum.EOA_BRONZE_PLAN_BANNER:
      return r'EOA_BRONZE_PLAN_BANNER';
    case Enum$UserCalloutFeatureNameEnum.PIPELINE_NEEDS_BANNER:
      return r'PIPELINE_NEEDS_BANNER';
    case Enum$UserCalloutFeatureNameEnum.PIPELINE_NEEDS_HOVER_TIP:
      return r'PIPELINE_NEEDS_HOVER_TIP';
    case Enum$UserCalloutFeatureNameEnum.WEB_IDE_CI_ENVIRONMENTS_GUIDANCE:
      return r'WEB_IDE_CI_ENVIRONMENTS_GUIDANCE';
    case Enum$UserCalloutFeatureNameEnum.SECURITY_CONFIGURATION_UPGRADE_BANNER:
      return r'SECURITY_CONFIGURATION_UPGRADE_BANNER';
    case Enum$UserCalloutFeatureNameEnum
        .CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER:
      return r'CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER';
    case Enum$UserCalloutFeatureNameEnum.TRIAL_STATUS_REMINDER_D14:
      return r'TRIAL_STATUS_REMINDER_D14';
    case Enum$UserCalloutFeatureNameEnum.TRIAL_STATUS_REMINDER_D3:
      return r'TRIAL_STATUS_REMINDER_D3';
    case Enum$UserCalloutFeatureNameEnum.SECURITY_CONFIGURATION_DEVOPS_ALERT:
      return r'SECURITY_CONFIGURATION_DEVOPS_ALERT';
    case Enum$UserCalloutFeatureNameEnum.PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY:
      return r'PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY';
    case Enum$UserCalloutFeatureNameEnum.TERRAFORM_NOTIFICATION_DISMISSED:
      return r'TERRAFORM_NOTIFICATION_DISMISSED';
    case Enum$UserCalloutFeatureNameEnum.SECURITY_NEWSLETTER_CALLOUT:
      return r'SECURITY_NEWSLETTER_CALLOUT';
    case Enum$UserCalloutFeatureNameEnum.VERIFICATION_REMINDER:
      return r'VERIFICATION_REMINDER';
    case Enum$UserCalloutFeatureNameEnum
        .CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD:
      return r'CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD';
    case Enum$UserCalloutFeatureNameEnum.SECURITY_TRAINING_FEATURE_PROMOTION:
      return r'SECURITY_TRAINING_FEATURE_PROMOTION';
    case Enum$UserCalloutFeatureNameEnum
        .STORAGE_ENFORCEMENT_BANNER_FIRST_ENFORCEMENT_THRESHOLD:
      return r'STORAGE_ENFORCEMENT_BANNER_FIRST_ENFORCEMENT_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .STORAGE_ENFORCEMENT_BANNER_SECOND_ENFORCEMENT_THRESHOLD:
      return r'STORAGE_ENFORCEMENT_BANNER_SECOND_ENFORCEMENT_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .STORAGE_ENFORCEMENT_BANNER_THIRD_ENFORCEMENT_THRESHOLD:
      return r'STORAGE_ENFORCEMENT_BANNER_THIRD_ENFORCEMENT_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .STORAGE_ENFORCEMENT_BANNER_FOURTH_ENFORCEMENT_THRESHOLD:
      return r'STORAGE_ENFORCEMENT_BANNER_FOURTH_ENFORCEMENT_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT:
      return r'PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT';
    case Enum$UserCalloutFeatureNameEnum.USER_REACHED_LIMIT_FREE_PLAN_ALERT:
      return r'USER_REACHED_LIMIT_FREE_PLAN_ALERT';
    case Enum$UserCalloutFeatureNameEnum.SUBMIT_LICENSE_USAGE_DATA_BANNER:
      return r'SUBMIT_LICENSE_USAGE_DATA_BANNER';
    case Enum$UserCalloutFeatureNameEnum.PERSONAL_PROJECT_LIMITATIONS_BANNER:
      return r'PERSONAL_PROJECT_LIMITATIONS_BANNER';
    case Enum$UserCalloutFeatureNameEnum.MR_EXPERIENCE_SURVEY:
      return r'MR_EXPERIENCE_SURVEY';
    case Enum$UserCalloutFeatureNameEnum
        .NAMESPACE_STORAGE_LIMIT_BANNER_INFO_THRESHOLD:
      return r'NAMESPACE_STORAGE_LIMIT_BANNER_INFO_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .NAMESPACE_STORAGE_LIMIT_BANNER_WARNING_THRESHOLD:
      return r'NAMESPACE_STORAGE_LIMIT_BANNER_WARNING_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .NAMESPACE_STORAGE_LIMIT_BANNER_ALERT_THRESHOLD:
      return r'NAMESPACE_STORAGE_LIMIT_BANNER_ALERT_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum
        .NAMESPACE_STORAGE_LIMIT_BANNER_ERROR_THRESHOLD:
      return r'NAMESPACE_STORAGE_LIMIT_BANNER_ERROR_THRESHOLD';
    case Enum$UserCalloutFeatureNameEnum.PROJECT_QUALITY_SUMMARY_FEEDBACK:
      return r'PROJECT_QUALITY_SUMMARY_FEEDBACK';
    case Enum$UserCalloutFeatureNameEnum.$unknown:
      return r'$unknown';
  }
}

Enum$UserCalloutFeatureNameEnum fromJson$Enum$UserCalloutFeatureNameEnum(
    String value) {
  switch (value) {
    case r'GKE_CLUSTER_INTEGRATION':
      return Enum$UserCalloutFeatureNameEnum.GKE_CLUSTER_INTEGRATION;
    case r'GCP_SIGNUP_OFFER':
      return Enum$UserCalloutFeatureNameEnum.GCP_SIGNUP_OFFER;
    case r'CLUSTER_SECURITY_WARNING':
      return Enum$UserCalloutFeatureNameEnum.CLUSTER_SECURITY_WARNING;
    case r'ULTIMATE_TRIAL':
      return Enum$UserCalloutFeatureNameEnum.ULTIMATE_TRIAL;
    case r'GEO_ENABLE_HASHED_STORAGE':
      return Enum$UserCalloutFeatureNameEnum.GEO_ENABLE_HASHED_STORAGE;
    case r'GEO_MIGRATE_HASHED_STORAGE':
      return Enum$UserCalloutFeatureNameEnum.GEO_MIGRATE_HASHED_STORAGE;
    case r'CANARY_DEPLOYMENT':
      return Enum$UserCalloutFeatureNameEnum.CANARY_DEPLOYMENT;
    case r'GOLD_TRIAL_BILLINGS':
      return Enum$UserCalloutFeatureNameEnum.GOLD_TRIAL_BILLINGS;
    case r'SUGGEST_POPOVER_DISMISSED':
      return Enum$UserCalloutFeatureNameEnum.SUGGEST_POPOVER_DISMISSED;
    case r'TABS_POSITION_HIGHLIGHT':
      return Enum$UserCalloutFeatureNameEnum.TABS_POSITION_HIGHLIGHT;
    case r'THREAT_MONITORING_INFO':
      return Enum$UserCalloutFeatureNameEnum.THREAT_MONITORING_INFO;
    case r'TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK':
      return Enum$UserCalloutFeatureNameEnum
          .TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK;
    case r'WEB_IDE_ALERT_DISMISSED':
      return Enum$UserCalloutFeatureNameEnum.WEB_IDE_ALERT_DISMISSED;
    case r'ACTIVE_USER_COUNT_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum.ACTIVE_USER_COUNT_THRESHOLD;
    case r'BUY_PIPELINE_MINUTES_NOTIFICATION_DOT':
      return Enum$UserCalloutFeatureNameEnum
          .BUY_PIPELINE_MINUTES_NOTIFICATION_DOT;
    case r'PERSONAL_ACCESS_TOKEN_EXPIRY':
      return Enum$UserCalloutFeatureNameEnum.PERSONAL_ACCESS_TOKEN_EXPIRY;
    case r'SUGGEST_PIPELINE':
      return Enum$UserCalloutFeatureNameEnum.SUGGEST_PIPELINE;
    case r'FEATURE_FLAGS_NEW_VERSION':
      return Enum$UserCalloutFeatureNameEnum.FEATURE_FLAGS_NEW_VERSION;
    case r'REGISTRATION_ENABLED_CALLOUT':
      return Enum$UserCalloutFeatureNameEnum.REGISTRATION_ENABLED_CALLOUT;
    case r'NEW_USER_SIGNUPS_CAP_REACHED':
      return Enum$UserCalloutFeatureNameEnum.NEW_USER_SIGNUPS_CAP_REACHED;
    case r'UNFINISHED_TAG_CLEANUP_CALLOUT':
      return Enum$UserCalloutFeatureNameEnum.UNFINISHED_TAG_CLEANUP_CALLOUT;
    case r'EOA_BRONZE_PLAN_BANNER':
      return Enum$UserCalloutFeatureNameEnum.EOA_BRONZE_PLAN_BANNER;
    case r'PIPELINE_NEEDS_BANNER':
      return Enum$UserCalloutFeatureNameEnum.PIPELINE_NEEDS_BANNER;
    case r'PIPELINE_NEEDS_HOVER_TIP':
      return Enum$UserCalloutFeatureNameEnum.PIPELINE_NEEDS_HOVER_TIP;
    case r'WEB_IDE_CI_ENVIRONMENTS_GUIDANCE':
      return Enum$UserCalloutFeatureNameEnum.WEB_IDE_CI_ENVIRONMENTS_GUIDANCE;
    case r'SECURITY_CONFIGURATION_UPGRADE_BANNER':
      return Enum$UserCalloutFeatureNameEnum
          .SECURITY_CONFIGURATION_UPGRADE_BANNER;
    case r'CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER':
      return Enum$UserCalloutFeatureNameEnum
          .CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER;
    case r'TRIAL_STATUS_REMINDER_D14':
      return Enum$UserCalloutFeatureNameEnum.TRIAL_STATUS_REMINDER_D14;
    case r'TRIAL_STATUS_REMINDER_D3':
      return Enum$UserCalloutFeatureNameEnum.TRIAL_STATUS_REMINDER_D3;
    case r'SECURITY_CONFIGURATION_DEVOPS_ALERT':
      return Enum$UserCalloutFeatureNameEnum
          .SECURITY_CONFIGURATION_DEVOPS_ALERT;
    case r'PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY':
      return Enum$UserCalloutFeatureNameEnum
          .PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY;
    case r'TERRAFORM_NOTIFICATION_DISMISSED':
      return Enum$UserCalloutFeatureNameEnum.TERRAFORM_NOTIFICATION_DISMISSED;
    case r'SECURITY_NEWSLETTER_CALLOUT':
      return Enum$UserCalloutFeatureNameEnum.SECURITY_NEWSLETTER_CALLOUT;
    case r'VERIFICATION_REMINDER':
      return Enum$UserCalloutFeatureNameEnum.VERIFICATION_REMINDER;
    case r'CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD':
      return Enum$UserCalloutFeatureNameEnum
          .CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD;
    case r'SECURITY_TRAINING_FEATURE_PROMOTION':
      return Enum$UserCalloutFeatureNameEnum
          .SECURITY_TRAINING_FEATURE_PROMOTION;
    case r'STORAGE_ENFORCEMENT_BANNER_FIRST_ENFORCEMENT_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .STORAGE_ENFORCEMENT_BANNER_FIRST_ENFORCEMENT_THRESHOLD;
    case r'STORAGE_ENFORCEMENT_BANNER_SECOND_ENFORCEMENT_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .STORAGE_ENFORCEMENT_BANNER_SECOND_ENFORCEMENT_THRESHOLD;
    case r'STORAGE_ENFORCEMENT_BANNER_THIRD_ENFORCEMENT_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .STORAGE_ENFORCEMENT_BANNER_THIRD_ENFORCEMENT_THRESHOLD;
    case r'STORAGE_ENFORCEMENT_BANNER_FOURTH_ENFORCEMENT_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .STORAGE_ENFORCEMENT_BANNER_FOURTH_ENFORCEMENT_THRESHOLD;
    case r'PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT':
      return Enum$UserCalloutFeatureNameEnum
          .PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT;
    case r'USER_REACHED_LIMIT_FREE_PLAN_ALERT':
      return Enum$UserCalloutFeatureNameEnum.USER_REACHED_LIMIT_FREE_PLAN_ALERT;
    case r'SUBMIT_LICENSE_USAGE_DATA_BANNER':
      return Enum$UserCalloutFeatureNameEnum.SUBMIT_LICENSE_USAGE_DATA_BANNER;
    case r'PERSONAL_PROJECT_LIMITATIONS_BANNER':
      return Enum$UserCalloutFeatureNameEnum
          .PERSONAL_PROJECT_LIMITATIONS_BANNER;
    case r'MR_EXPERIENCE_SURVEY':
      return Enum$UserCalloutFeatureNameEnum.MR_EXPERIENCE_SURVEY;
    case r'NAMESPACE_STORAGE_LIMIT_BANNER_INFO_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .NAMESPACE_STORAGE_LIMIT_BANNER_INFO_THRESHOLD;
    case r'NAMESPACE_STORAGE_LIMIT_BANNER_WARNING_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .NAMESPACE_STORAGE_LIMIT_BANNER_WARNING_THRESHOLD;
    case r'NAMESPACE_STORAGE_LIMIT_BANNER_ALERT_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .NAMESPACE_STORAGE_LIMIT_BANNER_ALERT_THRESHOLD;
    case r'NAMESPACE_STORAGE_LIMIT_BANNER_ERROR_THRESHOLD':
      return Enum$UserCalloutFeatureNameEnum
          .NAMESPACE_STORAGE_LIMIT_BANNER_ERROR_THRESHOLD;
    case r'PROJECT_QUALITY_SUMMARY_FEEDBACK':
      return Enum$UserCalloutFeatureNameEnum.PROJECT_QUALITY_SUMMARY_FEEDBACK;
    default:
      return Enum$UserCalloutFeatureNameEnum.$unknown;
  }
}

enum Enum$UserState { active, blocked, deactivated, $unknown }

String toJson$Enum$UserState(Enum$UserState e) {
  switch (e) {
    case Enum$UserState.active:
      return r'active';
    case Enum$UserState.blocked:
      return r'blocked';
    case Enum$UserState.deactivated:
      return r'deactivated';
    case Enum$UserState.$unknown:
      return r'$unknown';
  }
}

Enum$UserState fromJson$Enum$UserState(String value) {
  switch (value) {
    case r'active':
      return Enum$UserState.active;
    case r'blocked':
      return Enum$UserState.blocked;
    case r'deactivated':
      return Enum$UserState.deactivated;
    default:
      return Enum$UserState.$unknown;
  }
}

enum Enum$VerificationStateEnum {
  PENDING,
  STARTED,
  SUCCEEDED,
  FAILED,
  DISABLED,
  $unknown
}

String toJson$Enum$VerificationStateEnum(Enum$VerificationStateEnum e) {
  switch (e) {
    case Enum$VerificationStateEnum.PENDING:
      return r'PENDING';
    case Enum$VerificationStateEnum.STARTED:
      return r'STARTED';
    case Enum$VerificationStateEnum.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$VerificationStateEnum.FAILED:
      return r'FAILED';
    case Enum$VerificationStateEnum.DISABLED:
      return r'DISABLED';
    case Enum$VerificationStateEnum.$unknown:
      return r'$unknown';
  }
}

Enum$VerificationStateEnum fromJson$Enum$VerificationStateEnum(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$VerificationStateEnum.PENDING;
    case r'STARTED':
      return Enum$VerificationStateEnum.STARTED;
    case r'SUCCEEDED':
      return Enum$VerificationStateEnum.SUCCEEDED;
    case r'FAILED':
      return Enum$VerificationStateEnum.FAILED;
    case r'DISABLED':
      return Enum$VerificationStateEnum.DISABLED;
    default:
      return Enum$VerificationStateEnum.$unknown;
  }
}

enum Enum$VisibilityLevelsEnum { private, internal, public, $unknown }

String toJson$Enum$VisibilityLevelsEnum(Enum$VisibilityLevelsEnum e) {
  switch (e) {
    case Enum$VisibilityLevelsEnum.private:
      return r'private';
    case Enum$VisibilityLevelsEnum.internal:
      return r'internal';
    case Enum$VisibilityLevelsEnum.public:
      return r'public';
    case Enum$VisibilityLevelsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$VisibilityLevelsEnum fromJson$Enum$VisibilityLevelsEnum(String value) {
  switch (value) {
    case r'private':
      return Enum$VisibilityLevelsEnum.private;
    case r'internal':
      return Enum$VisibilityLevelsEnum.internal;
    case r'public':
      return Enum$VisibilityLevelsEnum.public;
    default:
      return Enum$VisibilityLevelsEnum.$unknown;
  }
}

enum Enum$VisibilityScopesEnum { private, internal, public, $unknown }

String toJson$Enum$VisibilityScopesEnum(Enum$VisibilityScopesEnum e) {
  switch (e) {
    case Enum$VisibilityScopesEnum.private:
      return r'private';
    case Enum$VisibilityScopesEnum.internal:
      return r'internal';
    case Enum$VisibilityScopesEnum.public:
      return r'public';
    case Enum$VisibilityScopesEnum.$unknown:
      return r'$unknown';
  }
}

Enum$VisibilityScopesEnum fromJson$Enum$VisibilityScopesEnum(String value) {
  switch (value) {
    case r'private':
      return Enum$VisibilityScopesEnum.private;
    case r'internal':
      return Enum$VisibilityScopesEnum.internal;
    case r'public':
      return Enum$VisibilityScopesEnum.public;
    default:
      return Enum$VisibilityScopesEnum.$unknown;
  }
}

enum Enum$VulnerabilityConfidence {
  IGNORE,
  UNKNOWN,
  EXPERIMENTAL,
  LOW,
  MEDIUM,
  HIGH,
  CONFIRMED,
  $unknown
}

String toJson$Enum$VulnerabilityConfidence(Enum$VulnerabilityConfidence e) {
  switch (e) {
    case Enum$VulnerabilityConfidence.IGNORE:
      return r'IGNORE';
    case Enum$VulnerabilityConfidence.UNKNOWN:
      return r'UNKNOWN';
    case Enum$VulnerabilityConfidence.EXPERIMENTAL:
      return r'EXPERIMENTAL';
    case Enum$VulnerabilityConfidence.LOW:
      return r'LOW';
    case Enum$VulnerabilityConfidence.MEDIUM:
      return r'MEDIUM';
    case Enum$VulnerabilityConfidence.HIGH:
      return r'HIGH';
    case Enum$VulnerabilityConfidence.CONFIRMED:
      return r'CONFIRMED';
    case Enum$VulnerabilityConfidence.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityConfidence fromJson$Enum$VulnerabilityConfidence(
    String value) {
  switch (value) {
    case r'IGNORE':
      return Enum$VulnerabilityConfidence.IGNORE;
    case r'UNKNOWN':
      return Enum$VulnerabilityConfidence.UNKNOWN;
    case r'EXPERIMENTAL':
      return Enum$VulnerabilityConfidence.EXPERIMENTAL;
    case r'LOW':
      return Enum$VulnerabilityConfidence.LOW;
    case r'MEDIUM':
      return Enum$VulnerabilityConfidence.MEDIUM;
    case r'HIGH':
      return Enum$VulnerabilityConfidence.HIGH;
    case r'CONFIRMED':
      return Enum$VulnerabilityConfidence.CONFIRMED;
    default:
      return Enum$VulnerabilityConfidence.$unknown;
  }
}

enum Enum$VulnerabilityDismissalReason {
  ACCEPTABLE_RISK,
  FALSE_POSITIVE,
  MITIGATING_CONTROL,
  USED_IN_TESTS,
  NOT_APPLICABLE,
  $unknown
}

String toJson$Enum$VulnerabilityDismissalReason(
    Enum$VulnerabilityDismissalReason e) {
  switch (e) {
    case Enum$VulnerabilityDismissalReason.ACCEPTABLE_RISK:
      return r'ACCEPTABLE_RISK';
    case Enum$VulnerabilityDismissalReason.FALSE_POSITIVE:
      return r'FALSE_POSITIVE';
    case Enum$VulnerabilityDismissalReason.MITIGATING_CONTROL:
      return r'MITIGATING_CONTROL';
    case Enum$VulnerabilityDismissalReason.USED_IN_TESTS:
      return r'USED_IN_TESTS';
    case Enum$VulnerabilityDismissalReason.NOT_APPLICABLE:
      return r'NOT_APPLICABLE';
    case Enum$VulnerabilityDismissalReason.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityDismissalReason fromJson$Enum$VulnerabilityDismissalReason(
    String value) {
  switch (value) {
    case r'ACCEPTABLE_RISK':
      return Enum$VulnerabilityDismissalReason.ACCEPTABLE_RISK;
    case r'FALSE_POSITIVE':
      return Enum$VulnerabilityDismissalReason.FALSE_POSITIVE;
    case r'MITIGATING_CONTROL':
      return Enum$VulnerabilityDismissalReason.MITIGATING_CONTROL;
    case r'USED_IN_TESTS':
      return Enum$VulnerabilityDismissalReason.USED_IN_TESTS;
    case r'NOT_APPLICABLE':
      return Enum$VulnerabilityDismissalReason.NOT_APPLICABLE;
    default:
      return Enum$VulnerabilityDismissalReason.$unknown;
  }
}

enum Enum$VulnerabilityExternalIssueLinkExternalTracker { JIRA, $unknown }

String toJson$Enum$VulnerabilityExternalIssueLinkExternalTracker(
    Enum$VulnerabilityExternalIssueLinkExternalTracker e) {
  switch (e) {
    case Enum$VulnerabilityExternalIssueLinkExternalTracker.JIRA:
      return r'JIRA';
    case Enum$VulnerabilityExternalIssueLinkExternalTracker.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityExternalIssueLinkExternalTracker
    fromJson$Enum$VulnerabilityExternalIssueLinkExternalTracker(String value) {
  switch (value) {
    case r'JIRA':
      return Enum$VulnerabilityExternalIssueLinkExternalTracker.JIRA;
    default:
      return Enum$VulnerabilityExternalIssueLinkExternalTracker.$unknown;
  }
}

enum Enum$VulnerabilityExternalIssueLinkType { CREATED, $unknown }

String toJson$Enum$VulnerabilityExternalIssueLinkType(
    Enum$VulnerabilityExternalIssueLinkType e) {
  switch (e) {
    case Enum$VulnerabilityExternalIssueLinkType.CREATED:
      return r'CREATED';
    case Enum$VulnerabilityExternalIssueLinkType.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityExternalIssueLinkType
    fromJson$Enum$VulnerabilityExternalIssueLinkType(String value) {
  switch (value) {
    case r'CREATED':
      return Enum$VulnerabilityExternalIssueLinkType.CREATED;
    default:
      return Enum$VulnerabilityExternalIssueLinkType.$unknown;
  }
}

enum Enum$VulnerabilityGrade { A, B, C, D, F, $unknown }

String toJson$Enum$VulnerabilityGrade(Enum$VulnerabilityGrade e) {
  switch (e) {
    case Enum$VulnerabilityGrade.A:
      return r'A';
    case Enum$VulnerabilityGrade.B:
      return r'B';
    case Enum$VulnerabilityGrade.C:
      return r'C';
    case Enum$VulnerabilityGrade.D:
      return r'D';
    case Enum$VulnerabilityGrade.F:
      return r'F';
    case Enum$VulnerabilityGrade.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityGrade fromJson$Enum$VulnerabilityGrade(String value) {
  switch (value) {
    case r'A':
      return Enum$VulnerabilityGrade.A;
    case r'B':
      return Enum$VulnerabilityGrade.B;
    case r'C':
      return Enum$VulnerabilityGrade.C;
    case r'D':
      return Enum$VulnerabilityGrade.D;
    case r'F':
      return Enum$VulnerabilityGrade.F;
    default:
      return Enum$VulnerabilityGrade.$unknown;
  }
}

enum Enum$VulnerabilityIssueLinkType { RELATED, CREATED, $unknown }

String toJson$Enum$VulnerabilityIssueLinkType(
    Enum$VulnerabilityIssueLinkType e) {
  switch (e) {
    case Enum$VulnerabilityIssueLinkType.RELATED:
      return r'RELATED';
    case Enum$VulnerabilityIssueLinkType.CREATED:
      return r'CREATED';
    case Enum$VulnerabilityIssueLinkType.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityIssueLinkType fromJson$Enum$VulnerabilityIssueLinkType(
    String value) {
  switch (value) {
    case r'RELATED':
      return Enum$VulnerabilityIssueLinkType.RELATED;
    case r'CREATED':
      return Enum$VulnerabilityIssueLinkType.CREATED;
    default:
      return Enum$VulnerabilityIssueLinkType.$unknown;
  }
}

enum Enum$VulnerabilityReportType {
  SAST,
  DEPENDENCY_SCANNING,
  CONTAINER_SCANNING,
  DAST,
  SECRET_DETECTION,
  COVERAGE_FUZZING,
  API_FUZZING,
  CLUSTER_IMAGE_SCANNING,
  GENERIC,
  $unknown
}

String toJson$Enum$VulnerabilityReportType(Enum$VulnerabilityReportType e) {
  switch (e) {
    case Enum$VulnerabilityReportType.SAST:
      return r'SAST';
    case Enum$VulnerabilityReportType.DEPENDENCY_SCANNING:
      return r'DEPENDENCY_SCANNING';
    case Enum$VulnerabilityReportType.CONTAINER_SCANNING:
      return r'CONTAINER_SCANNING';
    case Enum$VulnerabilityReportType.DAST:
      return r'DAST';
    case Enum$VulnerabilityReportType.SECRET_DETECTION:
      return r'SECRET_DETECTION';
    case Enum$VulnerabilityReportType.COVERAGE_FUZZING:
      return r'COVERAGE_FUZZING';
    case Enum$VulnerabilityReportType.API_FUZZING:
      return r'API_FUZZING';
    case Enum$VulnerabilityReportType.CLUSTER_IMAGE_SCANNING:
      return r'CLUSTER_IMAGE_SCANNING';
    case Enum$VulnerabilityReportType.GENERIC:
      return r'GENERIC';
    case Enum$VulnerabilityReportType.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityReportType fromJson$Enum$VulnerabilityReportType(
    String value) {
  switch (value) {
    case r'SAST':
      return Enum$VulnerabilityReportType.SAST;
    case r'DEPENDENCY_SCANNING':
      return Enum$VulnerabilityReportType.DEPENDENCY_SCANNING;
    case r'CONTAINER_SCANNING':
      return Enum$VulnerabilityReportType.CONTAINER_SCANNING;
    case r'DAST':
      return Enum$VulnerabilityReportType.DAST;
    case r'SECRET_DETECTION':
      return Enum$VulnerabilityReportType.SECRET_DETECTION;
    case r'COVERAGE_FUZZING':
      return Enum$VulnerabilityReportType.COVERAGE_FUZZING;
    case r'API_FUZZING':
      return Enum$VulnerabilityReportType.API_FUZZING;
    case r'CLUSTER_IMAGE_SCANNING':
      return Enum$VulnerabilityReportType.CLUSTER_IMAGE_SCANNING;
    case r'GENERIC':
      return Enum$VulnerabilityReportType.GENERIC;
    default:
      return Enum$VulnerabilityReportType.$unknown;
  }
}

enum Enum$VulnerabilitySeverity {
  INFO,
  UNKNOWN,
  LOW,
  MEDIUM,
  HIGH,
  CRITICAL,
  $unknown
}

String toJson$Enum$VulnerabilitySeverity(Enum$VulnerabilitySeverity e) {
  switch (e) {
    case Enum$VulnerabilitySeverity.INFO:
      return r'INFO';
    case Enum$VulnerabilitySeverity.UNKNOWN:
      return r'UNKNOWN';
    case Enum$VulnerabilitySeverity.LOW:
      return r'LOW';
    case Enum$VulnerabilitySeverity.MEDIUM:
      return r'MEDIUM';
    case Enum$VulnerabilitySeverity.HIGH:
      return r'HIGH';
    case Enum$VulnerabilitySeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$VulnerabilitySeverity.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilitySeverity fromJson$Enum$VulnerabilitySeverity(String value) {
  switch (value) {
    case r'INFO':
      return Enum$VulnerabilitySeverity.INFO;
    case r'UNKNOWN':
      return Enum$VulnerabilitySeverity.UNKNOWN;
    case r'LOW':
      return Enum$VulnerabilitySeverity.LOW;
    case r'MEDIUM':
      return Enum$VulnerabilitySeverity.MEDIUM;
    case r'HIGH':
      return Enum$VulnerabilitySeverity.HIGH;
    case r'CRITICAL':
      return Enum$VulnerabilitySeverity.CRITICAL;
    default:
      return Enum$VulnerabilitySeverity.$unknown;
  }
}

enum Enum$VulnerabilitySort {
  severity_desc,
  severity_asc,
  detected_desc,
  detected_asc,
  $unknown
}

String toJson$Enum$VulnerabilitySort(Enum$VulnerabilitySort e) {
  switch (e) {
    case Enum$VulnerabilitySort.severity_desc:
      return r'severity_desc';
    case Enum$VulnerabilitySort.severity_asc:
      return r'severity_asc';
    case Enum$VulnerabilitySort.detected_desc:
      return r'detected_desc';
    case Enum$VulnerabilitySort.detected_asc:
      return r'detected_asc';
    case Enum$VulnerabilitySort.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilitySort fromJson$Enum$VulnerabilitySort(String value) {
  switch (value) {
    case r'severity_desc':
      return Enum$VulnerabilitySort.severity_desc;
    case r'severity_asc':
      return Enum$VulnerabilitySort.severity_asc;
    case r'detected_desc':
      return Enum$VulnerabilitySort.detected_desc;
    case r'detected_asc':
      return Enum$VulnerabilitySort.detected_asc;
    default:
      return Enum$VulnerabilitySort.$unknown;
  }
}

enum Enum$VulnerabilityState {
  CONFIRMED,
  DETECTED,
  DISMISSED,
  RESOLVED,
  $unknown
}

String toJson$Enum$VulnerabilityState(Enum$VulnerabilityState e) {
  switch (e) {
    case Enum$VulnerabilityState.CONFIRMED:
      return r'CONFIRMED';
    case Enum$VulnerabilityState.DETECTED:
      return r'DETECTED';
    case Enum$VulnerabilityState.DISMISSED:
      return r'DISMISSED';
    case Enum$VulnerabilityState.RESOLVED:
      return r'RESOLVED';
    case Enum$VulnerabilityState.$unknown:
      return r'$unknown';
  }
}

Enum$VulnerabilityState fromJson$Enum$VulnerabilityState(String value) {
  switch (value) {
    case r'CONFIRMED':
      return Enum$VulnerabilityState.CONFIRMED;
    case r'DETECTED':
      return Enum$VulnerabilityState.DETECTED;
    case r'DISMISSED':
      return Enum$VulnerabilityState.DISMISSED;
    case r'RESOLVED':
      return Enum$VulnerabilityState.RESOLVED;
    default:
      return Enum$VulnerabilityState.$unknown;
  }
}

enum Enum$WeightWildcardId { NONE, ANY, $unknown }

String toJson$Enum$WeightWildcardId(Enum$WeightWildcardId e) {
  switch (e) {
    case Enum$WeightWildcardId.NONE:
      return r'NONE';
    case Enum$WeightWildcardId.ANY:
      return r'ANY';
    case Enum$WeightWildcardId.$unknown:
      return r'$unknown';
  }
}

Enum$WeightWildcardId fromJson$Enum$WeightWildcardId(String value) {
  switch (value) {
    case r'NONE':
      return Enum$WeightWildcardId.NONE;
    case r'ANY':
      return Enum$WeightWildcardId.ANY;
    default:
      return Enum$WeightWildcardId.$unknown;
  }
}

enum Enum$WorkItemSort {
  TITLE_ASC,
  TITLE_DESC,
  updated_desc,
  updated_asc,
  created_desc,
  created_asc,
  UPDATED_DESC,
  UPDATED_ASC,
  CREATED_DESC,
  CREATED_ASC,
  $unknown
}

String toJson$Enum$WorkItemSort(Enum$WorkItemSort e) {
  switch (e) {
    case Enum$WorkItemSort.TITLE_ASC:
      return r'TITLE_ASC';
    case Enum$WorkItemSort.TITLE_DESC:
      return r'TITLE_DESC';
    case Enum$WorkItemSort.updated_desc:
      return r'updated_desc';
    case Enum$WorkItemSort.updated_asc:
      return r'updated_asc';
    case Enum$WorkItemSort.created_desc:
      return r'created_desc';
    case Enum$WorkItemSort.created_asc:
      return r'created_asc';
    case Enum$WorkItemSort.UPDATED_DESC:
      return r'UPDATED_DESC';
    case Enum$WorkItemSort.UPDATED_ASC:
      return r'UPDATED_ASC';
    case Enum$WorkItemSort.CREATED_DESC:
      return r'CREATED_DESC';
    case Enum$WorkItemSort.CREATED_ASC:
      return r'CREATED_ASC';
    case Enum$WorkItemSort.$unknown:
      return r'$unknown';
  }
}

Enum$WorkItemSort fromJson$Enum$WorkItemSort(String value) {
  switch (value) {
    case r'TITLE_ASC':
      return Enum$WorkItemSort.TITLE_ASC;
    case r'TITLE_DESC':
      return Enum$WorkItemSort.TITLE_DESC;
    case r'updated_desc':
      return Enum$WorkItemSort.updated_desc;
    case r'updated_asc':
      return Enum$WorkItemSort.updated_asc;
    case r'created_desc':
      return Enum$WorkItemSort.created_desc;
    case r'created_asc':
      return Enum$WorkItemSort.created_asc;
    case r'UPDATED_DESC':
      return Enum$WorkItemSort.UPDATED_DESC;
    case r'UPDATED_ASC':
      return Enum$WorkItemSort.UPDATED_ASC;
    case r'CREATED_DESC':
      return Enum$WorkItemSort.CREATED_DESC;
    case r'CREATED_ASC':
      return Enum$WorkItemSort.CREATED_ASC;
    default:
      return Enum$WorkItemSort.$unknown;
  }
}

enum Enum$WorkItemState { OPEN, CLOSED, $unknown }

String toJson$Enum$WorkItemState(Enum$WorkItemState e) {
  switch (e) {
    case Enum$WorkItemState.OPEN:
      return r'OPEN';
    case Enum$WorkItemState.CLOSED:
      return r'CLOSED';
    case Enum$WorkItemState.$unknown:
      return r'$unknown';
  }
}

Enum$WorkItemState fromJson$Enum$WorkItemState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$WorkItemState.OPEN;
    case r'CLOSED':
      return Enum$WorkItemState.CLOSED;
    default:
      return Enum$WorkItemState.$unknown;
  }
}

enum Enum$WorkItemStateEvent { REOPEN, CLOSE, $unknown }

String toJson$Enum$WorkItemStateEvent(Enum$WorkItemStateEvent e) {
  switch (e) {
    case Enum$WorkItemStateEvent.REOPEN:
      return r'REOPEN';
    case Enum$WorkItemStateEvent.CLOSE:
      return r'CLOSE';
    case Enum$WorkItemStateEvent.$unknown:
      return r'$unknown';
  }
}

Enum$WorkItemStateEvent fromJson$Enum$WorkItemStateEvent(String value) {
  switch (value) {
    case r'REOPEN':
      return Enum$WorkItemStateEvent.REOPEN;
    case r'CLOSE':
      return Enum$WorkItemStateEvent.CLOSE;
    default:
      return Enum$WorkItemStateEvent.$unknown;
  }
}

enum Enum$WorkItemWidgetType {
  WEIGHT,
  VERIFICATION_STATUS,
  ASSIGNEES,
  LABELS,
  DESCRIPTION,
  HIERARCHY,
  START_AND_DUE_DATE,
  $unknown
}

String toJson$Enum$WorkItemWidgetType(Enum$WorkItemWidgetType e) {
  switch (e) {
    case Enum$WorkItemWidgetType.WEIGHT:
      return r'WEIGHT';
    case Enum$WorkItemWidgetType.VERIFICATION_STATUS:
      return r'VERIFICATION_STATUS';
    case Enum$WorkItemWidgetType.ASSIGNEES:
      return r'ASSIGNEES';
    case Enum$WorkItemWidgetType.LABELS:
      return r'LABELS';
    case Enum$WorkItemWidgetType.DESCRIPTION:
      return r'DESCRIPTION';
    case Enum$WorkItemWidgetType.HIERARCHY:
      return r'HIERARCHY';
    case Enum$WorkItemWidgetType.START_AND_DUE_DATE:
      return r'START_AND_DUE_DATE';
    case Enum$WorkItemWidgetType.$unknown:
      return r'$unknown';
  }
}

Enum$WorkItemWidgetType fromJson$Enum$WorkItemWidgetType(String value) {
  switch (value) {
    case r'WEIGHT':
      return Enum$WorkItemWidgetType.WEIGHT;
    case r'VERIFICATION_STATUS':
      return Enum$WorkItemWidgetType.VERIFICATION_STATUS;
    case r'ASSIGNEES':
      return Enum$WorkItemWidgetType.ASSIGNEES;
    case r'LABELS':
      return Enum$WorkItemWidgetType.LABELS;
    case r'DESCRIPTION':
      return Enum$WorkItemWidgetType.DESCRIPTION;
    case r'HIERARCHY':
      return Enum$WorkItemWidgetType.HIERARCHY;
    case r'START_AND_DUE_DATE':
      return Enum$WorkItemWidgetType.START_AND_DUE_DATE;
    default:
      return Enum$WorkItemWidgetType.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{
  'NoteableInterface': {
    'AlertManagementAlert',
    'BoardEpic',
    'Design',
    'Epic',
    'EpicIssue',
    'Issue',
    'MergeRequest',
    'Snippet',
    'Vulnerability',
  },
  'Todoable': {
    'AlertManagementAlert',
    'BoardEpic',
    'Commit',
    'Design',
    'Epic',
    'EpicIssue',
    'Issue',
    'MergeRequest',
  },
  'AlertManagementIntegration': {
    'AlertManagementHttpIntegration',
    'AlertManagementPrometheusIntegration',
  },
  'Service': {
    'BaseService',
    'JiraService',
  },
  'Entry': {
    'Blob',
    'Submodule',
    'TreeEntry',
  },
  'CurrentUserTodos': {
    'BoardEpic',
    'Design',
    'Epic',
    'EpicIssue',
    'Issue',
    'MergeRequest',
  },
  'Eventable': {
    'BoardEpic',
    'Epic',
  },
  'CiVariable': {
    'CiGroupVariable',
    'CiInstanceVariable',
    'CiManualVariable',
    'CiProjectVariable',
  },
  'PackageFileMetadata': {
    'ConanFileMetadata',
    'HelmFileMetadata',
  },
  'DesignFields': {
    'Design',
    'DesignAtVersion',
  },
  'ResolvableInterface': {
    'Discussion',
    'Note',
  },
  'MemberInterface': {
    'GroupMember',
    'ProjectMember',
  },
  'TimeboxReportInterface': {
    'Iteration',
    'Milestone',
  },
  'User': {
    'MergeRequestAssignee',
    'MergeRequestAuthor',
    'MergeRequestParticipant',
    'MergeRequestReviewer',
    'UserCore',
  },
  'OrchestrationPolicy': {
    'ScanExecutionPolicy',
    'ScanResultPolicy',
  },
  'WorkItemWidget': {
    'WorkItemWidgetAssignees',
    'WorkItemWidgetDescription',
    'WorkItemWidgetHierarchy',
    'WorkItemWidgetLabels',
    'WorkItemWidgetStartAndDueDate',
    'WorkItemWidgetVerificationStatus',
    'WorkItemWidgetWeight',
  },
  'DependencyLinkMetadata': {'NugetDependencyLinkMetadata'},
  'Issuable': {
    'Epic',
    'Issue',
    'MergeRequest',
    'WorkItem',
  },
  'JobNeedUnion': {
    'CiBuildNeed',
    'CiJob',
  },
  'NoteableType': {
    'Design',
    'Issue',
    'MergeRequest',
  },
  'PackageMetadata': {
    'ComposerMetadata',
    'ConanMetadata',
    'MavenMetadata',
    'NugetMetadata',
    'PypiMetadata',
  },
  'SecurityPolicySource': {
    'GroupSecurityPolicySource',
    'ProjectSecurityPolicySource',
  },
  'VulnerabilityDetail': {
    'VulnerabilityDetailBase',
    'VulnerabilityDetailBoolean',
    'VulnerabilityDetailCode',
    'VulnerabilityDetailCommit',
    'VulnerabilityDetailDiff',
    'VulnerabilityDetailFileLocation',
    'VulnerabilityDetailInt',
    'VulnerabilityDetailList',
    'VulnerabilityDetailMarkdown',
    'VulnerabilityDetailModuleLocation',
    'VulnerabilityDetailTable',
    'VulnerabilityDetailText',
    'VulnerabilityDetailUrl',
  },
  'VulnerabilityLocation': {
    'VulnerabilityLocationClusterImageScanning',
    'VulnerabilityLocationContainerScanning',
    'VulnerabilityLocationCoverageFuzzing',
    'VulnerabilityLocationDast',
    'VulnerabilityLocationDependencyScanning',
    'VulnerabilityLocationGeneric',
    'VulnerabilityLocationSast',
    'VulnerabilityLocationSecretDetection',
  },
};
